<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard - EstadÃ­sticas</title>

  <!-- Estilos base y sidebar -->
  <link rel="stylesheet" href="css/theme.css">
  <link rel="stylesheet" href="css/sidebar-shared.css">

  <!-- LibrerÃ­as -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

  <!-- Scripts de app -->
  <!-- Cargar primero las dependencias -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- ChartDataLabels removido - causaba etiquetas duplicadas -->
  <!-- Eliminado kit de Font Awesome (403). Se usa el CSS 5.15.4 ya cargado arriba. -->
  
  <!-- Luego cargar los scripts de la aplicaciÃ³n -->
  <script src="/js/logout-handler.js"></script>
  <script src="/js/user-info.js"></script>
  <script src="/utils/teams.js"></script>
  <script src="js/sidebar-loader.js"></script>
  
  <!-- Script de inicializaciÃ³n de grÃ¡ficos -->
  <script>
    // Verificar que Chart.js estÃ© disponible
    if (typeof Chart === 'undefined') {
      console.error('Error: No se pudo cargar Chart.js');
    } else {
      console.log('Chart.js cargado correctamente');
    }

    // Marcar inicialización de porcentaje para evitar dibujar donuts provisionales
    try { window.__porcIsInitializing = true; try { if (typeof showPorcSpinner === 'function') showPorcSpinner(true); } catch(_){} } catch(_){ }

    // Lista/modal de equipos y render por equipo removidos: la vista por defecto es "Mostrar todos".
  </script>
  
  <style>
    /* Layout general consistente con otras pÃ¡ginas */
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f7fa; color: #1e293b; }

    .layout { display: flex; min-height: 100vh; }

    .main-content {
      flex: 1;
      padding: 20px;
      display: flex;
      flex-direction: column;
    }
    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }
    .page-title { font-size: 1.8rem; font-weight: 800; margin: 0; }
    .page-actions { display: flex; gap: 8px; }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 24px;
      max-width: 95%;
      margin: 0 auto;
      padding: 0 20px;
      width: 100%;
      box-sizing: border-box;
    }

    .card {
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      padding: 24px;
      box-sizing: border-box;
      width: 100%;
      margin: 0;
    }

    .chart-card { grid-column: span 12; }
    @media (min-width: 900px) {
      .chart-card.half { grid-column: span 6; }
    }

    .card h3 { margin: 0 0 12px 0; font-size: 1.05rem; color: #1e293b; }
    /* Spinner overlay for porcentaje donut */
    .porc-spinner-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 30;
      pointer-events: none;
      background: rgba(255,255,255,0.0);
    }
    .porc-spinner {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 4px solid rgba(16,24,40,0.08);
      border-top-color: rgba(16,24,40,0.65);
      animation: porc-spin 900ms linear infinite;
      box-shadow: 0 2px 6px rgba(2,6,23,0.08);
      pointer-events: none;
    }
    @keyframes porc-spin { to { transform: rotate(360deg); } }
    
    /* Estilos para la tabla de calificaciones */
    .ventas-diarias-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      margin-top: 10px;
      width: 100%;
    }
    
    .ventas-diarias-card {
      background: white;
      border-radius: 4px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      width: 100%;
    }
    
    .ventas-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 0 auto;
    }
    
    .ventas-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem;
      table-layout: fixed;
    }
    
    .ventas-table th,
    .ventas-table td {
      padding: 14px 20px;
      text-align: left;
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
      line-height: 1.5;
    }
    
    .ventas-table th {
      background: #1f3b63;
      color: #fff;
      font-weight: 700;
      text-transform: uppercase;
      text-align: center;
      padding: 16px 20px;
      font-size: 0.9rem;
      letter-spacing: 0.5px;
    }
    
    .ventas-table td:first-child {
      width: 65%;
      padding-left: 16px;
    }
    
    .ventas-table td:last-child {
      width: 35%;
      text-align: center;
      font-weight: bold;
      padding-right: 16px;
    }
    .chart-wrapper { position: relative; height: 320px; }

    /* Responsive para mÃ³vil: sidebar superior */
    @media (max-width: 768px) {
      .main-content { margin-left: 0; width: 100%; padding: 15px; margin-top: 70px; }
    }
    /* Tabla de conversiÃ³n por equipo */
    .conversion-grid { 
      display: grid; 
      grid-template-columns: 2fr 1fr; 
      gap: 8px; 
      font-family: Arial, sans-serif;
    }
    .conversion-card { 
      background: #fff; 
      border-radius: 8px; 
      box-shadow: 0 2px 6px rgba(0,0,0,0.1); 
      padding: 12px; 
      border: 1px solid #dee2e6;
    }
  /* Tabla de conversión visible por defecto (se muestra debajo de las gráficas) */
    .conversion-title { 
      font-weight: 800; 
      margin: 0 0 8px 0; 
      color: #000; 
      font-size: 1rem;
      text-align: center;
      background: #fff9c2;
      padding: 6px 4px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .conversion-subtitle { 
      display: none; 
    }
    .sales-table { 
      width: 100%; 
      border-collapse: collapse; 
      font-size: 0.85rem;
      margin-bottom: 0;
    }
    .sales-table th, 
    .sales-table td { 
      padding: 4px 6px; 
      text-align: center; 
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
      height: 28px;
    }
    .sales-table th { 
      background: #1f3b63; 
      color: #fff; 
      font-weight: 700; 
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 6px 4px;
    }
    .sales-table td:first-child, 
    .sales-table th:first-child { 
      text-align: left; 
      padding-left: 8px;
      width: 40%;
    }
    .sales-table .total-row { 
      background: #0b5ed7; 
      color: #fff; 
      font-weight: 800; 
      font-size: 0.9rem;
    }
    .sales-table .score-col { 
      background: #ffeb7a; 
      font-weight: 800; 
      color: #000;
    }
    /* Layout mejorado para conversión: tabla + panel LINEAS (Grid asegura uso total de ancho) */
    .conv-two-col { display: grid; grid-template-columns: 640px 200px; gap: 8px; align-items: stretch; width: 848px; margin: 0 auto; }
    .conv-left { min-width: 640px; max-width: 640px; width: 640px; max-height: 520px; overflow-y: auto; overflow-x: hidden; margin: 0; padding: 0; }
    .conv-left .sales-table { width: 100% !important; table-layout: fixed; }
    .conv-right { width: 200px; min-width: 200px; max-width: 200px; }
    /* Igualar ancho de contenedores MES y DÍA */
    .conversion-card { width: 848px; max-width: 848px; min-width: 848px; margin: 0 auto; }
    #ventas-dia-card { width: 848px; max-width: 848px; min-width: 848px; margin: 0 auto; }
    /* Quitar contenedores externos (solo dentro de la sección MES/DÍA) */
    #mes-dia-section > .card {
      background: transparent !important;
      box-shadow: none !important;
      border: 0 !important;
      padding: 0 !important;
      margin: 0 auto !important;
      display: flex;
      justify-content: center;
    }
    #mes-dia-section > .card > h3 { display: none !important; }
    #mes-dia-section > .card > div { 
      margin: 0 auto;
      display: flex;
      justify-content: center;
    }
    /* Quitar cualquier tarjeta interna generada por el renderer del MES o del DÍA */
    #mes-dia-section .conversion-card,
    #mes-dia-section .ventas-diarias-card {
      background: transparent !important;
      box-shadow: none !important;
      border: 0 !important;
      padding: 0 !important;
      margin: 0 auto !important;
    }
    .mini-card { background: #fff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 8px; }
    .mini-card .mini-table { width: 100%; }
    .mini-card .mini-table th { padding: 12px; font-size: 0.9rem; }
    .mini-card .mini-table td { padding: 10px 12px; font-size: 1rem; text-align: center; }
    @media (max-width: 900px) { 
      .conv-two-col { display: block; width: 100%; } 
      .conv-left { min-width: 0; width: 100%; max-width: 100%; } 
      .conv-right { width: 100%; min-width: 0; max-width: 100%; } 
      .conversion-card { width: 100% !important; max-width: 100% !important; min-width: 0 !important; }
      #ventas-dia-card { width: 100% !important; max-width: 100% !important; min-width: 0 !important; }
    }
    .mini-table { 
      width: 100%; 
      border-collapse: collapse; 
      font-size: 0.85rem;
      margin-top: 15px;
    }
    .mini-table th, 
    .mini-table td { 
      padding: 4px 6px; 
      text-align: center; 
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
      height: 28px;
    }
    .mini-table th { 
      background: #1f3b63; 
      color: #fff; 
      font-weight: 700;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 6px 4px;
    }
    .mini-table .total { 
      background: #0b5ed7; 
      color: #fff; 
      font-weight: 800;
      font-size: 0.9rem;
    }
    @media (max-width: 900px) { 
      .conversion-grid { 
        grid-template-columns: 1fr; 
      }
      .ventas-diarias-grid { 
        grid-template-columns: 1fr; 
      }
    }
    
    /* Estilos para la secciÃ³n de Ventas Diarias */
    .ventas-diarias-grid {
      display: grid;
      gap: 16px;
      margin-top: 10px;
    }
    
    .ventas-diarias-card {
      background: white;
      border-radius: 4px;
      padding: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    /* Animaciones tipo carrusel */
    .slide-container { position: relative; overflow: hidden; }
    .slide-card { transition: transform 280ms ease, opacity 280ms ease; will-change: transform, opacity; }
    .flip-viewport { perspective: 1200px; position: relative; width: 100%; }
    .flip-scene { position: relative; width: 100%; height: 100%; transform-style: preserve-3d; transition: transform 0.8s ease; }
    .flip-face { position: absolute; inset: 0; width: 100%; height: 100%; backface-visibility: hidden; -webkit-backface-visibility: hidden; }
    .slide-exit-left { transform: translateX(-20%); opacity: 0; }
    .slide-exit-right { transform: translateX(20%); opacity: 0; }
    .slide-enter-base { transform: translateX(0); opacity: 0; }
    .slide-enter-from-left { transform: translateX(-20%); opacity: 0; }
    .slide-enter-from-right { transform: translateX(20%); opacity: 0; }
    .slide-enter-active { transform: translateX(0); opacity: 1; }
    
    .ventas-title {
      font-weight: 800;
      margin: 0 0 10px 0;
      color: #000;
      font-size: 1rem;
      text-align: center;
      background: #fff9c2;
      padding: 6px 4px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Botones flecha para navegación de meses (solo íconos) dentro de tarjetas */
    .porc-nav { display:flex; gap:8px; align-items:center; }
    .porc-nav .porc-arrow { background:#e6eef9; border:1px solid #cfe0fa; color:#0f172a; width:34px; height:34px; border-radius:6px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; font-weight:700; }
    .porc-nav .porc-arrow:hover { background:#d0e7ff; }
    
    .ventas-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin-bottom: 15px;
    }
    
    .ventas-table th,
    .ventas-table td {
      padding: 6px 8px;
      text-align: center;
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
    }
    
    .ventas-table th {
      background: #1f3b63;
      color: #fff;
      font-weight: 700;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 8px 4px;
    }
    
    .ventas-table td:first-child {
      text-align: left;
      padding-left: 10px;
    }
    
    .ventas-table .total-row {
      background: #0b5ed7;
      color: #fff;
      font-weight: 800;
      font-size: 0.9rem;
    }
    
    .ventas-table .score-col {
      background: #ffeb7a;
      font-weight: 800;
      color: #000;
    }
    
    /* Estilos para grÃ¡ficos */
    .chart-card {
      grid-column: 1 / -1;
      margin-bottom: 20px;
    }
    /* Excepción: las tarjetas dentro de #top-charts usan su propio grid (2 columnas)
       Evitamos que la regla global .chart-card las fuerce a 1 columna */
    #top-charts-combined {
      width: 100%;
      max-width: 100%;
      margin: 0 auto 20px auto;
      padding: 20px;
      grid-column: 1 / -1;
    }
    #top-charts-inner {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      align-items: start;
    }
    .top-chart-section {
      min-width: 0;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    .top-chart-section.porcentaje-section {
      display: flex;
      flex-direction: column;
    }
    .top-chart-section.porcentaje-section .chart-subtitle {
      margin-bottom: 15px;
    }
    .porcentaje-content {
      display: flex;
      flex-direction: row;
      gap: 20px;
      align-items: flex-start;
    }
    .porcentaje-left {
      width: 200px;
      min-width: 200px;
      flex-shrink: 0;
    }
    .porcentaje-right {
      flex: 1;
      min-width: 0;
    }
    /* Estilos para Ventas Activas (similar a Porcentaje) */
    .top-chart-section.ventas-activas-section {
      display: flex;
      flex-direction: column;
    }
    .top-chart-section.ventas-activas-section .chart-subtitle {
      margin-bottom: 15px;
    }
    .ventas-activas-content {
      display: flex;
      flex-direction: row;
      gap: 20px;
      align-items: flex-start;
    }
    .ventas-activas-left {
      width: 200px;
      min-width: 200px;
      flex-shrink: 0;
    }
    .ventas-activas-right {
      flex: 1;
      min-width: 0;
    }
    .chart-subtitle {
      font-size: 1rem;
      font-weight: 600;
      color: #1f3b63;
      margin: 0 0 15px 0;
      padding-bottom: 10px;
      border-bottom: 2px solid #e5e7eb;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .chart-subtitle i {
      color: #22b3ec;
    }
    .top-chart-section .chart-wrapper {
      height: 400px;
      min-height: 400px;
      position: relative;
    }
    @media (max-width: 1200px) {
      #top-charts-inner {
        grid-template-columns: 1fr;
        gap: 40px;
      }
    }

    /* Excepción: fila de Ventas y Productos (dos columnas al mismo nivel) */
    #ventas-products-row .chart-card { grid-column: auto !important; }
  /* match altura de .graph-container para que queden alineados */
  #ventas-products-row .chart-wrapper { min-height: 360px; height: 420px; }
  #ventas-products-row .graph-container { height: 420px; }
  /* asegurar que el canvas llene el wrapper (override inline/Chart.js sizing) */
  #ventas-products-row .chart-wrapper canvas { width: 100% !important; height: 100% !important; display: block; }
    @media (max-width: 900px) {
      /* en pantallas pequeñas, apilar una columna para mejor lectura */
      #ventas-products-row { grid-template-columns: 1fr !important; }
    }
    
    .chart-wrapper {
      position: relative;
      height: 400px;
      width: 100%;
      min-height: 300px;
    }
    
    .chart-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      padding: 20px;
      text-align: center;
      color: #666;
    }
    
    .chart-loading .spinner-border {
      width: 3rem;
      height: 3rem;
    }
    
    .alert {
      padding: 15px;
      margin-bottom: 20px;
      border: 1px solid transparent;
      border-radius: 4px;
    }
    
    .alert-danger {
      color: #721c24;
      background-color: #f8d7da;
      border-color: #f5c6cb;
    }

    /* Estilos para la nueva gráfica de ventas y puntaje */
    .date-filter-container {
      width: fit-content;
      margin-bottom: 15px;
      background: #f8fafc;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }
    
    .date-filter {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
    }
    
    .date-filter label {
      color: #475569;
      font-weight: 500;
      margin-right: 2px;
      font-size: 12px;
      white-space: nowrap;
    }
    
    .date-select {
      padding: 2px 6px;
      border: 1px solid #cbd5e1;
      border-radius: 4px;
      background-color: white;
      font-size: 12px;
      width: 70px;
      height: 26px;
    }
    
    .filter-button {
      padding: 2px 8px;
      background-color: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 11px;
      height: 26px;
      white-space: nowrap;
      transition: background-color 0.2s;
    }
    
    .filter-button:hover {
      background-color: #2563eb;
    }
    
    #reset-filter {
      background-color: #64748b;
      padding: 2px 6px;
    }
    
    #reset-filter:hover {
      background-color: #475569;
    }

    .graph-container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
      width: 100%;
      height: 420px;
      max-height: 420px;
      position: relative;
    }
    
    .graph-canvas {
      width: 100% !important;
      height: 100% !important;
      min-height: 360px;
    }

    /* Estilos para notificaciones */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 25px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      display: flex;
      align-items: center;
      transform: translateX(120%);
      transition: transform 0.3s ease-in-out;
      max-width: 350px;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success {
      background-color: #10b981;
      border-left: 4px solid #059669;
    }

    .notification.error {
      background-color: #ef4444;
      border-left: 4px solid #dc2626;
    }

    .notification i {
      margin-right: 10px;
      font-size: 20px;
    }
    
    /* Estilos para el modal de detalle del día */
    .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
    .modal{background:#fff;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.2);max-width:960px;width:92%;max-height:80vh;overflow:auto}
    .modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e2e8f0;font-weight:800}
    .modal-body{padding:12px 16px}
    .close-btn{border:none;background:#e11d48;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
    .table-compact{width:100%;border-collapse:collapse;font-size:.9rem}
    .table-compact th,.table-compact td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left}
    .table-compact th{background:#1f3b63;color:#fff}
    .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  </style>
</head>
<body>
  <div class="layout">
    <!-- SIDEBAR (cargado dinÃ¡micamente) -->
    <nav class="sidebar sidebar-inicio" data-active="estadisticas"></nav>

    <main class="main-content">
      <header class="page-header">
        <h1 class="page-title"><i class="fas fa-chart-line" style="color:#22b3ec; margin-right:8px;"></i> Estadísticas</h1>
        <div class="page-actions">
          <button id="btn-refresh" class="btn-refresh" style="background:#22b3ec;color:#fff;border:none;border-radius:8px;padding:8px 12px;font-weight:600;cursor:pointer;">Actualizar</button>
        </div>
      </header>

      <section class="stats-grid">
        <!-- STAGE 1: Combined top chart - Porcentaje de Activación y Ventas Activas del mes -->
        <div id="top-charts-combined" class="card chart-card">
          <h3 style="text-align:center; margin-bottom:20px;">
            <i class="fas fa-chart-pie" style="color:#22b3ec; margin-right:8px;"></i> 
            Estadísticas del Mes
          </h3>
          <div id="top-charts-inner">
            <!-- Gráfico izquierdo: Porcentaje de Activación -->
            <div class="top-chart-section porcentaje-section">
              <h4 class="chart-subtitle"><i class="fas fa-percent"></i> Porcentaje de Activación</h4>
              <div class="porcentaje-content">
                <div class="porcentaje-left">
                  <div id="porc-team-list" style="display:flex; flex-direction:column; gap:6px; max-height:400px; overflow:auto;"></div>
                  <div id="porc-activas-note" style="font-size:0.9rem;color:#374151; margin-top: 10px;"></div>
                </div>
                <div class="porcentaje-right">
                  <div class="chart-wrapper">
                    <canvas id="chart-porcentaje-activacion"></canvas>
                  </div>
                </div>
              </div>
            </div>

            <!-- Gráfico derecho: Ventas Activas -->
            <div class="top-chart-section ventas-activas-section">
              <h4 class="chart-subtitle"><i class="fas fa-chart-bar"></i> Ventas Activas</h4>
              <div class="ventas-activas-content">
                <div class="ventas-activas-left">
                  <div id="ventas-activas-team-list" style="display:flex; flex-direction:column; gap:6px; max-height:400px; overflow:auto;"></div>
                  <div id="ventas-activas-note" style="font-size:0.9rem;color:#374151; margin-top: 10px;"></div>
                </div>
                <div class="ventas-activas-right">
                  <div class="chart-wrapper">
                    <canvas id="chart-ventas-activas-mes"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div id="mes-dia-section" style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; grid-column: 1 / -1; width: 100%; margin: 0; padding: 0;">
          <div class="card">
            <h3></h3>
            <div id="conversion-table" class="conversion-grid"></div>
          </div>

          <div class="card">
            <div class="ventas-diarias-grid">
              <div id="ventas-dia-card" class="ventas-diarias-card"><!-- Renderizado por JS --></div>
            </div>
          </div>
        </div>

        <!-- Nueva Sección: Gráfica de Ventas y Puntaje (Últimos 7 días) + Productos vendidos en el mes -->
  <div id="ventas-products-row" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; grid-column: 1 / -1; width: 100%; margin: 0; padding: 0;">
          <div class="card chart-card">
            <h3><i class="fas fa-chart-bar" style="color:#22b3ec; margin-right:8px;"></i> Ventas y Puntaje - Últimos 7 días</h3>
            
            <!-- Filtro de Fecha -->
            <div class="date-filter-container" style="margin-bottom: 20px;">
              <div class="date-filter">
                <label for="month-select">Mes:</label>
                <select id="month-select" class="date-select">
                  <option value="0">Enero</option>
                  <option value="1">Febrero</option>
                  <option value="2">Marzo</option>
                  <option value="3">Abril</option>
                  <option value="4">Mayo</option>
                  <option value="5">Junio</option>
                  <option value="6">Julio</option>
                  <option value="7">Agosto</option>
                  <option value="8">Septiembre</option>
                  <option value="9">Octubre</option>
                  <option value="10">Noviembre</option>
                  <option value="11">Diciembre</option>
                </select>
                
                <label for="day-select">Día:</label>
                <select id="day-select" class="date-select">
                  <!-- Los días se llenarán dinámicamente -->
                </select>
                
                <label for="year-select">Año:</label>
                <select id="year-select" class="date-select">
                  <option value="2023">2023</option>
                  <option value="2024">2024</option>
                  <option value="2025" selected>2025</option>
                  <option value="2026">2026</option>
                </select>
                
                <button id="apply-filter" class="filter-button">Aplicar Filtro</button>
                <button id="reset-filter" class="filter-button">Hoy</button>
              </div>
            </div>

            <!-- Gráfica de Ventas y Puntaje -->
            <div class="graph-container">
              <canvas id="ventasPuntajeChart" class="graph-canvas"></canvas>
            </div>
          </div>

          <div class="card chart-card">
            <div style="display:flex; align-items:center; justify-content:space-between; padding:8px 12px; background:#fef3c7; border-radius:8px 8px 0 0;">
              <button id="products-prev" class="filter-button" style="height:32px;width:32px;font-size:16px;" title="Mes anterior">◀</button>
              <div id="products-month-title" class="conversion-title" style="margin:0;">Productos vendidos en Noviembre 2025</div>
              <button id="products-next" class="filter-button" style="height:32px;width:32px;font-size:16px;" title="Mes siguiente">▶</button>
            </div>
            <div class="chart-wrapper">
              <canvas id="productsChart"></canvas>
            </div>
          </div>
        </div>
      </div>
      </section>
    </main>
  </div>

  <!-- Modal de detalle del día -->
  <div id="day-detail-modal" class="modal-overlay">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="dayDetailTitle">
      <div class="modal-header">
        <div id="dayDetailTitle">Detalle de Ventas del Día</div>
        <button class="close-btn" id="day-detail-close">Cerrar</button>
      </div>
      <div class="modal-body">
        <div class="toolbar">
          <label for="filter-team-select" style="font-weight:600">Equipo:</label>
          <select id="filter-team-select"></select>
          <span id="day-detail-subtitle" style="margin-left:auto;color:#475569"></span>
        </div>
        <div style="overflow:auto">
          <table class="table-compact" id="day-detail-table">
            <thead>
              <tr>
                <th>Equipo</th>
                <th>Agente</th>
                <th>Servicio</th>
                <th>Mercado</th>
                <th>Puntaje</th>
                <th>Fecha</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Datos de ejemplo para visualizaciÃ³n inicial (puedes reemplazar por datos reales)
    function rand(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }  
    function rand(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }  

    async function renderConversionTable(root) {
      try {
        console.log('Iniciando renderConversionTable con root:', root);
        if (!root) {
          console.error('Error: No se proporcionÃ³ un elemento raÃ­z vÃ¡lido');
          return;
        }
        
        // Verificar autenticaciÃ³n
        if (!checkAuth()) return;
        
        // Mostrar indicador de carga
        root.innerHTML = '<div class="text-center py-4"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Cargando...</span></div><p class="mt-2">Cargando datos de equipos...</p></div>';
        
        // Leer parámetro ?m= si existe para navegación de mes
        const urlParams = new URLSearchParams(location.search);
        const mParam = urlParams.get('m');
        let targetMonth;
        if (mParam && /^\d{4}-\d{2}$/.test(mParam)) {
          const [y,m] = mParam.split('-').map(Number);
          targetMonth = new Date(y, m-1, 15, 12, 0, 0);
          console.log('[ESTADISTICAS] Navegando a mes:', mParam, targetMonth);
        } else {
          targetMonth = new Date();
          console.log('[ESTADISTICAS] Sin parámetro de mes, usando mes actual:', targetMonth);
        }
        // Rango del MES COMPLETO (desde día 1 hasta último día del mes)
        let fechaInicio = '';
        let fechaFin = '';
        {
          const primerDiaMes = new Date(targetMonth.getFullYear(), targetMonth.getMonth(), 1);
          const ultimoDiaMes = new Date(targetMonth.getFullYear(), targetMonth.getMonth() + 1, 0);
          const fmt = (d)=>`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
          fechaInicio = fmt(primerDiaMes);
          fechaFin = fmt(ultimoDiaMes);
          console.log('[ESTADISTICAS] Rango mes completo:', { mes: `${targetMonth.getMonth()+1}/${targetMonth.getFullYear()}`, fechaInicio, fechaFin });
        }
        
        // Construir URL con parámetros
        let url = '/api/equipos/estadisticas';
        const params = new URLSearchParams();
        
        if (fechaInicio) params.append('fechaInicio', fechaInicio);
        if (fechaFin) params.append('fechaFin', fechaFin);
        // Si el rol es agente, forzar que el backend devuelva TODOS los equipos
        try {
          const u = JSON.parse(sessionStorage.getItem('user') || localStorage.getItem('user') || 'null');
          const role = (u?.role || '').toString().trim().toLowerCase();
          if (role === 'agent' || role === 'agente') params.append('forceAll', '1');
        } catch(_){ }
        
        // Agregar parámetros a la URL
        if (params.toString()) {
          url += '?' + params.toString();
        }
        
        console.log('[ESTADISTICAS] Solicitando datos a:', url);
        
        // Realizar petición a la API usando la función fetchWithAuth
        console.log('[ESTADISTICAS] Realizando petición a la API...');
        const response = await fetchWithAuth(url);
        console.log('Respuesta recibida:', response);
        
        if (!response) {
          console.error('No se recibiÃ³ respuesta de la API (posible error de autenticaciÃ³n)');
          return; // Error de autenticaciÃ³n ya manejado
        }
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Error en la respuesta:', {
            status: response.status,
            statusText: response.statusText,
            error: errorText
          });
          throw new Error(`Error HTTP: ${response.status} - ${errorText}`);
        }
        
        let data = await response.json();
        let usedAllFallback = false;
        console.log('Datos recibidos de la API (MES):', {
          success: data.success,
          message: data.message,
          total: data.total,
          data: data.data ? `Array de ${data.data.length} elementos` : 'No hay datos'
        });
        
        // Eliminado fallback all=1 para mostrar solo datos del MES ACTUAL
        
        if (!data.success) {
          console.error('Formato de respuesta invÃ¡lido:', data);
          throw new Error('Formato de respuesta invÃ¡lido');
        }

        
        // Si no hay datos (o según rol), podremos forzar fallback con /api/leads
        let teamData = [];
        // Determinar si el payload está vacío o si trae solo equipos en cero
        const payloadEmpty = !data.data || data.data.length === 0;
        const payloadZero = Array.isArray(data.data) && data.data.length > 0 && data.data.every(e => (Number(e.Total||0) === 0) && (Number(e.ICON||0) === 0) && (Number(e.BAMO||0) === 0) && (Number(e.Puntaje||0) === 0));

        if (!(payloadEmpty || payloadZero)) {
          // Mapear datos de la API al formato esperado (mantener Puntaje como número)
          teamData = data.data.map(equipo => ({
            name: equipo.TEAM || equipo.team || 'Sin equipo',
            ICON: parseFloat(equipo.ICON || 0),
            ACTIVAS: parseFloat(equipo.ACTIVAS || 0),
            BAMO: parseFloat(equipo.BAMO || 0),
            Total: parseFloat(equipo.Total || 0),
            Puntaje: parseFloat(equipo.Puntaje || 0)
          }));
        }

        // Solo fallback si la respuesta viene vacía/cero
        if (payloadEmpty || payloadZero) {
          try {
            console.log('[ESTADISTICAS][MES] Construyendo datos desde /api/leads (fallback por rol o vacío)');
            // Pedimos al endpoint /api/leads el mismo rango que usamos para equipos (fechaInicio/fechaFin)
            const leadsResp = await fetchWithAuth(`/api/leads?fechaInicio=${fechaInicio}&fechaFin=${fechaFin}`);
            if (leadsResp && leadsResp.ok) {
              const leadsJson = await leadsResp.json();
              const leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
              const getByPath = (obj, path) => { try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch(_) { return undefined; } };
              const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
              const teamMap = new Map();
              const teamNameOf = (lead) => {
                const t = findFirst(lead, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']);
                const s = (t || '').toString().trim();
                return s || 'Sin equipo';
              };
              const isICON = (lead) => {
                const v = (findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
                return v.includes('ICON');
              };
              const isBAMO = (lead) => {
                const v = (findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
                return v.includes('BAMO');
              };
              const getPuntaje = (lead) => {
                const p = findFirst(lead, ['puntaje','score','puntos']);
                const n = typeof p === 'number' ? p : parseFloat(p);
                return isNaN(n) ? 0 : n;
              };
              leads.forEach(l => {
                const name = teamNameOf(l);
                if (!teamMap.has(name)) teamMap.set(name, { name, ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });
                const agg = teamMap.get(name);
                agg.Total += 1;
                if (isICON(l)) agg.ICON += 1; else if (isBAMO(l)) agg.BAMO += 1;
                agg.Puntaje += getPuntaje(l);
              });
              teamData = Array.from(teamMap.values());
            }
          } catch (fe) {
            console.warn('[ESTADISTICAS][MES] Fallback por rol/empty falló:', fe);
          }
        }
        // Separar TEAM LINEAS a tabla aparte y mantener principal sin LINEA(S)
        const lineasData = Array.isArray(data.lineas) ? data.lineas.map(r => ({
          name: r.name || r.TEAM || 'SIN NOMBRE',
          ICON: parseFloat(r.ICON || 0)
        })) : [];
        const lineasTotalICON = typeof data.lineasTotalICON === 'number' ? data.lineasTotalICON : lineasData.reduce((acc, r) => acc + (r.ICON || 0), 0);
        const excludeNames = new Set(['TEAM LINEA','TEAM LINEAS']);
        let fallbackTeamData = teamData.filter(t => !excludeNames.has((t.name || '').toUpperCase()));
          // Nota: la verificación de "activas" era realizada en el cliente (consultando /api/leads).
          // Se ha eliminado aquí para evitar llamadas redundantes y condiciones de carrera.
          // El conteo autoritativo de ACTIVAS debe provenir del backend (`/api/equipos/estadisticas`).
        // Fallback: si principal queda vacío o todos son cero, construir desde /api/leads con rango del DÍA efectivo
        const allZero = fallbackTeamData.length > 0 && fallbackTeamData.every(t => Number(t.Total||0) === 0 && Number(t.ICON||0) === 0 && Number(t.BAMO||0) === 0 && Number(t.Puntaje||0) === 0);
        if (fallbackTeamData.length === 0 || allZero) {
          try {
            console.warn('fallbackTeamData vacío. Construyendo desde /api/leads para el día efectivo...');
            // Helpers locales
            const BUSINESS_TZ_OFFSET_MIN = -6 * 60; // ajustar si tu TZ cambia
            const toISOInTZLocal = (date, tzOffsetMinutes) => {
              const target = new Date(date.getTime() + tzOffsetMinutes * 60000);
              const y = target.getUTCFullYear();
              const m = String(target.getUTCMonth() + 1).padStart(2, '0');
              const d = String(target.getUTCDate()).padStart(2, '0');
              return `${y}-${m}-${d}`;
            };
            const getByPath = (obj, path) => {
              try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch (_) { return undefined; }
            };
            const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
            const tryDateFrom = (val) => {
              if (!val) return null; if (typeof val === 'string') { const s = val.trim();
                if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [y,m,d] = s.split('-').map(Number); return new Date(Date.UTC(y, m-1, d, 12, 0, 0)); }
                if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) { const parts = s.split(/[\/\-]/).map(Number); const [d,m,y] = parts; return new Date(Date.UTC(y, m-1, d, 12, 0, 0)); }
              }
              if (typeof val === 'number') return new Date(val < 1e12 ? val*1000 : val);
              const dt = new Date(val); return isNaN(dt) ? null : dt;
            };

            // Rango día efectivo (mismo criterio que arriba)
            const nowLocal = new Date();
            const cutoffHour = 9, cutoffMinute = 30;
            const isBeforeCutoff = (nowLocal.getHours() < cutoffHour) || (nowLocal.getHours() === cutoffHour && nowLocal.getMinutes() < cutoffMinute);
            const effective = new Date(nowLocal);
            if (isBeforeCutoff) effective.setDate(effective.getDate() - 1);
            const startLocal = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate(), 0, 0, 0, 0);
            // SIEMPRE mostrar datos hasta las 9:30 AM del día siguiente (no cortar a la hora actual)
            // Esto permite que los datos se mantengan visibles todo el día hasta el siguiente corte
            const endExclusive = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate() + 1, cutoffHour, cutoffMinute, 0, 0);
            const dayKey = toISOInTZLocal(effective, BUSINESS_TZ_OFFSET_MIN);

            // Obtener leads para el día efectivo (usar dayKey calculado arriba)
            const leadsResp = await fetchWithAuth(`/api/leads?fechaInicio=${dayKey}&fechaFin=${dayKey}`);
            if (leadsResp && leadsResp.ok) {
              const leadsJson = await leadsResp.json();
              let leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
              console.log(`[FALLBACK LEADS] Recibidos ${leads.length} registros`);

              // Filtrar por día efectivo
              const createdPaths = [
                'dia_venta','diaVenta','creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha',
                '_raw.creadoEn','_raw.fecha_creacion','_raw.fechaCreacion','_raw.createdAt','_raw.created_at','_raw.fecha',
                'metadata.createdAt','audit.createdAt','timestamps.createdAt'
              ];

              const inDay = leads.filter(l => {
                const v = findFirst(l, createdPaths);
                const dt = tryDateFrom(v);
                const d = dt && new Date(dt);
                return d && d >= startLocal && d < endExclusive;
              });

              // Agrupar por equipo e inferir métricas
              const teamMap = new Map();
              const teamNameOf = (lead) => {
                const t = findFirst(lead, ['TEAM','team','equipo','grupo','department','team_name','Team']);
                const s = (t || '').toString().trim();
                return s || 'Sin equipo';
              };
              const isICON = (lead) => {
                const v = (findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
                return v.includes('ICON');
              };
              const isBAMO = (lead) => {
                const v = (findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
                return v.includes('BAMO');
              };
              const getPuntaje = (lead) => {
                const p = findFirst(lead, ['puntaje','score','puntos']);
                const n = typeof p === 'number' ? p : parseFloat(p); return isNaN(n) ? 0 : n;
              };

              inDay.forEach(l => {
                const name = teamNameOf(l);
                if (!teamMap.has(name)) teamMap.set(name, { name, ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });
                const agg = teamMap.get(name);
                agg.Total += 1;
                if (isICON(l)) agg.ICON += 1; else if (isBAMO(l)) agg.BAMO += 1;
                agg.Puntaje += getPuntaje(l);
              });

              fallbackTeamData = Array.from(teamMap.values()).filter(t => !excludeNames.has((t.name || '').toUpperCase()));
              teamData = fallbackTeamData; // usar fallback también para totales
              console.log('[FALLBACK LEADS] Construido fallbackTeamData y aplicado a teamData:', fallbackTeamData);
            } else {
              console.warn('No se pudo obtener /api/leads para fallback.');
            }
          } catch (fe) {
            console.error('Error en fallback por leads:', fe);
          }
        }
        
        // Visibilidad (MES): no filtrar por fin de semana; siempre considerar todos los equipos
        (function applyMonthVisibility(){
          try {
            const norm = (s)=>String(s||'').normalize('NFD').replace(/\p{Diacritic}+/gu,'').trim().toLowerCase();
            const teamCanon = (name)=>{
              const n = norm(name).replace(/^team\s+/, '');
              if (n.includes('pleitez')) return 'Pleitez';
              if (n.includes('roberto')) return 'Roberto';
              if (n.includes('marisol')) return 'Marisol';
              if (n.includes('johana') || n.includes('johanna')) return 'Johana';
              if (n.includes('irania')) return 'Irania';
              return name || 'Sin equipo';
            };
            const groupA = new Set(['johana','irania']);
            const groupB = new Set(['pleitez','roberto','marisol']);
            const today = new Date();
            // No filtrar por día: mantener todos los equipos del mes

            // Asegurar presencia de filas en 0 para equipos faltantes
            const allTeams = (function(){
              try {
                if (window.Teams && typeof window.Teams.getAllTeams === 'function') {
                  const arr = window.Teams.getAllTeams(); // devuelve nombres
                  return Array.isArray(arr) ? arr : [];
                }
              } catch(_){ }
              // fallback estático
              return [];
            })();
            const targetSet = new Set(allTeams.map(x=>norm(x)));
            const ensureRows = (arr)=>{
              try {
                const have = new Set((arr||[]).map(t=>norm(t?.name)));
                const out = Array.isArray(arr) ? arr.slice() : [];
                for (const t of targetSet) {
                  if (!have.has(t)) {
                    // no incluir TEAM LINEAS aquí (va aparte)
                    out.push({ name: t.charAt(0).toUpperCase()+t.slice(1), ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });
                  }
                }
                return out;
              } catch(_) { return arr; }
            };
            fallbackTeamData = ensureRows(fallbackTeamData);
            teamData = ensureRows(teamData);
          } catch(e) { console.warn('[ESTADISTICAS] Weekend visibility filter error:', e); }
        })();

        // Calcular totales preliminares (serán recalculados tras el orden final)
        let totals = teamData.reduce((acc, r) => ({
          ICON: acc.ICON + (r.ICON || 0),
          BAMO: acc.BAMO + (r.BAMO || 0),
          Total: acc.Total + (r.Total || 0),
          Puntaje: acc.Puntaje + parseFloat(r.Puntaje || 0)
        }), { ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });

        // Orden fijo MES: siempre mostrar todos los equipos en ORDER_ALL
        (function applyFinalOrdering(){
          try {
            const norm = (s)=>String(s||'').normalize('NFD').replace(/\p{Diacritic}+/gu,'').trim().toLowerCase();
            const teamCanon = (name)=>{
              const n = norm(name).replace(/^team\s+/, '');
              if (n.includes('pleitez')) return 'Pleitez';
              if (n.includes('roberto')) return 'Roberto';
              if (n.includes('marisol')) return 'Marisol';
              if (n.includes('johana') || n.includes('johanna')) return 'Johana';
              if (n.includes('irania')) return 'Irania';
              return name || 'Sin equipo';
            };
            const ORDER_ALL = ['Pleitez','Roberto','Marisol','Johana','Irania'];
            const ORDER_A = ['Johana','Irania'];
            const ORDER_B = ['Pleitez','Roberto','Marisol'];
            let order = ORDER_ALL;
            const canonRows = (fallbackTeamData||[]).map(t=>({ ...t, name: teamCanon(t?.name) }));
            const map = new Map(canonRows.map(t=>[norm(t?.name), t]));
            const ensureRow = (name)=> map.get(norm(name)) || { name, ICON:0, BAMO:0, Total:0, Puntaje:0 };
            const ordered = order.map(ensureRow);
            const displayRows = ordered;
            fallbackTeamData = displayRows;
            // mantener teamData en sincronía para totales
            teamData = displayRows.slice();
            try { window.MonthDisplayRows = displayRows.slice(); } catch(_){ }
            // Datos para la gráfica mensual (flip)
            try { window.__monthlyTeamData = displayRows.slice(); } catch(_){ }
            try { window.__monthlyRange = { start: fechaInicio, end: fechaFin }; } catch(_){ }
            // recalcular totales definitivos con displayRows
            totals = (displayRows||[]).reduce((acc, r) => ({
              ICON: acc.ICON + (r.ICON || 0),
              BAMO: acc.BAMO + (r.BAMO || 0),
              Total: acc.Total + (r.Total || 0),
              Puntaje: acc.Puntaje + parseFloat(r.Puntaje || 0)
            }), { ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });
            try { window.__statsDisplayRows = displayRows.slice(); } catch(_) {}
          } catch(e) { console.warn('[ESTADISTICAS] Final ordering error:', e); }
        })();

        // Encabezado: siempre mostrar MES (mm/yyyy) para esta tabla (izquierda)
        const mesTexto = `${String(targetMonth.getMonth()+1).padStart(2,'0')}/${targetMonth.getFullYear()}`;
        const encabezadoTitulo = `VENTAS POR MERCADO Y PUNTAJE DEL MES (${mesTexto})`;

        // Generar HTML de la tabla de equipos
        let html = `
          <div class="conversion-card">
            <div style="display:flex; align-items:center; justify-content:space-between; padding:8px 12px; background:#fef3c7; border-radius:8px 8px 0 0;">
              <button id="month-prev" class="filter-button" style="height:32px;width:32px;font-size:16px;" title="Mes anterior">◀</button>
              <div class="conversion-title" style="margin:0;">${encabezadoTitulo}</div>
              <button id="month-next" class="filter-button" style="height:32px;width:32px;font-size:16px;" title="Mes siguiente">▶</button>
            </div>
            <div style="display:flex; justify-content:flex-end; margin:8px 0 6px; gap:8px;">
              <button id="btn-detalle-mensual" class="filter-button" style="height:28px;">Ver detalle</button>
              <button id="btn-flip-monthly" class="filter-button" title="Ver gráfica" style="height:28px;width:32px;font-weight:700;">↻</button>
            </div>
            <div class="flip-viewport" id="month-flip-local">
              <div class="flip-scene">
                <div class="flip-face front" id="month-front-face">
                  <div class="conv-two-col">
                    <div class="conv-left">
                      <table class="sales-table">
                        <thead>
                          <tr>
                            <th>EQUIPO</th>
                            <th>ICON</th>
                            <th>BAMO</th>
                            <th>TOTAL</th>
                            <th>PUNTAJE</th>
                          </tr>
                        </thead>
                        <tbody>
                          ${(!fallbackTeamData || fallbackTeamData.length === 0) ? `
                            <tr>
                              <td colspan="5" style="text-align: center; padding: 20px; color: #666; font-style: italic;">
                                No hay datos disponibles para la fecha seleccionada
                              </td>
                            </tr>
                          ` : (fallbackTeamData || []).map(team => `
                            <tr>
                              <td>${team.name}</td>
                              <td>${team.ICON || 0}</td>
                              <td>${team.BAMO || 0}</td>
                              <td>${team.Total || 0}</td>
                              <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                            </tr>
                          `).join('')}
                          ${ (fallbackTeamData && fallbackTeamData.length > 0) ? `
                            <tr class="total-row">
                              <td>TOTAL</td>
                              <td>${totals.ICON}</td>
                              <td>${totals.BAMO}</td>
                              <td>${totals.Total}</td>
                              <td>${Number(totals.Puntaje).toFixed(2)}</td>
                            </tr>
                          ` : ''}
                        </tbody>
                      </table>
                    </div>
                    <div class="conv-right">
                      <div class="mini-card">
                        <table class="mini-table">
                          <thead>
                            <tr>
                              <th>TEAM LINEAS</th>
                              <th>ICON</th>
                            </tr>
                          </thead>
                          <tbody>
                            ${lineasData.map(r => `
                              <tr>
                                <td>${r.name}</td>
                                <td>${r.ICON || 0}</td>
                              </tr>
                            `).join('')}
                            <tr class="total">
                              <td>TOTAL</td>
                              <td class="total-icon">${lineasTotalICON}</td>
                            </tr>
                          </tbody>
                        </table>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="flip-face back">
                  <div class="chart-wrapper">
                    <canvas id="monthly-team-chart"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
        
    // Asignar el HTML generado al elemento raíz (mostrar la tabla de conversión)
    root.innerHTML = html;
        // Overlay + handler del botón ↻ (mostrar gráfica en el mismo contenedor)
        try {
          const card = root.querySelector('.conversion-card');
          if (card && !card.querySelector('.month-chart-overlay')) {
            card.insertAdjacentHTML(
              'beforeend',
              '<div class="month-chart-overlay"><div class="chart-wrapper"><canvas id="monthly-team-chart"></canvas></div></div>'
            );
          }
          const flipBtn = document.getElementById('btn-flip-monthly');
          if (flipBtn && card) {
            // Single, robust handler: toggle using helper (if present), then create/destroy chart
            flipBtn.onclick = function(){
              try {
                // Use centralized helper to lock heights and toggle class when available
                if (typeof window.__toggleMonthlyFlip === 'function') {
                  window.__toggleMonthlyFlip();
                } else {
                  card.classList.toggle('show-chart');
                }

                // Defer chart creation/destruction slightly to allow layout/overlay to settle
                setTimeout(() => {
                  try {
                    const showing = card.classList.contains('show-chart');
                    const canvas = document.getElementById('monthly-team-chart');
                    if (showing) {
                      if (!canvas) return;
                      const rows = (Array.isArray(window.MonthDisplayRows) && window.MonthDisplayRows.length)
                        ? window.MonthDisplayRows
                        : (Array.isArray(window.__monthlyTeamData) ? window.__monthlyTeamData : []);
                      const labels = rows.map(r => String(r.name || ''));
                      const ventas  = rows.map(r => Number(r.Total   || 0));
                      const puntos  = rows.map(r => Number(r.Puntaje || 0));
                      try { if (window.__monthlyChart) { window.__monthlyChart.destroy(); window.__monthlyChart = null; } } catch(_) {}
                      const ctx = canvas.getContext('2d');
                      try {
                        window.__monthlyChart = new Chart(ctx, {
                          type: 'bar',
                          data: { labels, datasets: [
                            { label: 'Ventas',  data: ventas,  backgroundColor: 'rgba(37,99,235,0.85)' },
                            { label: 'Puntaje', data: puntos,  backgroundColor: 'rgba(239,68,68,0.85)' }
                          ] },
                          options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                        });
                      } catch(chartErr){ console.warn('monthly chart create error', chartErr); }
                      try { if (window.__monthlyChart && typeof window.__monthlyChart.resize === 'function') window.__monthlyChart.resize(); } catch(_){}
                    } else {
                      // hiding -> destroy chart to free memory and avoid stray drawings
                      try { if (window.__monthlyChart) { window.__monthlyChart.destroy(); window.__monthlyChart = null; } } catch(_){}
                    }
                  } catch(err){ console.warn('deferred monthly overlay handler error', err); }
                }, 80);
              } catch(e) { console.warn('overlay error', e); }
            };
          }
        } catch(_) {}
        
        // Ajustar altura del contenedor flip local al alto real de la tabla
        try {
          // No extra handler here: the flip button's onclick above covers toggling and chart lifecycle
        } catch(_) {}
        // Hook flechas navegación mes
        try {
          const btnPrev = document.getElementById('month-prev');
          const btnNext = document.getElementById('month-next');
          if (btnPrev) {
            btnPrev.onclick = () => { 
              const d = new Date(targetMonth); 
              d.setMonth(d.getMonth()-1); 
              location.href = `?m=${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`; 
            };
            console.log('[MES] Botón anterior conectado');
          } else {
            console.warn('[MES] Botón anterior NO encontrado');
          }
          if (btnNext) {
            btnNext.onclick = () => { 
              const d = new Date(targetMonth); 
              d.setMonth(d.getMonth()+1); 
              location.href = `?m=${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`; 
            };
            console.log('[MES] Botón siguiente conectado');
          } else {
            console.warn('[MES] Botón siguiente NO encontrado');
          }
        } catch(err) { 
          console.error('[MES] Error al conectar flechas:', err); 
        }

  // Ahora, renderizar el gráfico de ventas activas del mes (barra).
  // La gráfica de porcentaje (dona) se renderizará desde la carga asíncrona
  // `loadPorcentajeForMonth` para evitar render duplicado durante inicialización.
  try { renderVentasActivasMes(fallbackTeamData); } catch(_) { /* non-fatal */ }
        
        // Filtro eliminado: no se requiere manejar eventos de filtrado
      } catch (e) {
        console.error('Error renderizando tabla de conversiÃ³n', e);
        console.log('Usando datos de prueba para la tabla de conversiÃ³n...');
        
        // Datos de prueba cuando falla la API
        const hoy = new Date();
        const fecha = hoy.toLocaleDateString('es-ES', { day:'2-digit', month:'2-digit', year:'numeric' });
        const fallbackTeamData = [
          { name: 'TEAM IRANIA', ICON: 8, BAMO: 7, Total: 15, Puntaje: '8.5' },
          { name: 'TEAM ROBERTO VELASQUEZ', ICON: 12, BAMO: 11, Total: 23, Puntaje: '9.2' },
          { name: 'TEAM BRYAN PLEITEZ', ICON: 9, BAMO: 9, Total: 18, Puntaje: '7.8' },
          { name: 'TEAM MARISOL BELTRAN', ICON: 6, BAMO: 6, Total: 12, Puntaje: '7.1' },
          { name: 'TEAM RANDAL MARTINEZ', ICON: 11, BAMO: 9, Total: 20, Puntaje: '8.9' },
          { name: 'TEAM LINEA', ICON: 4, BAMO: 4, Total: 8, Puntaje: '6.5' }
        ];

        // Generar HTML de la tabla con datos de prueba
        let html = `
          <div class="conversion-card">
            <div class="conversion-title">VENTAS POR MERCADO Y PUNTAJE DEL MES</div>
            <div class="conv-two-col">
              <div class="conv-left">
                <table class="sales-table">
                  <thead>
                    <tr>
                      <th>EQUIPO</th>
                      <th>ICON</th>
                      <th>BAMO</th>
                      <th>TOTAL</th>
                      <th>PUNTAJE</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${fallbackTeamData.length === 0 ? `
                      <tr>
                        <td colspan="5" style="text-align: center; padding: 20px; color: #666; font-style: italic;">
                          No hay datos disponibles para la fecha seleccionada
                        </td>
                      </tr>
                    ` : fallbackTeamData.map(team => `
                      <tr>
                        <td>${team.name}</td>
                        <td>${team.ICON || 0}</td>
                        <td>${team.BAMO || 0}</td>
                        <td>${team.Total || 0}</td>
                        <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                      </tr>
                    `).join('')}
                    ${fallbackTeamData.length > 0 ? `
                      <tr class="total-row">
                        <td>TOTAL</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(2)}</td>
                      </tr>
                    ` : ''}
                  </tbody>
                </table>
              </div>
              ${true ? `
              <div class="conv-right">
                <div class="mini-card">
                  <table class="mini-table">
                    <thead>
                      <tr>
                        <th>TEAM LINEAS</th>
                        <th>ICON</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${lineasData.map(r => `
                        <tr>
                          <td>${r.name}</td>
                          <td>${r.ICON || 0}</td>
                        </tr>
                      `).join('')}
                      <tr class="total">
                        <td>TOTAL</td>
                        <td class="total-icon">${lineasTotalICON}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              ` : ''}
            </div>DÃA (${fecha})</div>
            <div class="alert alert-warning mb-3" style="padding: 10px; margin-bottom: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; color: #856404; font-size: 0.9rem;">
              <i class="fas fa-exclamation-triangle me-2"></i>
              Mostrando datos de prueba (Error de conexiÃ³n con la base de datos)
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; grid-column: 1 / -1; width: 100%; margin: 0; padding: 0;">
              <div class="card">
                <h3></h3>
                <div id="conversion-table" class="conversion-grid">
                  <table class="sales-table">
                    <thead>
                      <tr>
                        <th>EQUIPO</th>
                        <th>ICON</th>
                        <th>BAMO</th>
                        <th>TOTAL</th>
                        <th>PUNTAJE</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${fallbackTeamData.map(team => `
                        <tr>
                          <td>${team.name}</td>
                          <td>${team.ICON || 0}</td>
                          <td>${team.BAMO || 0}</td>
                          <td>${team.Total || 0}</td>
                          <td class="score-col">${team.Puntaje || '0.0'}</td>
                        </tr>
                      `).join('')}
                      <tr class="total-row">
                        <td>TOTAL</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(1)}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        `;
        
    // Asignar el HTML generado al elemento raíz (mostrar la tabla de conversión)
    root.innerHTML = html;
        
        // Agregar evento al botÃ³n de filtrar
        const btnFiltrar = document.getElementById('btnFiltrarEquipos');
        if (btnFiltrar) {
          btnFiltrar.addEventListener('click', () => {
            renderConversionTable(root);
          });
        }
      }
    }

    // Variable para mantener la referencia al grÃ¡fico
    let ventasChart = null;
    
    // Función para verificar autenticación
    function checkAuth() {
      // Verificar si hay un usuario en sessionStorage o localStorage
      const user = JSON.parse(sessionStorage.getItem('user') || localStorage.getItem('user') || 'null');
      if (!user) {
        console.error('No se encontró sesión de usuario activa');
        window.location.href = '/login.html';
        return false;
      }
      // Acceso permitido para todos los usuarios autenticados
      console.log('Usuario autenticado con acceso a Estadísticas:', user.username || user.name);
      return true;
    }
    
    // FunciÃ³n para realizar peticiones autenticadas
    async function fetchWithAuth(url, options = {}) {
      if (!checkAuth()) return null;
      
      const defaultHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      };
      // Adjuntar token si está disponible (algunos endpoints lo requieren)
      try {
        const storedUser = sessionStorage.getItem('user') || localStorage.getItem('user');
        const user = storedUser ? JSON.parse(storedUser) : null;
        const token = (user && user.token) || localStorage.getItem('token') || sessionStorage.getItem('token');
        if (token) {
          defaultHeaders['Authorization'] = `Bearer ${token}`;
        }
      } catch(_) {}
      
      const response = await fetch(url, {
        ...options,
        headers: {
          ...defaultHeaders,
          ...(options.headers || {})
        },
        credentials: 'include' // Importante para enviar las cookies de autenticaciÃ³n
      });
      
      if (response.status === 401) {
        // No autorizado - redirigir al login
        console.error('Error de autenticaciÃ³n - Redirigiendo al login');
        window.location.href = '/login.html';
        return null;
      }
      
      return response;
    }
    
    function renderVentasPorEquipoChart(teamData) {
      const ctx = document.getElementById('chart-ventas-dia');
      if (!ctx) return;

      // Filtrar equipos sin ventas para no saturar el gráfico
      // Filtrar equipos para fines de semana: solo mostrar si Total > 0
      const today = new Date();
      const isWeekend = today.getDay() === 0 || today.getDay() === 6; // 0 = domingo, 6 = sábado
      const filteredDayTeams = isWeekend ? teamData.filter(team => team.Total > 0) : teamData;
      const labels = filteredDayTeams.map(t => (t.name || t._id || 'SIN EQUIPO'));
      const data = filteredDayTeams.map(t => t.Total);

      // Paleta de colores atractiva (más colores si es necesario)
      const colors = [
        '#22b3ec', '#3498db', '#5dade2', '#85c1e9', '#aed6f1',
        '#36c2cf', '#48c9b0', '#76d7c4', '#a3e4d7', '#d1f2eb',
        '#f39c12', '#e67e22', '#e74c3c', '#9b59b6', '#34495e'
      ];

      // Destruir el grÃ¡fico anterior si existe para evitar conflictos
      if (window.ventasPorEquipoChart) {
        window.ventasPorEquipoChart.destroy();
      }

      window.ventasPorEquipoChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ventas por Equipo',
            data: data,
            backgroundColor: colors.slice(0, data.length),
            borderColor: '#fff',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  let label = context.label || '';
                  if (label) {
                    label += ': ';
                  }
                  if (context.parsed !== null) {
                    label += context.parsed;
                  }
                  return label + ' ventas';
                }
              }
            }
          }
        }
      });
    }

    // Nuevo: renderiza un donut que muestra % de activación (ICON vs resto)
    function renderPorcentajeActivacion(teamData) {
      try {
        const canvas = document.getElementById('chart-porcentaje-activacion');
        if (!canvas) return;

        // Datos defensivos
        teamData = Array.isArray(teamData) ? teamData : [];
        const totalICON = teamData.reduce((s, t) => s + (Number(t.ICON || 0)), 0);
        const total = teamData.reduce((s, t) => s + (Number(t.Total || 0)), 0) || 0;
        const active = totalICON;
        const inactive = Math.max(0, total - totalICON);

        // Si no hay datos (total === 0) mostramos un placeholder simple
        if (total === 0) {
          // Don't draw a neutral/placeholder donut that persists after load —
          // instead clear any previous chart and leave the canvas ready to be
          // rendered when real data arrives. This prevents showing an unwanted
          // neutral donut as seen in the UI.
          try { if (window.porcentajeActivacionChart) { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } } catch(_){ }
          try {
            const ctxClear = canvas.getContext('2d');
            ctxClear.clearRect(0,0,canvas.width, canvas.height);
            try { canvas.style.display = 'none'; } catch(_){}
          } catch(_){ }
          return;
        }

  // Destruir instancia previa si existe (limpiar labels primero)
  if (window.porcentajeActivacionChart) try { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } catch(_){ }

  const ctx = canvas.getContext('2d');
  try { canvas.style.display = 'block'; } catch(_){}
        // Crear gráfico (sin número central) - mostramos sólo el donut
        window.porcentajeActivacionChart = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: ['Activadas', 'No activadas'],
            datasets: [{
              data: [active, inactive],
              // Paleta principal (usar primer color para activadas, paleta de la imagen para no activadas)
              backgroundColor: ['#588A87', '#DFD9CA'],
              borderColor: ['#fff','#fff'],
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: '65%',
            plugins: {
              legend: { position: 'right' },
              tooltip: { callbacks: { label: function(ctx){ return `${ctx.label}: ${ctx.parsed} (${(total?((ctx.parsed/total)*100):0).toFixed(1)}%)`; } } }
            }
          }
        });

        // Forzar resize por si el canvas parent cambió de tamaño
        try { if (window.porcentajeActivacionChart && typeof window.porcentajeActivacionChart.resize === 'function') window.porcentajeActivacionChart.resize(); } catch(_){}
      } catch (e) { console.warn('renderPorcentajeActivacion error', e); }
    }

    // Renderiza un gráfico de barras con ventas activas por equipo
    function renderVentasActivasMes(teamData) {
      try {
        console.log('[VENTAS ACTIVAS] Datos recibidos:', teamData);
        
        const canvas = document.getElementById('chart-ventas-activas-mes');
        const listEl = document.getElementById('ventas-activas-team-list');
        const noteEl = document.getElementById('ventas-activas-note');
        
        if (!canvas) {
          console.warn('[VENTAS ACTIVAS] Canvas no encontrado');
          return;
        }
        
        // Asegurar que el canvas esté visible
        try {
          canvas.style.display = 'block';
          canvas.style.visibility = 'visible';
        } catch(_) {}
        
        teamData = Array.isArray(teamData) ? teamData : [];

        // Lista completa de equipos ordenada
        const EQUIPOS_ORDER = ['Pleitez', 'Roberto', 'Marisol', 'Johana', 'Irania', 'Jonathan', 'Luis'];
        
        // Deduplicar por nombre y asegurar que todos los equipos estén presentes
        const mapByName = new Map();
        
        // Primero procesar los datos existentes
        for (const team of teamData) {
          const key = String(team.name || '').trim().toUpperCase();
          if (!mapByName.has(key)) {
            mapByName.set(key, {
              name: team.name,
              ACTIVAS: Number(team.ACTIVAS || 0),
              Total: Number(team.Total || 0)
            });
          } else {
            // Si hay duplicados, sumar sus valores
            const existing = mapByName.get(key);
            existing.ACTIVAS = (existing.ACTIVAS || 0) + Number(team.ACTIVAS || 0);
            existing.Total = (existing.Total || 0) + Number(team.Total || 0);
          }
        }

        // Asegurar que todos los equipos requeridos estén presentes
        for (const teamName of EQUIPOS_ORDER) {
          const key = teamName.trim().toUpperCase();
          if (!mapByName.has(key)) {
            mapByName.set(key, {
              name: teamName,
              ACTIVAS: 0,
              Total: 0
            });
          }
        }

        // Convertir a array ordenado
        const filtered = EQUIPOS_ORDER.map(teamName => {
          return mapByName.get(teamName.trim().toUpperCase()) || {
            name: teamName,
            ACTIVAS: 0,
            Total: 0
          };
        });

        const labels = filtered.map(t => String(t.name || 'Sin equipo'));
        const dataVals = filtered.map(t => Number(t.ACTIVAS || 0));

        console.log('[VENTAS ACTIVAS] Labels:', labels);
        console.log('[VENTAS ACTIVAS] Valores:', dataVals);

        // Renderizar lista de equipos
        if (listEl) {
          let totalActivas = 0;
          let totalVentas = 0;
          
          const listHtml = filtered.map(team => {
            const activas = Number(team.ACTIVAS || 0);
            const total = Number(team.Total || 0);
            totalActivas += activas;
            totalVentas += total;
            
            return `
              <div style="display:flex; justify-content:space-between; padding:4px 8px; background:#f9fafb; border-radius:4px; font-size:0.85rem;">
                <span style="font-weight:600; color:#1f3b63;">${team.name}</span>
                <span style="color:#22b3ec; font-weight:700;">${activas}</span>
              </div>
            `;
          }).join('');
          
          listEl.innerHTML = `
            <div style="display:flex; justify-content:space-between; padding:6px 8px; background:#22b3ec; color:#fff; border-radius:4px; font-weight:700; margin-bottom:8px;">
              <span>Total</span>
              <span>${totalActivas}</span>
            </div>
            ${listHtml}
          `;
        }
        
        // Actualizar nota
        if (noteEl) {
          noteEl.innerHTML = `Solo ventas con status <strong>Completed</strong>`;
        }

        // Renderizar gráfico
        if (window.ventasActivasMesChart) {
          try { 
            window.ventasActivasMesChart.destroy(); 
            window.ventasActivasMesChart = null;
          } catch(_){}
        }

        const ctx = canvas.getContext('2d');
        
        // Asegurar que el contexto es válido
        if (!ctx) {
          console.error('[VENTAS ACTIVAS] No se pudo obtener el contexto 2D del canvas');
          return;
        }
        
        // Crear gradiente para efecto 3D
        const gradient = ctx.createLinearGradient(0, 0, 0, 400);
        gradient.addColorStop(0, 'rgba(34, 179, 236, 1)');
        gradient.addColorStop(0.5, 'rgba(34, 179, 236, 0.8)');
        gradient.addColorStop(1, 'rgba(34, 179, 236, 0.6)');

        window.ventasActivasMesChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              label: 'Ventas Activas',
              data: dataVals,
              backgroundColor: gradient,
              borderColor: 'rgba(26, 144, 193, 1)',
              borderWidth: 2,
              borderRadius: 8,
              borderSkipped: false
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
              padding: 10
            },
            plugins: { 
              legend: { display: false },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                padding: 12,
                cornerRadius: 8,
                displayColors: true,
                callbacks: {
                  label: function(context) {
                    const idx = context.dataIndex;
                    const activas = dataVals[idx];
                    const total = filtered[idx].Total;
                    return `Activas: ${activas} de ${total}`;
                  }
                }
              },
              datalabels: {
                display: false  // Deshabilitar etiquetas en las barras
              }
            },
            scales: {
              y: { 
                beginAtZero: true, 
                title: { 
                  display: true, 
                  text: 'Ventas Activas',
                  font: { weight: 'bold', size: 12 }
                },
                ticks: { stepSize: 1 },
                grid: {
                  color: 'rgba(0, 0, 0, 0.05)',
                  lineWidth: 1
                }
              },
              x: { 
                ticks: { 
                  autoSkip: false, 
                  maxRotation: 45, 
                  minRotation: 0,
                  font: { weight: '600', size: 11 }
                },
                grid: {
                  display: false
                }
              }
            }
          },
          plugins: [{
            // Plugin personalizado para efecto 3D con sombras
            id: 'barShadow3D',
            beforeDatasetsDraw: (chart) => {
              const ctx = chart.ctx;
              ctx.save();
              ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
              ctx.shadowBlur = 10;
              ctx.shadowOffsetX = 4;
              ctx.shadowOffsetY = 4;
            },
            afterDatasetsDraw: (chart) => {
              chart.ctx.restore();
            }
          }]
        });
        
        // Asegurar que el canvas permanezca visible después de crear el gráfico
        try {
          canvas.style.display = 'block';
          canvas.style.visibility = 'visible';
          canvas.style.opacity = '1';
        } catch(_) {}
        
        // Forzar un resize para asegurar que el gráfico se renderice correctamente
        try {
          if (window.ventasActivasMesChart && typeof window.ventasActivasMesChart.resize === 'function') {
            setTimeout(() => {
              try {
                window.ventasActivasMesChart.resize();
                window.ventasActivasMesChart.update('none');
              } catch(_) {}
            }, 100);
          }
        } catch(_) {}
        
        console.log('[VENTAS ACTIVAS] Gráfico renderizado exitosamente');
      } catch (e) { 
        console.error('[VENTAS ACTIVAS] Error al renderizar:', e); 
      }
    }

    // --- Productos vendidos en el mes: helpers y gráfico ---
    const SOLD = new Set(['vendido','cerrado','aprobado','approved','sold','closed']);
    function pickDateForProduct(lead){
      const cand = lead && (lead.dia_venta || lead.fecha_contratacion || lead.createdAt || lead.fecha || lead.created_at || lead.createdOn);
      const d = cand ? new Date(cand) : null;
      return d && !isNaN(d) ? d : new Date(0);
    }

    let productsChartRef = null;
    function renderProducts(leads){
      try{
        leads = Array.isArray(leads) ? leads : [];
        const now = new Date(); const M = now.getMonth(); const Y = now.getFullYear();
        let monthSales = leads.filter(l => { const d = pickDateForProduct(l); return d.getMonth()===M && d.getFullYear()===Y && SOLD.has(String(l.status||'').toLowerCase()); });
        if (monthSales.length === 0) {
          monthSales = leads.filter(l => { const d = pickDateForProduct(l); return d.getMonth()===M && d.getFullYear()===Y; });
        }
        const getProd = (l) => {
          const v = l.servicios_texto || l.tipo_servicios || l.tipo_servicio || l.servicios || l.producto || (l.producto && l.producto.nombre) || l.product || l.service || l.servicio || '';
          return v ? String(v).replace(/[-_]/g,' ').toUpperCase() : 'SIN PRODUCTO';
        };
        const counts = {};
        monthSales.forEach(l => { const k = getProd(l); if (!k) return; counts[k] = (counts[k]||0) + 1; });
        const entries = Object.entries(counts).sort((a,b) => b[1] - a[1]);
        const labels = entries.map(e => e[0]);
        const dataVals = entries.map(e => e[1]);
        const canvas = document.getElementById('productsChart'); if (!canvas) return; const ctx = canvas.getContext('2d');
        if (productsChartRef) try { productsChartRef.destroy(); } catch(_){}
        productsChartRef = new Chart(ctx, {
          type: 'bar',
          data: { labels, datasets: [{ label: 'Cantidad', data: dataVals, backgroundColor: 'rgba(54,162,235,.7)', borderColor: 'rgba(54,162,235,1)', borderWidth: 1, borderRadius: 4 }] },
          options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } }, x: { ticks: { autoSkip: false, maxRotation: 45, minRotation: 45 } } } }
        });
      } catch (e) { console.warn('renderProducts error', e); }
    }

    // Variables para el control de navegación de productos por mes
    let currentProductsDate = new Date();
    const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];

    async function loadProductsChart(){
      try{
        if (!checkAuth()) return;
        
        // Actualizar título del mes primero para feedback inmediato
        const titleElement = document.getElementById('products-month-title');
        if (titleElement) {
          titleElement.textContent = `PRODUCTOS VENDIDOS EN ${monthNames[currentProductsDate.getMonth()].toUpperCase()} ${currentProductsDate.getFullYear()}`;
        }

        // Construir rango de fechas para el mes seleccionado
        const startDate = new Date(currentProductsDate.getFullYear(), currentProductsDate.getMonth(), 1);
        const endDate = new Date(currentProductsDate.getFullYear(), currentProductsDate.getMonth() + 1, 0);
        const startStr = startDate.toISOString().split('T')[0];
        const endStr = endDate.toISOString().split('T')[0];

        console.log('Cargando productos para:', monthNames[currentProductsDate.getMonth()], currentProductsDate.getFullYear());
        console.log('Rango de fechas:', { startStr, endStr });

        const resp = await fetchWithAuth(`/api/leads?fechaInicio=${startStr}&fechaFin=${endStr}`);
        if (!resp || !resp.ok) { 
          console.warn('loadProductsChart: error en la respuesta de /api/leads'); 
          showNoDataMessage();
          return; 
        }
        
        const json = await resp.json();
        const leads = Array.isArray(json) ? json : (Array.isArray(json.data) ? json.data : (Array.isArray(json.leads) ? json.leads : []));
        console.log(`Obtenidos ${leads.length} leads para el mes`);

        // Filtrar ventas del mes seleccionado
        const monthSales = leads.filter(l => {
          const d = new Date(l.dia_venta || l.fecha_contratacion || l.createdAt || l.fecha || l.created_at || l.createdOn);
          return d.getMonth() === currentProductsDate.getMonth() && d.getFullYear() === currentProductsDate.getFullYear();
        });
        console.log(`Filtrados ${monthSales.length} ventas para el mes`);

        if (monthSales.length === 0) {
          showNoDataMessage();
          return;
        }

        // Contar productos
        const counts = {};
        monthSales.forEach(l => {
          const prod = l.servicios_texto || l.tipo_servicios || l.tipo_servicio || l.servicios || 
                      l.producto || (l.producto && l.producto.nombre) || l.product || l.service || 
                      l.servicio || 'SIN PRODUCTO';
          const key = prod ? String(prod).replace(/[-_]/g,' ').toUpperCase() : 'SIN PRODUCTO';
          counts[key] = (counts[key] || 0) + 1;
        });

        // Ordenar por cantidad
        const entries = Object.entries(counts).sort((a,b) => b[1] - a[1]);
        const labels = entries.map(e => e[0]);
        const dataVals = entries.map(e => e[1]);

        // Actualizar gráfico
        const canvas = document.getElementById('productsChart');
        if (!canvas) return;

        if (productsChartRef) {
          productsChartRef.destroy();
        }

        productsChartRef = new Chart(canvas.getContext('2d'), {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              label: 'Cantidad',
              data: dataVals,
              backgroundColor: 'rgba(54,162,235,.7)',
              borderColor: 'rgba(54,162,235,1)',
              borderWidth: 1,
              borderRadius: 4
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              title: {
                display: true,
                text: `Total: ${dataVals.reduce((a,b) => a + b, 0)} ventas`,
                padding: {top: 10, bottom: 10},
                font: { size: 14, weight: 'bold' }
              },
              datalabels: {
                anchor: 'end',
                align: 'top',
                offset: 4,
                color: '#333',
                font: {
                  weight: 'bold',
                  size: 13
                },
                formatter: function(value) {
                  return value;
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: { stepSize: 1 }
              },
              x: {
                ticks: {
                  autoSkip: false,
                  maxRotation: 45,
                  minRotation: 45
                }
              }
            }
          }
        });

      } catch(e) { 
        console.error('Error en loadProductsChart:', e);
        showNoDataMessage();
      }
    }

    // Función auxiliar para mostrar mensaje cuando no hay datos
    function showNoDataMessage() {
      const canvas = document.getElementById('productsChart');
      if (!canvas) return;

      if (productsChartRef) {
        productsChartRef.destroy();
      }

      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#666666';
      ctx.font = '14px Arial';
      ctx.fillText('No hay datos disponibles para este mes', canvas.width / 2, canvas.height / 2);
      ctx.restore();
    }
    

    // Función auxiliar para mostrar mensaje cuando no hay datos
    function showNoDataMessage() {
      const canvas = document.getElementById('productsChart');
      if (!canvas) return;

      if (productsChartRef) {
        productsChartRef.destroy();
      }

      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#666666';
      ctx.font = '14px Arial';
      ctx.fillText('No hay datos disponibles para este mes', canvas.width / 2, canvas.height / 2);
      ctx.restore();
    }

    // Configurar eventos de navegación después de que el DOM esté listo
    document.addEventListener('DOMContentLoaded', () => {
      const prevBtn = document.getElementById('products-prev');
      const nextBtn = document.getElementById('products-next');

      if (prevBtn) {
        prevBtn.addEventListener('click', () => {
          currentProductsDate.setMonth(currentProductsDate.getMonth() - 1);
          loadProductsChart();
        });
      }

      if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          currentProductsDate.setMonth(currentProductsDate.getMonth() + 1);
          loadProductsChart();
        });
      }
    });

    async function initCharts(){
      // Esta funciÃ³n se deja vacÃ­a intencionalmente para dar paso al nuevo grÃ¡fico de dona.
      console.log('initCharts ya no renderiza el grÃ¡fico de barras diario.');
    }
    
    // FunciÃ³n para renderizar el grÃ¡fico de ventas diarias
    function renderVentasDiarias(container, labels, data, isFallback) {
      if (!container) return;
      
      const warningHtml = isFallback ? `
        <div class="alert alert-warning mb-3" style="padding: 10px; margin-bottom: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; color: #856404;">
          <i class="fas fa-exclamation-triangle me-2"></i>
          Mostrando datos de prueba (Error de conexiÃ³n con la base de datos)
        </div>
      ` : '';
      
      container.innerHTML = `
        ${warningHtml}
        <canvas id="chart-ventas-diarias"></canvas>
      `;
      
      const canvas = container.querySelector('#chart-ventas-diarias');
      if (!canvas) {
        console.error('No se pudo crear el canvas para el grÃ¡fico de ventas diarias');
        return;
      }
      
      // Destruir grÃ¡fico anterior si existe
      if (window.ventasDiariasChart) {
        window.ventasDiariasChart.destroy();
      }
      
      // ConfiguraciÃ³n del grÃ¡fico
      const config = {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ventas',
            data: data,
            backgroundColor: 'rgba(34, 179, 236, 0.8)',
            borderColor: 'rgba(26, 144, 193, 1)',
            borderWidth: 1,
            borderRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Ventas: ${context.raw}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'NÃºmero de ventas',
                font: {
                  weight: 'bold'
                }
              },
              ticks: {
                stepSize: 1,
                precision: 0
              }
            },
            x: {
              title: {
                display: true,
                text: 'Fechas',
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
      };
      
      // Crear el grÃ¡fico
      window.ventasDiariasChart = new Chart(canvas, config);
    }
    

    // FunciÃ³n auxiliar para renderizar el grÃ¡fico
    function renderChart(container, labels, data, isFallback) {
      if (!container) return;
      
      const warningHtml = isFallback ? `
        <div class="alert alert-warning mb-3" style="padding: 10px; margin-bottom: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; color: #856404;">
          <i class="fas fa-exclamation-triangle me-2"></i>
          Mostrando datos de prueba (Error de conexiÃ³n con la base de datos)
        </div>
      ` : '';
      
      container.innerHTML = `
        ${warningHtml}
        <canvas id="chart-ventas-canvas"></canvas>
      `;
      
      const canvas = container.querySelector('#chart-ventas-canvas');
      if (!canvas) {
        console.error('No se pudo crear el canvas');
        return;
      }
      
      // Destruir grÃ¡fico anterior si existe
      if (window.ventasChart) {
        window.ventasChart.destroy();
      }
      
      // Crear nuevo grÃ¡fico
      const chartConfig = {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ventas',
            backgroundColor: '#22b3ec',
            borderColor: '#1a90c1',
            borderWidth: 1,
            borderRadius: 6,
            data: data
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Ventas: ${context.raw}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'NÃºmero de ventas',
                font: { weight: 'bold' }
              }
            },
            x: {
              title: {
                display: true,
                text: 'Equipos',
                font: { weight: 'bold' }
              },
              ticks: {
                autoSkip: false,
                maxRotation: 45,
                minRotation: 45
              }
            }
          }
        }
      };
      
      try {
        window.ventasChart = new Chart(canvas, chartConfig);
        console.log('GrÃ¡fico creado exitosamente');
      } catch (error) {
        console.error('Error al crear el grÃ¡fico:', error);
        container.innerHTML = `
          <div class="alert alert-danger">
            <i class="fas fa-exclamation-triangle me-2"></i>
            Error al crear el grÃ¡fico: ${error.message}
          </div>
        `;
      }

      // Renderizar tabla de ConversiÃ³n por equipo
      console.log('Buscando elemento con ID conversion-table...');
      const convRoot = document.getElementById('conversion-table');
      console.log('Elemento encontrado:', convRoot);
      if (convRoot) {
        console.log('Elemento conversion-table encontrado, procediendo a renderizar...');
        // Establecer fechas por defecto (Ãºltimos 30 dÃ­as)
        const fechaFin = new Date();
        const fechaInicio = new Date();
        fechaInicio.setDate(fechaInicio.getDate() - 30);
        
        // Formatear fechas para los inputs
        const fechaInicioInput = document.getElementById('fechaInicio');
        const fechaFinInput = document.getElementById('fechaFin');
        
        if (fechaInicioInput) fechaInicioInput.valueAsDate = fechaInicio;
        if (fechaFinInput) fechaFinInput.valueAsDate = fechaFin;
        
        // Cargar datos
        renderConversionTable(convRoot);
      }

      const rendCtx = document.getElementById('chart-rendimiento-mes');
      if (rendCtx) {
        new Chart(rendCtx, {
          type: 'line',
          data: {
            labels: ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'],
            datasets: [{
              label: 'Puntos',
              data: Array.from({length: 12}, () => rand(10, 40)),
              borderColor: '#10b981',
              backgroundColor: 'rgba(16,185,129,0.12)',
              fill: true,
              tension: 0.35
            }]
          },
          options: { responsive: true, maintainAspectRatio: false }
        });
      }
    }

    function initializeApp() {
      console.log('Inicializando aplicación...');
      
      // Verificar que Chart esté disponible
      if (typeof Chart === 'undefined') {
        console.error('Error: Chart.js no se ha cargado correctamente');
        const chartContainer = document.querySelector('.chart-wrapper');
        if (chartContainer) {
          chartContainer.innerHTML = `
            <div class="alert alert-danger">
              <i class="fas fa-exclamation-triangle me-2"></i>
              Error: No se pudo cargar la biblioteca de gráficos. Por favor, recarga la página.
            </div>
          `;
        }
        return;
      }
      
      console.log('Chart.js cargado correctamente:', Chart.version);
      
      // Inicializar gráficos
      initCharts();
      
      // Configurar botón de actualización
      const btn = document.getElementById('btn-refresh');
      if (btn) {
        btn.addEventListener('click', () => {
          console.log('Actualizando gráficos...');
          initCharts();
        });
      }

      // Inicializar tabla de conversión después de que el DOM esté listo
      setTimeout(() => {
        initConversionTable();
        loadDayData();
        
        // Cargar gráfico de Porcentaje de Activación
        try { 
          console.log('[INIT] Cargando gráfico de Porcentaje de Activación...');
          if (typeof loadPorcentajeForMonth === 'function') {
            loadPorcentajeForMonth(new Date());
          } else {
            console.error('[INIT] loadPorcentajeForMonth no está definida');
          }
        } catch(e) { 
          console.error('[INIT] Error cargando Porcentaje de Activación:', e); 
        }
        
        try { prepareMonthDetails(); } catch(_){ }
        // Inyectar el botón dentro del contenedor mensual cuando esté renderizado
  try { injectMonthlyDetailButton(); } catch(_){ }
  // Inyectar botón flip para la tarjeta del DÍA
  try { injectDayFlipButton(); } catch(_){ }
    // Inyectar flechas de navegación para la tarjeta de Porcentaje de Activacion
    try { if (typeof window.injectPorcentajeNavButtons === 'function') window.injectPorcentajeNavButtons(); } catch(_){ }
    // mark porcentaje loader as initializing so we don't render placeholder charts
    try { window.__porcIsInitializing = true; } catch(_){}
        // Asegurar barra de toggles del DÍA aún si el render cambió
        try { ensureDayTogglesFallback(); } catch(_){ }
        // Agregar tabs Día/Mes a ambas tarjetas
        try { ensureStatsTabs(); } catch(_){ }
        // Cargar gráfica de Productos vendidos en el mes
        try { loadProductsChart(); } catch(_){ }
        // Igualar alturas entre la gráfica izquierda y la tarjeta de productos para evitar espacios
        try { setTimeout(() => { try { equalizeVentasProductsHeights(); } catch(_){} }, 300); } catch(_){}
      }, 200); // Delay para asegurar que el DOM esté listo
    }

  // Igualar alturas de las dos tarjetas (Ventas vs Productos) para evitar espacio en blanco
  function equalizeVentasProductsHeights(){
    try{
      const row = document.getElementById('ventas-products-row'); if (!row) return;
      const left = row.querySelector('.graph-container');
      const right = row.querySelector('.chart-wrapper');
      if (!left || !right) return;
      const h = left.clientHeight;
      right.style.height = h + 'px';
      // also ensure canvas fills
      const cvs = right.querySelector('canvas'); if (cvs) { cvs.style.width='100%'; cvs.style.height='100%'; }
    } catch(e){ console.warn('equalizeVentasProductsHeights error', e); }
  }
  window.addEventListener('resize', () => { try{ equalizeVentasProductsHeights(); }catch(_){} });

    // Deshabilitado: ya no se inyectan toggles fuera del modal
    function ensureDayTogglesFallback(){ return; }
    // ====== MODAL DETALLE DÍA ======
    // Estilos básicos del modal (inline para no depender de CSS externo)
    (function ensureModalStyles(){
      const css = `
      .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
      .modal{background:#fff;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.2);max-width:960px;width:92%;max-height:80vh;overflow:auto}
      .modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e2e8f0;font-weight:800}
      .close-btn{border:none;background:#e11d48;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
      .table-compact{width:100%;border-collapse:collapse;font-size:.9rem}
      .table-compact th,.table-compact td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left}
      .table-compact th{background:#1f3b63;color:#fff}
      .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
      `;
      const s = document.createElement('style'); s.textContent = css; document.head.appendChild(s);
    })();

    // Force-visible helper CSS (used as a robust fallback to make front face/table visible)
    (function(){
      if (document.getElementById('flip-force-styles')) return;
      const css = `
        /* force-visible: used sparingly to nudge visibility without changing table layout
           avoid forcing display:block globally which breaks table/tr layout */
        .force-visible { visibility: visible !important; opacity: 1 !important; pointer-events: auto !important; transform: none !important; }
        .force-visible table { display: table !important; visibility: visible !important; opacity: 1 !important; }

        /* Stronger, scoped override: when the flip viewport is NOT flipped, ensure the front face
           is visible and interactive. This targets the transient race where CSS with
           .flip-front-hidden (which uses !important) may still be present or re-applied.
           Using :not(.is-flipped) and placing this style late in the document gives it
           the correct cascade precedence without affecting the flipped state. */
        #day-flip-local:not(.is-flipped) .flip-face.front { visibility: visible !important; opacity: 1 !important; pointer-events: auto !important; transform: none !important; }
        #day-flip-local:not(.is-flipped) .flip-face.front table { display: table !important; visibility: visible !important; opacity: 1 !important; }
      `;
      const s = document.createElement('style'); s.id = 'flip-force-styles'; s.textContent = css; document.head.appendChild(s);
    })();

    // Styles for the monthly overlay so showing the monthly chart doesn't change layout flow
    (function ensureMonthlyOverlayStyles(){
      if (document.getElementById('monthly-overlay-styles')) return;
      const css = `
        /* Ensure conversion card is a positioning context for the absolute overlay */
        .conversion-card { position: relative; }

        /* The overlay is absolutely positioned and hidden by default so it doesn't affect layout */
        .conversion-card .month-chart-overlay {
          position: absolute;
          inset: 0;
          display: none;
          padding: 12px;
          box-sizing: border-box;
          background: #fff;
          z-index: 5;
          align-items: center;
          justify-content: center;
        }

        /* When the card has show-chart, display the overlay as a flex container (no reflow) */
        .conversion-card.show-chart .month-chart-overlay { display: flex; }

        /* Ensure the inner chart wrapper fills the overlay */
        .month-chart-overlay .chart-wrapper { width: 100%; height: 100%; }

        /* Prevent the overlay from changing document flow when visible */
        .month-chart-overlay canvas { width: 100% !important; height: 100% !important; }
      `;
      const s = document.createElement('style'); s.id = 'monthly-overlay-styles'; s.textContent = css; document.head.appendChild(s);
    })();

    // Inyectar flechas en la tarjeta de Porcentaje de Activasion (solo íconos)
    window.injectPorcentajeNavButtons = function(attempt = 0){
      try {
        const topCharts = document.getElementById('top-charts');
        if (!topCharts) {
          if (attempt < 20) return setTimeout(() => window.injectPorcentajeNavButtons(attempt+1), 300);
          return;
        }
        // Buscar la tarjeta que contiene chart-porcentaje-activacion
        const canvas = document.getElementById('chart-porcentaje-activacion');
        if (!canvas) return;
        const card = canvas.closest('.card');
        if (!card) return;
        // No duplicar
        if (card.querySelector('.porc-nav')) return;
        const nav = document.createElement('div'); nav.className = 'porc-nav';
        const prev = document.createElement('button'); prev.className = 'porc-arrow'; prev.innerHTML = '◀';
        const next = document.createElement('button'); next.className = 'porc-arrow'; next.innerHTML = '▶';
        nav.appendChild(prev); nav.appendChild(next);
        // Insertar al inicio del header
        const header = card.querySelector('h3');
        if (header) header.parentNode.insertBefore(nav, header.nextSibling);

        // Handlers: navegar mes anterior/siguiente mediante ?m=YYYY-MM
        const urlParams = new URLSearchParams(location.search);
        const mParam = urlParams.get('m');
        let base;
        if (mParam && /^\d{4}-\d{2}$/.test(mParam)) {
          const [y,m] = mParam.split('-').map(Number); base = new Date(y, m-1, 15);
        } else {
          base = new Date();
        }
  // Wire to in-place loader (no full page reload)
  window.currentPorcMonth = base;
  prev.onclick = () => { try { window.shiftPorcMonth(-1); } catch(e){ console.warn(e); } };
  next.onclick = () => { try { window.shiftPorcMonth(1); } catch(e){ console.warn(e); } };
  // Auto-load porcentaje for the current month (if function available). If the loader
  // isn't defined yet, schedule a short retry so the chart appears without manual console call.
  try{
    if (typeof loadPorcentajeForMonth === 'function') {
      loadPorcentajeForMonth(base);
    } else {
      setTimeout(()=>{ try{ if (typeof loadPorcentajeForMonth === 'function') loadPorcentajeForMonth(base); }catch(_){}} , 250);
    }
  }catch(_){ }
      } catch(e){ if (attempt < 20) return setTimeout(() => window.injectPorcentajeNavButtons(attempt+1), 300); }
    };

      // --- Porcentaje de Activacion: in-place month loader and per-team donut renderer ---
      // Moved here to avoid nesting inside other IIFEs and to keep top-level functions stable.
      window.shiftPorcMonth = function(delta){
        try{
          if (!window.currentPorcMonth) window.currentPorcMonth = new Date();
          const d = new Date(window.currentPorcMonth);
          d.setMonth(d.getMonth() + delta);
          window.currentPorcMonth = d;
          try { loadPorcentajeForMonth(d); } catch(e){ console.warn('loadPorcentajeForMonth error', e); }
        } catch(e){ console.warn('shiftPorcMonth error', e); }
      };

      async function loadPorcentajeForMonth(date){
        try{
          try { window.__porcIsInitializing = true; } catch(_){}
          if (!date) date = (window.currentPorcMonth || new Date());
          const y = date.getFullYear();
          const m = String(date.getMonth()+1).padStart(2,'0');
          
          // Obtener primer y último día del mes actual
          const primer = `${y}-${m}-01`;
          const ultimo = `${y}-${m}-${String(new Date(y, date.getMonth()+1, 0).getDate()).padStart(2,'0')}`;
          
          // Calcular primer y último día del mes anterior para comparación
          const mesAnterior = new Date(y, date.getMonth()-1, 1);
          const yAnt = mesAnterior.getFullYear();
          const mAnt = String(mesAnterior.getMonth()+1).padStart(2,'0');
          const primerAnt = `${yAnt}-${mAnt}-01`;
          const ultimoAnt = `${yAnt}-${mAnt}-${String(new Date(yAnt, mesAnterior.getMonth()+1, 0).getDate()).padStart(2,'0')}`;
          const url = `/api/equipos/estadisticas?fechaInicio=${primer}&fechaFin=${ultimo}`;
          const resp = await fetchWithAuth(url);
          let teamData = [];
          if (resp && resp.ok) {
            const json = await resp.json();
            console.log('🔍 RAW BACKEND RESPONSE:', JSON.stringify(json, null, 2));
            teamData = Array.isArray(json) ? json : (Array.isArray(json.data) ? json.data : (Array.isArray(json.leads) ? json.leads : []));
          } else {
            teamData = Array.isArray(window.__monthlyTeamData) ? window.__monthlyTeamData : [];
          }
          // Normalize simple equipos payload (accept several field names)
          teamData = (teamData||[]).map(r => {
            const totalVentas = Number(r.Total || r.total || r.cantidad || 0);
            const totalActivas = Number(r.ACTIVAS || r.activadas || r.activadas_count || r.ACTIVADAS || 0);
            const porcentaje = totalVentas > 0 ? (totalActivas / totalVentas) * 100 : 0;
            
            return {
              name: String(r.name || r.TEAM || r.team || r.equipo || 'Sin equipo'),
              ICON: Number(r.ICON || 0),
              ACTIVAS: totalActivas,
              Total: totalVentas,
              porcentajeActivacion: porcentaje // Porcentaje exacto sin redondeo
            };
          });
          console.log('loadPorcentajeForMonth: equipos payload normalized', teamData && teamData.length ? teamData.slice(0,10) : teamData);

          // If the equipos endpoint didn't return usable per-team stats, fallback to aggregating from /api/leads
          const looksEmpty = !Array.isArray(teamData) || teamData.length === 0 || teamData.every(t => Number(t.Total || 0) === 0 && Number(t.ICON || 0) === 0);
          if (looksEmpty) {
            try {
              const leadsUrl = `/api/leads?fechaInicio=${primer}&fechaFin=${ultimo}`;
              const r2 = await fetchWithAuth(leadsUrl);
              let leads = [];
              if (r2 && r2.ok) {
                const j2 = await r2.json();
                leads = Array.isArray(j2) ? j2 : (Array.isArray(j2.data) ? j2.data : (Array.isArray(j2.leads) ? j2.leads : []));
              }

              // Aggregate by probable team field. Be permissive matching status and boolean markers
              const map = Object.create(null);
              (leads||[]).forEach(ld => {
                try {
                  const teamName = String(ld.team || ld.TEAM || ld.equipo || ld.group || ld.supervisor || ld.assignedTeam || ld.teamName || ld.nombreEquipo || 'Sin equipo').trim();
                  const rawStatus = String(ld.status || ld.estado || ld.estadoVenta || ld.workflowStatus || ld.state || ld.saleStatus || '').toLowerCase().trim();
                  const statusNorm = rawStatus.replace(/\s+/g, '');
                  const boolActive = (ld.activated === true || ld.sold === true || ld.isActive === true || ld.vendido === true);
                  const numericActive = (String(ld.activated || ld.sold || ld.isActive || ld.vendido || '').trim() === '1');
                  // Consider as active primarily when status indicates 'completed' (or Spanish variants), or boolean flags are set
                  const isActive = boolActive || numericActive || /completed|completad|finaliz|vendid|vendido/i.test(rawStatus) || ['completed','complete','done','finalizado','completado','activada','activado','vendido','ok','cerrada','cerrado','v'].includes(statusNorm);
                  if (!map[teamName]) map[teamName] = { name: teamName, ICON: 0, ACTIVAS: 0, Total: 0 };
                  map[teamName].Total += 1;
                  // count verified "activas" separately from market ICON counts
                  if (isActive) map[teamName].ACTIVAS += 1;
                } catch(_){}
              });

              teamData = Object.keys(map).map(k => ({ name: map[k].name, ICON: Number(map[k].ICON||0), ACTIVAS: Number(map[k].ACTIVAS||0), Total: Number(map[k].Total||0) }));
              console.log('loadPorcentajeForMonth: aggregated from leads (fallback)', teamData);
              // Nota: se omite la verificación adicional en cliente para evitar llamadas redundantes.
              // El conteo de ACTIVAS debe venir del backend (/api/equipos/estadisticas).
            } catch(e){
              console.warn('fallback aggregation from /api/leads failed', e);
            }
          }

          // Comentado: ya no usar datos de prueba, usar datos reales del backend
          // if (!Array.isArray(teamData) || teamData.length === 0) {
          //   console.warn('No hay datos disponibles, usando datos de prueba para el gráfico de Porcentaje de Activación');
          //   teamData = [];
          // }

          // allow rendering now that data arrived
          try { window.__porcIsInitializing = false; showPorcSpinner(false); } catch(_){}
          renderPorcentajeTeams(teamData);
          
          // Renderizar también el gráfico de ventas activas con los mismos datos
          renderVentasActivasMes(teamData);
        } catch(e){ console.warn('loadPorcentajeForMonth error', e); }
        // ensure the initializing flag is cleared even on unexpected errors
        try { window.__porcIsInitializing = false; showPorcSpinner(false); } catch(_){ }
      }

      // Helpers: DOM-based external labels for porcentaje donuts (robust outside-canvas numeric labels)
      function cleanupPorcLabels(chart){
        try{
          if (!chart) return;
          try { if (chart._porcLabelsContainer && chart._porcLabelsContainer.parentNode) chart._porcLabelsContainer.parentNode.removeChild(chart._porcLabelsContainer); } catch(_){}
          try { if (chart._porcResizeHandler) { window.removeEventListener('resize', chart._porcResizeHandler); chart._porcResizeHandler = null; } } catch(_){}
          try { if (chart._porcObserver) { chart._porcObserver.disconnect(); chart._porcObserver = null; } } catch(_){}
          // restore original update if we wrapped it
          try { if (chart.__origUpdate) { chart.update = chart.__origUpdate; chart.__origUpdate = null; } } catch(_){}
        } catch(_){}
      }

      function attachPorcLabels(chart, rowsArr, useTotals){
        try{
          if (!chart || !chart.canvas) return;
          cleanupPorcLabels(chart);
          const canvas = chart.canvas;
          const wrapper = canvas.parentElement || document.body;
          if (wrapper && getComputedStyle(wrapper).position === 'static') wrapper.style.position = 'relative';
          const container = document.createElement('div');
          container.className = 'porc-labels-overlay';
          // Use fixed positioning anchored to the canvas bounding rect. This
          // avoids ancestor transforms/stacking contexts that can shift absolute
          // positioned overlays and makes mapping from chart pixels -> screen
          // pixels more reliable across browsers/devices.
          container.style.position = 'fixed';
          container.style.pointerEvents = 'none';
          container.style.zIndex = '40';
          // align overlay to the canvas surface so arc.x/arc.y map 1:1 to overlay coords
          try {
            // Anchor the overlay to the canvas bounding box in viewport coordinates
            // so subsequent label placement can use viewport absolute coords.
            const canvasRect = canvas.getBoundingClientRect();
            container.style.left = Math.round(canvasRect.left) + 'px';
            container.style.top = Math.round(canvasRect.top) + 'px';
            container.style.width = Math.round(canvasRect.width) + 'px';
            container.style.height = Math.round(canvasRect.height) + 'px';
          } catch(_) {
            container.style.inset = '0';
            container.style.top = '0';
            container.style.left = '0';
            container.style.width = '100%';
            container.style.height = '100%';
          }
          wrapper.appendChild(container);
          chart._porcLabelsContainer = container;

          const update = function(){
            try {
              container.innerHTML = '';
              const meta = chart.getDatasetMeta(0);
              if (!meta || !Array.isArray(meta.data)) return;
                  meta.data.forEach((arc, i) => {
                try {
                  const rawVal = (chart.data && chart.data.datasets && chart.data.datasets[0] && chart.data.datasets[0].data && chart.data.datasets[0].data[i]) ? chart.data.datasets[0].data[i] : 0;
                  const value = (rawVal === null || rawVal === undefined) ? 0 : rawVal;
                  // skip labels for zero-sized slices to avoid clutter
                  if (!value || Number(value) === 0) return;
                  // compute slice color for contrast adjustments
                  let sliceColor = null;
                  try { sliceColor = (chart.data && chart.data.datasets && chart.data.datasets[0] && chart.data.datasets[0].backgroundColor && chart.data.datasets[0].backgroundColor[i]) ? chart.data.datasets[0].backgroundColor[i] : null; } catch(_) { sliceColor = null; }
                  // place label at the middle of the slice (midpoint between inner and outer radius)
                  const angle = (arc.startAngle + arc.endAngle) / 2;
                  const outer = (typeof arc.outerRadius === 'number') ? arc.outerRadius : Math.min(chart.width, chart.height) / 2;
                  const inner = (typeof arc.innerRadius === 'number') ? arc.innerRadius : Math.max(0, outer * 0.4);
                  // pull labels slightly inward from the exact midpoint so they stay
                  // visually inside the donut slice (helps for thin/adjacent slices)
                  const span = Math.abs((arc.endAngle || 0) - (arc.startAngle || 0));
                  let midRadius = (inner + outer) / 2;
                  if (span < 0.6) {
                    // narrow slice: push label closer to inner radius so it fits
                    midRadius = inner + (outer - inner) * 0.38;
                  } else {
                    // normal slice: slight inward nudge
                    midRadius = midRadius * 0.7;
                  }
                  const cx = (typeof arc.x === 'number') ? arc.x : (chart.width / 2);
                  const cy = (typeof arc.y === 'number') ? arc.y : (chart.height / 2);
                  // Chart internal coordinates may be in device pixels; map to the
                  // overlay (which uses CSS pixels) using the canvas bounding rect.
                  const cRect = canvas.getBoundingClientRect();
                  // Use the canvas backing buffer size (canvas.width/height) which are
                  // in device pixels. Mapping from chart internal pixels -> CSS pixels
                  // is done by ratio = cssSize / backingSize.
                  const backingW = (canvas.width || chart.width || cRect.width);
                  const backingH = (canvas.height || chart.height || cRect.height);
                  const ratioX = (cRect.width || 1) / backingW;
                  const ratioY = (cRect.height || 1) / backingH;
                  // Prefer the arc's built-in center/tooltip position if available
                  // (Chart.js provides element.tooltipPosition() / getCenterPoint()).
                  let pos = null;
                  try {
                    if (typeof arc.getCenterPoint === 'function') pos = arc.getCenterPoint();
                    else if (typeof arc.tooltipPosition === 'function') pos = arc.tooltipPosition();
                  } catch(_) { pos = null; }
                  // Fallback: use our computed midpoint if Chart element helpers are missing
                  let xChart, yChart;
                  if (pos && typeof pos.x === 'number' && typeof pos.y === 'number') {
                    xChart = pos.x; yChart = pos.y;
                  } else {
                    xChart = cx + Math.cos(angle) * midRadius;
                    yChart = cy + Math.sin(angle) * midRadius;
                  }
                  // Compute absolute screen coordinates for the label and then map
                  // them into the overlay's coordinate system. This avoids offsets
                  // caused by padding/margins or different positioning contexts.
                  const absoluteX = cRect.left + (xChart * ratioX);
                  const absoluteY = cRect.top  + (yChart * ratioY);
                  // container is fixed and aligned to canvas bounding rect, so map
                  // absolute viewport coords into the overlay by subtracting its
                  // bounding rect. This avoids issues when wrapper has transforms.
                  const containerRect = container.getBoundingClientRect();
                  // coordinates relative to the overlay
                  let x = absoluteX - containerRect.left;
                  let y = absoluteY - containerRect.top;
                  // keep labels inside the overlay bounds (padding 6px)
                  try {
                    const maxW = container.clientWidth || containerRect.width || cRect.width || 1;
                    const maxH = container.clientHeight || containerRect.height || cRect.height || 1;
                    x = Math.max(6, Math.min(maxW - 6, x));
                    y = Math.max(6, Math.min(maxH - 6, y));
                  } catch(_){}
                  const lbl = document.createElement('div');
                  lbl.className = 'porc-label';
                  lbl.style.position = 'absolute';
                  lbl.style.left = x + 'px';
                  lbl.style.top = y + 'px';
                  lbl.style.transform = 'translate(-50%, -50%)';
                  lbl.style.pointerEvents = 'none';
                  // make label visually compact so it fits inside slices
                  lbl.style.background = 'rgba(255,255,255,0.9)';
                  lbl.style.borderRadius = '6px';
                  lbl.style.padding = '2px 6px';
                  lbl.style.fontWeight = '700';
                  lbl.style.fontSize = '11px';
                  lbl.style.color = '#0f172a';
                  lbl.style.boxShadow = '0 1px 2px rgba(0,0,0,0.06)';
                  lbl.style.border = '1px solid rgba(0,0,0,0.06)';
                  // adjust foreground/background for readability depending on slice color
                  try {
                    if (sliceColor) {
                      const hexToRgb = (h) => {
                        try {
                          if (h.startsWith('#')) {
                            const v = h.slice(1);
                            const bigint = parseInt(v.length===3 ? v.split('').map(c=>c+c).join('') : v, 16);
                            return [(bigint>>16)&255, (bigint>>8)&255, bigint&255];
                          }
                          // rgba(...) or rgb(...)
                          const m = h.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
                          if (m) return [parseInt(m[1]), parseInt(m[2]), parseInt(m[3])];
                        } catch(_){}
                        return null;
                      };
                      const rgb = hexToRgb(String(sliceColor));
                      if (rgb) {
                        const [r,g,b] = rgb.map(n => Number(n)/255);
                        // relative luminance
                        const lum = 0.2126 * (r<=0.03928 ? r/12.92 : Math.pow((r+0.055)/1.055,2.4))
                                  + 0.7152 * (g<=0.03928 ? g/12.92 : Math.pow((g+0.055)/1.055,2.4))
                                  + 0.0722 * (b<=0.03928 ? b/12.92 : Math.pow((b+0.055)/1.055,2.4));
                        if (lum < 0.45) {
                          // dark slice -> light text, slight dark translucent bg
                          lbl.style.color = '#ffffff';
                          lbl.style.background = 'rgba(0,0,0,0.38)';
                        } else {
                          // light slice -> dark text, light translucent bg
                          lbl.style.color = '#0f172a';
                          lbl.style.background = 'rgba(255,255,255,0.85)';
                        }
                      }
                    }
                  } catch(_){}
                  lbl.textContent = String(value);
                  container.appendChild(lbl);
                } catch(_){}
              });
            } catch(e){ console.warn('update porc labels error', e); }
          };

          // initial placement: run several times and after next frame to handle
          // Chart.js internal layout timing (first draw may change canvas size).
          try { update(); } catch(_){}
          try { setTimeout(update, 30); } catch(_){}
          try { requestAnimationFrame(() => { try { update(); } catch(_){} }); } catch(_){}
          try { setTimeout(update, 220); } catch(_){ }
          try { setTimeout(update, 600); } catch(_){ }
          try { setTimeout(update, 1200); } catch(_){ }

          // keep handler for later cleanup and recompute overlay bounds on resize
          chart._porcResizeHandler = function(){
            try {
              // Re-anchor the fixed overlay to the canvas viewport rect so
              // scrolling/resizes keep labels positioned correctly.
              const cRect = canvas.getBoundingClientRect();
              container.style.left = Math.round(cRect.left) + 'px';
              container.style.top = Math.round(cRect.top) + 'px';
              container.style.width = Math.round(cRect.width) + 'px';
              container.style.height = Math.round(cRect.height) + 'px';
            } catch(_){}
            try { update(); } catch(_){}
          };
          window.addEventListener('resize', chart._porcResizeHandler);

          // observe canvas size/attr changes to update labels
          try { const mo = new MutationObserver(update); mo.observe(canvas, { attributes: true, attributeFilter: ['width','height','style'] }); chart._porcObserver = mo; } catch(_){}

          // wrap update so labels refresh when chart.update() called
          try { if (!chart.__origUpdate) { chart.__origUpdate = chart.update.bind(chart); chart.update = function(){ const res = chart.__origUpdate.apply(this, arguments); try { update(); } catch(_){} return res; }; } } catch(_){}

          // Expose a simple forced update helper so callers (e.g. animation.onComplete)
          // can request a multi-pass refresh. This schedules a few delayed retries
          // to handle devicePixelRatio/layout shifts on first paint.
          try {
            chart._porcForceUpdate = function(){ try { update(); } catch(_){}
              try { setTimeout(update, 350); } catch(_){}
              try { setTimeout(update, 700); } catch(_){}
              try { setTimeout(update, 1200); } catch(_){}
            };
          } catch(_){ }
        } catch(e){ console.warn('attachPorcLabels error', e); }
      }

      function renderPorcentajeTeams(teamData, selectedIndex = 0){
        try {
          const canvas = document.getElementById('chart-porcentaje-activacion');
          const listRoot = document.getElementById('porc-team-list');
          
          console.log('[PORCENTAJE] Iniciando render...', {
            canvasFound: !!canvas,
            listRootFound: !!listRoot,
            teamDataLength: teamData?.length,
            selectedIndex
          });
          
          if (!canvas) {
            console.error('[PORCENTAJE] Canvas no encontrado!');
            return;
          }
          if (!Array.isArray(teamData)) teamData = [];
          
          console.log('[PORCENTAJE] TeamData:', teamData);

          // Lista completa de equipos ordenada
          const EQUIPOS_ORDER = ['Pleitez', 'Roberto', 'Marisol', 'Johana', 'Irania', 'Jonathan', 'Luis'];
          
          // while inicializando no dibujar gráficos provisionales
          if (window.__porcIsInitializing) {
            try {
              if (canvas.getContext) {
                const ctx = canvas.getContext('2d');
                try { ctx.clearRect(0,0,canvas.width || canvas.clientWidth, canvas.height || canvas.clientHeight); } catch(_){}
              }
              return;
            } catch(_) {}
          }

          // Deduplicar por nombre y asegurar que todos los equipos estén presentes
          const mapByName = new Map();
          
          // Primero procesar los datos existentes
          for (const team of teamData) {
            const key = String(team.name || '').trim().toUpperCase();
            if (!mapByName.has(key)) {
              mapByName.set(key, {
                name: team.name,
                ICON: Number(team.ICON || 0),
                ACTIVAS: Number(team.ACTIVAS || 0),
                Total: Number(team.Total || 0),
                Puntaje: Number(team.Puntaje || 0)
              });
            } else {
              // Si hay duplicados, sumar sus valores
              const existing = mapByName.get(key);
              existing.ICON = (existing.ICON || 0) + Number(team.ICON || 0);
              existing.ACTIVAS = (existing.ACTIVAS || 0) + Number(team.ACTIVAS || 0);
              existing.Total = (existing.Total || 0) + Number(team.Total || 0);
              existing.Puntaje = (existing.Puntaje || 0) + Number(team.Puntaje || 0);
            }
          }

          // Asegurar que todos los equipos requeridos estén presentes
          for (const teamName of EQUIPOS_ORDER) {
            const key = teamName.trim().toUpperCase();
            if (!mapByName.has(key)) {
              mapByName.set(key, {
                name: teamName,
                ICON: 0,
                ACTIVAS: 0,
                Total: 0,
                Puntaje: 0
              });
            }
          }

          // Convertir los equipos procesados a un array ordenado según EQUIPOS_ORDER
          const rows = EQUIPOS_ORDER.map(teamName => {
            const team = mapByName.get(teamName.trim().toUpperCase()) || {
              name: teamName,
              ICON: 0,
              ACTIVAS: 0,
              Total: 0,
              Puntaje: 0
            };
            
            // Calcular el porcentaje de activación usando solo ventas completadas (ACTIVAS)
            const totalVentas = Number(team.Total || 0);
            const totalActivas = Number(team.ACTIVAS || 0); // Solo usar ACTIVAS, no ICON
            const porcentaje = totalVentas > 0 ? (totalActivas / totalVentas) * 100 : 0;
            
            return {
              ...team,
              porcentajeActivacion: Math.round(porcentaje * 100) / 100 // Redondear a 2 decimales
            };
          });
          // Verificar si hay datos para mostrar
          if (rows.length === 0) {
            try {
              // Limpiar y ocultar el canvas si no hay datos
              if (window.porcentajeActivacionChart) {
                try { 
                  cleanupPorcLabels(window.porcentajeActivacionChart);
                  window.porcentajeActivacionChart.destroy();
                  window.porcentajeActivacionChart = null;
                } catch(_){ }
              }
              if (canvas && canvas.getContext) {
                const ctx = canvas.getContext('2d');
                try { 
                  ctx.clearRect(0, 0, canvas.width || canvas.clientWidth, canvas.height || canvas.clientHeight);
                  canvas.style.display = 'none';
                } catch(_){ }
              }
              return;
            } catch(_){ }
          }

          // Spinner overlay management for Porcentaje de Activacion
          function showPorcSpinner(show) {
            try {
              if (!canvas) return;
              const wrapper = canvas.parentElement || document.body;
              // ensure wrapper is a positioning context
              if (wrapper && getComputedStyle(wrapper).position === 'static') {
                wrapper.style.position = 'relative';
              }
              let overlay = wrapper.querySelector('.porc-spinner-overlay');
              if (show) {
                if (!overlay) {
                  overlay = document.createElement('div');
                  overlay.className = 'porc-spinner-overlay';
                  overlay.innerHTML = '<div class="porc-spinner" aria-hidden="true"></div>';
                  // align overlay to canvas bounds
                  try {
                    overlay.style.left = (canvas.offsetLeft || 0) + 'px';
                    overlay.style.top = (canvas.offsetTop || 0) + 'px';
                    overlay.style.width = (canvas.clientWidth || canvas.width || 200) + 'px';
                    overlay.style.height = (canvas.clientHeight || canvas.height || 200) + 'px';
                  } catch(_) { overlay.style.inset = '0'; }
                  wrapper.appendChild(overlay);
                }
              } else {
                try { 
                  if (overlay && overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                  }
                } catch(_){ }
              }
            } catch(e){ console.warn('showPorcSpinner error', e); }
          }
          if (listRoot) {
            try{ 
              listRoot.style.display = 'flex';
              listRoot.style.flexDirection = 'column';
              listRoot.innerHTML = '';
              
              // Generar la lista de equipos con sus porcentajes
              const itemsHtml = rows.map(team => {
                const totalVentas = Number(team.Total || 0);
                const totalActivas = Number(team.ACTIVAS || 0); // Solo usar ventas completadas (ACTIVAS)
                const porcentaje = totalVentas > 0 ? (totalActivas / totalVentas) * 100 : 0;
                return `
                  <div style="display:grid;grid-template-columns:1fr auto;column-gap:10px;align-items:center;padding:6px 4px;border-bottom:1px solid rgba(0,0,0,0.04);">
                    <div style="font-weight:700;color:#0f172a;font-size:0.95rem;">${team.name}</div>
                    <div style="text-align:right;color:#6b7280;font-size:0.85rem;line-height:1.1;">
                      Total: <span style='font-weight:700;color:#111;'>${totalVentas}</span><br>
                      Activas: <span style='font-weight:700;color:#111;'>${totalActivas}</span><br>
                      <span style='color:#059669;font-weight:700;'>${porcentaje.toFixed(2)}%</span>
                    </div>
                  </div>`;
              }).join('');

              listRoot.innerHTML = `<div style="display:block;">${itemsHtml}</div>`;
            } catch(_){ }
          }

          // By default render the aggregated 'all teams' donut when there are multiple teams
          if (rows.length > 1) {
            // default: render all teams view
            renderPorcentajeAllTeams(rows);
            return;
          }

          // fallback single team render
          renderPorcentajeForTeam(rows, selectedIndex);

          // --- helper: render a single team's donut ---
          function renderPorcentajeForTeam(rowsArr, selIdx){
            try{
              const team = rowsArr[selIdx] || rowsArr[0];
              // Usar solo ventas completadas (ACTIVAS) para el cálculo
              const active = Number(team.ACTIVAS || 0);
              const total = Number(team.Total || 0);
              const inactive = Math.max(0, total - active);
              // If the team has no total sales at all, clear and hide the canvas
              // but if Total > 0 we still render a donut (with Activadas possibly 0)
              if (!total || Number(total) === 0) {
                try { if (window.porcentajeActivacionChart) { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } } catch(_){ }
                try { const ctx = canvas.getContext && canvas.getContext('2d'); if (ctx) ctx.clearRect(0,0,canvas.width || canvas.clientWidth, canvas.height || canvas.clientHeight); try { canvas.style.display = 'none'; } catch(_){} } catch(_){ }
                return;
              }
              if (window.porcentajeActivacionChart) try { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } catch(_){ }
              const ctx = canvas.getContext('2d');
              try { canvas.style.display = 'block'; } catch(_){}
              // Usar la paleta de la imagen: #588A87, #B6C6BE, #DFD9CA, #EFCABF, #EEA995
              window.porcentajeActivacionChart = new Chart(ctx, {
                type: 'doughnut',
                data: { labels: ['Activadas','No activadas'], datasets: [{ data: [active, inactive], backgroundColor: ['#588A87','#DFD9CA'], borderColor: ['#fff','#fff'], borderWidth: 3 }] },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  cutout: '60%',
                  layout: {
                    padding: 15
                  },
                  plugins: {
                    legend: { display: false },
                    tooltip: {
                      backgroundColor: 'rgba(0, 0, 0, 0.8)',
                      padding: 12,
                      cornerRadius: 8
                    }
                  }
                },
                plugins: [{
                  id: 'shadow3D',
                  beforeDraw: (chart) => {
                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 5;
                    ctx.shadowOffsetY = 5;
                  },
                  afterDraw: (chart) => {
                    chart.ctx.restore();
                  }
                }]
              });
              // Labels are rendered inside the canvas by the datalabels plugin now.
            }catch(e){ console.warn('renderPorcentajeForTeam error', e); }
          }

          // --- helper: render all teams as slices in a single donut ---
          function renderPorcentajeAllTeams(rowsArr){
            try{
              if (!Array.isArray(rowsArr) || rowsArr.length === 0) return;
              const labels = rowsArr.map(r => String(r.name));
              // Usar el Total de ventas para el tamaño de las porciones del gráfico
              // El porcentaje de activación se mostrará en las etiquetas
              const dataToUse = rowsArr.map(r => Number(r.Total || 0));
              const totalTotal = dataToUse.reduce((s,n)=>s+Number(n||0),0);
              
              // If after choosing the data the sum is zero, there's nothing to draw
              if (totalTotal === 0) {
                try { if (window.porcentajeActivacionChart) { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } } catch(_){ }
                try { const ctx = canvas.getContext && canvas.getContext('2d'); if (ctx) ctx.clearRect(0,0,canvas.width || canvas.clientWidth, canvas.height || canvas.clientHeight); try { canvas.style.display = 'none'; } catch(_){} } catch(_){ }
                return;
              }
              if (window.porcentajeActivacionChart) try { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } catch(_){ }
              const ctx = canvas.getContext('2d');
              // generate colors
              // Paleta provista por el usuario (imagen)
              const palette = ['#588A87', '#B6C6BE', '#DFD9CA', '#EFCABF', '#EEA995'];
              const background = labels.map((_,i)=> palette[i % palette.length]);
              
              // Solo incluir plugin de sombras 3D
              const chartPlugins = [{
                id: 'shadow3D',
                beforeDraw: (chart) => {
                  const ctx = chart.ctx;
                  ctx.save();
                  ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                  ctx.shadowBlur = 15;
                  ctx.shadowOffsetX = 5;
                  ctx.shadowOffsetY = 5;
                },
                afterDraw: (chart) => {
                  chart.ctx.restore();
                }
              }];
              
              window.porcentajeActivacionChart = new Chart(ctx, {
                type: 'doughnut',
                data: { labels: labels, datasets: [{ data: dataToUse, backgroundColor: background, borderColor: '#fff', borderWidth: 3 }] },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  cutout: '60%',
                  // Efecto 3D con sombras
                  layout: {
                    padding: 15
                  },
                  plugins: {
                    legend: { display: false },
                    tooltip: { 
                      intersect: false, 
                      position: 'nearest',
                      backgroundColor: 'rgba(0, 0, 0, 0.8)',
                      padding: 12,
                      cornerRadius: 8,
                      displayColors: true,
                      callbacks: { 
                        label: function(ctx){ 
                          const idx = ctx.dataIndex;
                          const team = rowsArr[idx];
                          const totalVentas = Number(team.Total || 0);
                          const totalActivas = Number(team.ACTIVAS || 0);
                          const porcentaje = totalVentas > 0 ? (totalActivas / totalVentas) * 100 : 0;
                          return `${ctx.label}: ${totalActivas}/${totalVentas} (${porcentaje.toFixed(1)}% activación)`;
                        } 
                      } 
                    }
                  }
                },
                plugins: chartPlugins
              });

              // Populate the compact left-side list (`#porc-team-list`) with the
              // rows for quick reference. Make it absolute-left inside the chart
              // wrapper so it doesn't push content and avoid repopulating when
              // identical (use dataset.porcKey as a guard).
              try {
                const listRootLocal = document.getElementById('porc-team-list');
                if (listRootLocal) {
                  // Colores del gráfico (misma paleta)
                  const palette = ['#588A87', '#B6C6BE', '#DFD9CA', '#EFCABF', '#EEA995'];
                  const itemsHtml = rowsArr.map((team, index) => {
                    const name = String(team.name || 'Sin equipo');
                    const total = Number(team.Total || 0);
                    const activas = Number(team.ACTIVAS || 0);
                    const color = palette[index % palette.length];
                    return `
                      <div style="display:grid;grid-template-columns:auto 1fr auto;column-gap:8px;align-items:center;padding:6px 4px;border-bottom:1px solid rgba(0,0,0,0.04);">
                        <div style="width:12px;height:12px;border-radius:50%;background-color:${color};flex-shrink:0;"></div>
                        <div style="font-weight:700;color:#0f172a;font-size:0.95rem;">${name}</div>
                        <div style="text-align:right;color:#6b7280;font-size:0.85rem;line-height:1.1;">Total: <span style='font-weight:700;color:#111;'>${total}</span><br>Activas: <span style='font-weight:700;color:#111;'>${activas}</span></div>
                      </div>`;
                  }).join('');

                  const key = rowsArr.map(r => String(r.name || '') + '::' + Number(r.Total || 0) + '::' + Number((r.ACTIVAS !== undefined && r.ACTIVAS !== null) ? r.ACTIVAS : r.ICON || 0)).join('|');
                  if (listRootLocal.dataset.porcKey !== key) {
                    listRootLocal.innerHTML = `<div style="display:block;">${itemsHtml}</div>`;
                    listRootLocal.dataset.porcKey = key;
                  }

                  // style it like the compact list (absolute left)
                  try {
                    listRootLocal.style.display = 'block';
                    listRootLocal.style.position = 'absolute';
                    listRootLocal.style.left = '12px';
                    listRootLocal.style.top = '50%';
                    listRootLocal.style.transform = 'translateY(-50%)';
                    listRootLocal.style.width = '180px';
                    listRootLocal.style.maxHeight = '360px';
                    listRootLocal.style.overflow = 'auto';
                    listRootLocal.style.padding = '4px 6px';
                    listRootLocal.style.boxSizing = 'border-box';
                    listRootLocal.style.background = 'transparent';
                    listRootLocal.style.fontSize = '0.92rem';
                    listRootLocal.style.color = '#0f172a';
                    listRootLocal.style.zIndex = '6';
                  } catch(_){}
                }

                // ensure the chart wrapper has space on the left so the list doesn't overlap the donut
                try {
                  const wrapper = canvas && canvas.parentElement;
                  if (wrapper) {
                    if (getComputedStyle(wrapper).position === 'static') wrapper.style.position = 'relative';
                    wrapper.style.paddingLeft = '200px';
                    wrapper.style.overflow = 'visible';
                    try { if (wrapper.parentElement) wrapper.parentElement.style.overflow = 'visible'; } catch(_){ }
                  }
                } catch(_){ }
              } catch(e){ console.warn('populate left porc-team-list error', e); }
            }catch(e){ console.warn('renderPorcentajeAllTeams error', e); }
          }

        }catch(e){ console.warn('renderPorcentajeTeams error', e); }
      }

    /* Day flip: make the back face an absolute overlay so the day chart never pushes or
       overlaps the table in a way that changes layout flow. This keeps the front table
       visible unless explicitly hidden and prevents reflow of the lower panels. */
    (function ensureDayFlipOverlayStyles(){
      if (document.getElementById('day-flip-overlay-styles')) return;
      const css = `
        /* Positioning context */
        #day-flip-local { position: relative; }

        /* Put the back face (chart) out of flow and hidden by default */
        #day-flip-local .flip-face.back {
          position: absolute;
          inset: 0;
          display: none;
          z-index: 6;
          box-sizing: border-box;
          padding: 8px;
          background: rgba(255,255,255,0.98);
          pointer-events: auto;
        }

        /* When the container is marked as flipped, show the back overlay without reflow */
        #day-flip-local.is-flipped .flip-face.back,
        #day-flip-local.show-chart-day .flip-face.back { display: block; }

        /* Keep front in normal flow so tables retain dimensions */
        #day-flip-local .flip-face.front { position: relative; z-index: 2; }

        /* Make sure any canvases fill the overlay area */
        #day-flip-local .flip-face.back .chart-wrapper,
        #day-flip-local .flip-face.back canvas { width: 100% !important; height: 100% !important; }
      `;
      const s = document.createElement('style'); s.id = 'day-flip-overlay-styles'; s.textContent = css; document.head.appendChild(s);
    })();

    // Safe delegated click handler for the day flip button: call existing toggle if present
    (function attachDayFlipDelegated(){
      document.addEventListener('click', function onDocClick(e){
        try {
          const t = e.target;
          if (!t) return;
          // Common IDs used by the app for the monthly/day flip buttons: try to catch the day one
          if (t.id === 'btn-flip-day' || t.dataset && t.dataset.flip === 'day') {
            e.preventDefault();
            if (typeof window.__toggleDayFlip === 'function') {
              try { window.__toggleDayFlip(); } catch(err){ console.warn('error calling __toggleDayFlip', err); }
            } else if (typeof window.__toggleMonthlyFlip === 'function') {
              // fallback: reuse monthly helper if day toggle isn't present
              try { window.__toggleMonthlyFlip(); } catch(_){}
            } else {
              // Last resort: toggle a show class on #day-flip-local so CSS overlay shows
              const container = document.getElementById('day-flip-local');
              if (container) container.classList.toggle('show-chart-day');
            }
          }
        } catch(_){}
      }, false);
    })();

    // Ensure monthly flip preserves layout height to avoid shifting the lower chart
    // This helper locks the flip viewport (or card) to the front face height while the
    // flip transition runs, then releases it and triggers a chart resize.
    (function ensureMonthlyFlipHeightLock(){
      if (window.__toggleMonthlyFlip) return; // don't overwrite if already defined
      window.__toggleMonthlyFlip = function(){
        try {
          // Prefer the conversion-card that contains the monthly flip
          const card = document.querySelector('.conversion-card');
          const flipViewport = (card && card.querySelector('#month-flip-local')) || document.getElementById('month-flip-local');
          const front = flipViewport ? flipViewport.querySelector('.flip-face.front') : null;
          const lockTarget = flipViewport || card || document.body;

          // Measure and lock height so the layout below doesn't reflow mid-transition
          const height = (front && front.offsetHeight) ? front.offsetHeight : (lockTarget && lockTarget.offsetHeight) || 0;
          if (height) {
            // Use minHeight so content can still grow if needed but won't shrink during flip
            lockTarget.style.minHeight = height + 'px';
          }

          // Toggle the visual state (same class the rest of the code expects)
          if (card) card.classList.toggle('show-chart');

          // After the flip animation settles, release the lock and refresh charts
          const RELEASE_MS = 700; // slightly longer than the CSS transition to be safe
          setTimeout(() => {
            try { if (height) lockTarget.style.minHeight = ''; } catch(_){}
            try { if (window.__monthlyChart && typeof window.__monthlyChart.resize === 'function') window.__monthlyChart.resize(); } catch(_){}
            try { if (window.ventasPorEquipoChart && typeof window.ventasPorEquipoChart.resize === 'function') window.ventasPorEquipoChart.resize(); } catch(_){}
          }, RELEASE_MS);
        } catch(e){
          console.warn('toggleMonthlyFlip error', e);
        }
      };
    })();

    // Contenedor del modal
    (function ensureModalContainer(){
      let overlay = document.getElementById('day-detail-modal');
      if (!overlay){
        overlay = document.createElement('div');
        overlay.id = 'day-detail-modal';
        overlay.className = 'modal-overlay';
        overlay.innerHTML = `
          <div class="modal" role="dialog" aria-modal="true" aria-labelledby="dayDetailTitle">
            <div class="modal-header">
              <div id="dayDetailTitle">Detalle de Ventas del Día</div>
              <button class="close-btn" id="day-detail-close">Cerrar</button>
            </div>
            <div class="modal-body">
              <div class="toolbar">
                <label for="filter-team-select" style="font-weight:600">Equipo:</label>
                <select id="filter-team-select"></select>
                <span id="day-detail-subtitle" style="margin-left:auto;color:#475569"></span>
              </div>
              <div style="overflow:auto">
                <table class="table-compact" id="day-detail-table">
                  <thead>
                    <tr>
                      <th>Equipo</th>
                      <th>Agente</th>
                      <th>Servicio</th>
                      <th>Mercado</th>
                      <th>Puntaje</th>
                      <th>Fecha</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
          </div>`;
        document.body.appendChild(overlay);
      }
      // Conectar listeners (siempre)
      overlay.addEventListener('click', (e)=>{ if(e.target===overlay) hideDayDetailModal(); });
      const closeBtn = document.getElementById('day-detail-close');
      if (closeBtn) closeBtn.onclick = hideDayDetailModal;
      // Cerrar con ESC
      document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideDayDetailModal(); });
    })();

    function hideDayDetailModal(){
      const el = document.getElementById('day-detail-modal');
      if (el) el.style.display = 'none';
    }

    // Aplica visibilidad a la tabla del Día y persiste selección
    window.applyDayTeamVisibility = function(teams){
      try {
        const STORAGE_KEY = 'stats_day_visible_teams';
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(teams)); } catch(_) {}
        const ORDER_ALL = ['Pleitez','Roberto','Marisol','Johana','Irania'];
        const base = Array.isArray(window.DayRowsOriginal) ? window.DayRowsOriginal : [];
        const rows = (teams && teams.length ? ORDER_ALL.filter(n=>teams.includes(n)) : ORDER_ALL).map(n => {
          const found = (base||[]).find(r=>String(r.name)===n);
          return found || { name:n, ICON:0, BAMO:0, Total:0, Puntaje:0 };
        });
        const card = document.querySelector('#ventas-dia-card .sales-table');
        if (!card) return;
        const tbody = card.querySelector('tbody');
        if (!tbody) return;
        const bodyRows = rows.map(team => `
          <tr>
            <td>${team.name}</td>
            <td>${team.ICON || 0}</td>
            <td>${team.BAMO || 0}</td>
            <td>${team.Total || 0}</td>
            <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
          </tr>
        `).join('');
        const totalHTML = `
          <tr class="total-row">
            <td>TOTAL</td>
            <td>${rows.reduce((s,t)=>s+(t.ICON||0),0)}</td>
            <td>${rows.reduce((s,t)=>s+(t.BAMO||0),0)}</td>
            <td>${rows.reduce((s,t)=>s+(t.Total||0),0)}</td>
            <td>${rows.reduce((s,t)=>s+parseFloat(t.Puntaje||0),0).toFixed(2)}</td>
          </tr>`;
        tbody.innerHTML = bodyRows + totalHTML;
      } catch(e){ console.warn('applyDayTeamVisibility error', e); }
    };

    // ====== DETALLE MENSUAL ======

    (function ensureMonthModal(){
      if (!document.getElementById('month-detail-modal')){
        const overlay = document.createElement('div');
        overlay.id = 'month-detail-modal';
        overlay.className = 'modal-overlay';
        overlay.innerHTML = `
          <div class="modal" role="dialog" aria-modal="true" aria-labelledby="monthDetailTitle">
            <div class="modal-header">
              <div id="monthDetailTitle">Detalle Mensual</div>
              <button class="close-btn" id="month-detail-close">Cerrar</button>
            </div>
            <div class="modal-body">
              <div class="toolbar">
                <label for="month-filter-team" style="font-weight:600">Equipo:</label>
                <select id="month-filter-team" style="min-width:200px"></select>
                <label for="month-filter-agent" style="font-weight:600; margin-left:8px;">Agente:</label>
                <select id="month-filter-agent" style="min-width:220px"></select>
                <span id="month-detail-subtitle" style="margin-left:auto;color:#475569"></span>
              </div>
              <div style="overflow:auto">
                <table class="table-compact" id="month-detail-table">
                  <thead>
                    <tr>
                      <th>Equipo</th>
                      <th>Agente</th>
                      <th>Servicio</th>
                      <th>Mercado</th>
                      <th>Puntaje</th>
                      <th>Fecha</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
          </div>`;
        document.body.appendChild(overlay);
        overlay.addEventListener('click', (e)=>{ if(e.target===overlay) hideMonthDetailModal(); });
        document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideMonthDetailModal(); });
        const closeBtn = overlay.querySelector('#month-detail-close');
        if (closeBtn) closeBtn.addEventListener('click', hideMonthDetailModal);
      }
    })();

    async function prepareMonthDetails(){
        // Intentar SIEMPRE el agregado del DÍA con forceAll=1 (todos los equipos)
        // Ensure start/end Date objects are defined (use window.__monthlyRange if available)
        let start, end;
        try {
          const r = (window && window.__monthlyRange) ? window.__monthlyRange : null;
          if (r && r.start) {
            // r.start/r.end may be strings like 'YYYY-MM-DD'
            start = (r.start instanceof Date) ? r.start : new Date(String(r.start) + 'T00:00:00');
            // make end exclusive (next day after r.end)
            const last = (r.end instanceof Date) ? r.end : new Date(String(r.end) + 'T00:00:00');
            end = new Date(last.getFullYear(), last.getMonth(), last.getDate() + 1, 0, 0, 0);
          } else {
            const now = new Date();
            start = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0);
            end = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0);
          }
        } catch(_) {
          start = new Date(); end = new Date(start.getFullYear(), start.getMonth() + 1, 1);
        }
        let leads = [];
        let usedEquiposAggreg = false;
        try {
          let u = `/api/equipos/estadisticas?${qs}&forceAll=1`;
          const resp = await fetchWithAuth(u);
          if (resp && resp.ok) {
            const dj = await resp.json();
            if (dj && dj.success && Array.isArray(dj.data) && dj.data.length) {
              dayData = dj.data.map(equipo => ({
                name: equipo.TEAM || equipo.team || 'Sin equipo',
                ICON: parseFloat(equipo.ICON || 0),
                ACTIVAS: parseFloat(equipo.ACTIVAS || 0),
                BAMO: parseFloat(equipo.BAMO || 0),
                Total: parseFloat(equipo.Total || 0),
                Puntaje: parseFloat(equipo.Puntaje || 0)
              }));
              usedEquiposAggreg = true;
            }
          }
        } catch(_){ /* ignorar y caer al fallback por leads */ }
        if (!usedEquiposAggreg) {
          // Construir desde /api/leads para el rango mensual calculado arriba
          try {
            const sd = start; const ed = new Date(end.getTime() - 24*60*60*1000); // end es exclusivo -> restar 1 día
            const sStr = `${sd.getFullYear()}-${String(sd.getMonth()+1).padStart(2,'0')}-${String(sd.getDate()).padStart(2,'0')}`;
            const eStr = `${ed.getFullYear()}-${String(ed.getMonth()+1).padStart(2,'0')}-${String(ed.getDate()).padStart(2,'0')}`;
            const leadsResp = await fetchWithAuth(`/api/leads?fechaInicio=${sStr}&fechaFin=${eStr}`);
            if (!leadsResp) return;
            const leadsJson = await leadsResp.json();
            leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
          } catch(e) { console.warn('prepareMonthDetails leads fallback error', e); return; }
        }
        const getByPath = (obj, path) => { try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch(_) { return undefined; } };
        const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
        const tryDateFrom = (val) => { if (!val) return null; if (typeof val === 'string') { const s = val.trim(); if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [yy,mm,dd] = s.split('-').map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) { const [dd,mm,yy] = s.split(/[\/\-]/).map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } } const dt = new Date(val); return isNaN(dt) ? null : dt; };
        const createdPaths = ['dia_venta','diaVenta','fecha_contratacion','creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha'];
        const normalizeServicio = (lead) => {
          const raw = findFirst(lead, ['servicios_texto','servicios','producto','servicio','tipoProducto','producto.nombre']);
          if (Array.isArray(raw)) return raw.map(s=>String(s).trim()).filter(Boolean).join(', ');
          return (raw ? String(raw) : '').trim();
        };

        // Watcher: if the day front table exists in DOM but remains hidden, attempt automatic recovery
        window.__startDayTableVisibilityWatcher = function(timeoutMs = 8000){
          try {
            if (window.__dayTableWatcherTimer) return;
            // ensure paused flag exists
            if (typeof window.__dayWatcherPaused === 'undefined') window.__dayWatcherPaused = false;
            const start = Date.now();
            window.__dayTableWatcherTimer = setInterval(() => {
              try {
                // if paused (we're in the middle of a flip/cleanup) avoid fighting with flip code
                if (window.__dayWatcherPaused) return;
                const vp = document.getElementById('day-flip-local');
                if (!vp) return;
                const front = vp.querySelector('.flip-face.front');
                const table = front && front.querySelector ? front.querySelector('table.sales-table') : null;
                if (!table) return;
                const cs = window.getComputedStyle(table);
                const hidden = (!cs || cs.display === 'none' || cs.visibility === 'hidden' || Number(cs.opacity) === 0 || cs.pointerEvents === 'none');
                if (hidden) {
                  try { console.log('[VIS-WATCHER] Table hidden detected, attempting restore'); } catch(_){}
                  try { if (typeof window.__ensureDayFrontVisible === 'function') window.__ensureDayFrontVisible(); } catch(_){}
                  try { front && front.classList.add('force-visible'); } catch(_){}
                  setTimeout(() => { try { front && front.classList.remove('force-visible'); } catch(_){} }, 500);
                } else {
                  // visible -> stop watcher
                  clearInterval(window.__dayTableWatcherTimer); window.__dayTableWatcherTimer = null;
                }
                if ((Date.now() - start) > timeoutMs) { clearInterval(window.__dayTableWatcherTimer); window.__dayTableWatcherTimer = null; }
              } catch(e){ try{ console.warn('[VIS-WATCHER] error', e); }catch(_){} }
            }, 300);
          } catch(e){ try{ console.warn('startDayTableVisibilityWatcher error', e); }catch(_){} }
        };

        // Kick the watcher when the script initializes so it can auto-heal intermittent cases
        try { setTimeout(() => { try { window.__startDayTableVisibilityWatcher(10000); } catch(_){} }, 800); } catch(_){}
        const normalizeAgente = (lead) => {
          const raw = findFirst(lead, ['agenteNombre','agente','createdBy','registeredBy','usuario','vendedor']);
          const val = (raw ? String(raw) : '').trim();
          return agentCanonical(val);
        };
        const inMonth = leads.filter(l => { const v = findFirst(l, createdPaths); const dt = tryDateFrom(v); return dt && dt >= start && dt < end; });
        const rows = inMonth.map(l => ({
          team: (findFirst(l, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team'])||'').toString().trim(),
          agente: normalizeAgente(l),
          servicio: normalizeServicio(l),
          mercado: (findFirst(l, ['mercado','market','producto','servicio','tipoProducto','producto.nombre'])||'').toString().toUpperCase(),
          puntaje: Number((() => { const p = findFirst(l, ['puntaje','score','puntos']); return typeof p==='number'?p:parseFloat(p)||0; })()),
          fecha: findFirst(l, createdPaths)
        }));
        window.MonthDetailRows = {
          rango: `${String(start.getDate()).padStart(2,'0')}/${String(start.getMonth()+1).padStart(2,'0')}/${start.getFullYear()} - ${String(new Date(end-1).getDate()).padStart(2,'0')}/${String(start.getMonth()+1).padStart(2,'0')}/${start.getFullYear()}`,
          rows
        };
    }

    function hideMonthDetailModal(){ const el = document.getElementById('month-detail-modal'); if (el) el.style.display = 'none'; }
    function normStr(s){
      return (s||'').toString().normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().replace(/\s+/g,'').replace(/\./g,'');
    }
    function agentCanonical(name){
      const n = normStr(name);
      const aliases = {
        // Eduardo Rivas
        'eduardor': 'Eduardo Rivas',
        'eduardorivas': 'Eduardo Rivas',
        'eduardor.': 'Eduardo Rivas',
        'eduardorrivas': 'Eduardo Rivas'
      };
      return aliases[n] || (name || '');
    }

    function showMonthDetailModal(){
      try{
        console.log('[MODAL] showMonthDetailModal invoked', { MonthDetailRows: !!window.MonthDetailRows });
        const store = window.MonthDetailRows || { rango:'', rows:[] };
        const rows = Array.isArray(store.rows) ? store.rows : [];
        const overlay = document.getElementById('month-detail-modal'); if (!overlay) return;
        const tbody = overlay.querySelector('#month-detail-table tbody');
        const selTeam = overlay.querySelector('#month-filter-team');
        const selAgent = overlay.querySelector('#month-filter-agent');
        const subtitle = overlay.querySelector('#month-detail-subtitle');
        subtitle.textContent = `Rango: ${store.rango}`;
        const teams = Array.from(new Set(rows.map(r => (r.team||'').toString().trim()).filter(Boolean))).sort();
        selTeam.innerHTML = `<option value="">Todos</option>` + teams.map(t=>`<option value="${t}">${t}</option>`).join('');
        function refreshAgents(){
          const team = selTeam.value;
          const agents = Array.from(new Set(rows
            .filter(r => !team || r.team === team)
            .map(r => (r.agente||'').toString().trim())
            .filter(Boolean)))
            .sort();
          selAgent.innerHTML = `<option value="">Todos</option>` + agents.map(a=>`<option value="${a}">${a}</option>`).join('');
        }
        function render(){
          const team = selTeam.value; const agent = selAgent.value;
          const agentNorm = normStr(agent);
          const data = rows.filter(r => {
            const okTeam = (!team || r.team === team);
            if (!okTeam) return false;
            if (!agent) return true;
            return normStr(r.agente) === agentNorm;
          });
          tbody.innerHTML = data.map(r => `
            <tr>
              <td>${r.team || ''}</td>
              <td>${r.agente || ''}</td>
              <td>${r.servicio || ''}</td>
              <td>${r.mercado || ''}</td>
              <td>${Number(r.puntaje||0).toFixed(2)}</td>
              <td>${typeof r.fecha==='string' ? r.fecha : (r.fecha instanceof Date ? r.fecha.toISOString() : (r.fecha||''))}</td>
            </tr>
          `).join('');
        }
        refreshAgents();
        render();
        selTeam.onchange = () => { refreshAgents(); render(); };
        selAgent.onchange = () => { render(); };
        overlay.style.display = 'flex';
      } catch(e){ console.error('Error abriendo detalle mensual', e); }
    }

    // Inserta el botón dentro de la tarjeta mensual cuando exista en el DOM
    function injectMonthlyDetailButton(attempt = 0){
      const root = document.getElementById('conversion-table');
      const card = root ? root.querySelector('.conversion-card') : null;
      if (!card) {
        if (attempt < 20) return setTimeout(() => injectMonthlyDetailButton(attempt + 1), 300);
        return;
      }
      if (card.querySelector('#btn-detalle-mensual')) return;
      const toolbar = document.createElement('div');
      toolbar.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin:8px 0 6px;';
      const navDiv = document.createElement('div');
      navDiv.style.cssText = 'display:flex; gap:6px;';
      const btnPrev = document.createElement('button');
      btnPrev.id = 'month-prev';
      btnPrev.className = 'filter-button';
      btnPrev.style.cssText = 'height:28px;width:32px;';
      btnPrev.title = 'Mes anterior';
      btnPrev.textContent = '◀';
      const btnNext = document.createElement('button');
      btnNext.id = 'month-next';
      btnNext.className = 'filter-button';
      btnNext.style.cssText = 'height:28px;width:32px;';
      btnNext.title = 'Mes siguiente';
      btnNext.textContent = '▶';
      navDiv.appendChild(btnPrev);
      navDiv.appendChild(btnNext);
      const actionsDiv = document.createElement('div');
      actionsDiv.style.cssText = 'display:flex; gap:8px;';
      // Botón Flip ↻
      const btnFlip = document.createElement('button');
      btnFlip.id = 'btn-flip-monthly';
      btnFlip.className = 'filter-button';
      btnFlip.title = 'Ver gráfica';
      btnFlip.textContent = '↻';
      btnFlip.style.cssText = 'height:28px;width:32px;font-weight:700;';
      const btn = document.createElement('button');
      btn.id = 'btn-detalle-mensual';
      btn.className = 'filter-button';
      btn.style.height = '28px';
      btn.textContent = 'Ver detalle mensual';
      btn.addEventListener('click', () => { try { showMonthDetailModal(); } catch(e){ console.error(e); } });
      actionsDiv.appendChild(btn);
      actionsDiv.appendChild(btnFlip);
      toolbar.appendChild(navDiv);
      toolbar.appendChild(actionsDiv);
      // Hook flechas navegación mes
      const urlParams = new URLSearchParams(location.search);
      const mParam = urlParams.get('m');
      let base;
      if (mParam && /^\d{4}-\d{2}$/.test(mParam)) {
        const [y,m] = mParam.split('-').map(Number);
        base = new Date(y, m-1, 15);
      } else {
        base = new Date();
      }
      btnPrev.onclick = () => { const d = new Date(base); d.setMonth(d.getMonth()-1); location.href = `?m=${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`; };
      btnNext.onclick = () => { const d = new Date(base); d.setMonth(d.getMonth()+1); location.href = `?m=${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`; };
      const convTwoCol = card.querySelector('.conv-two-col');
      if (convTwoCol) card.insertBefore(toolbar, convTwoCol); else card.appendChild(toolbar);
    }

    // FunciÃ³n para inicializar la tabla de conversiÃ³n
    function initConversionTable() {
      console.log('Inicializando tabla de conversiÃ³n...');
      const convRoot = document.getElementById('conversion-table');
      if (convRoot) {
        console.log('Elemento conversion-table encontrado, renderizando...');
        renderConversionTable(document.getElementById('conversion-table'));
      } else {
        console.error('No se encontrÃ³ el elemento con ID conversion-table');
      }
    }

    // Función para cargar y renderizar la tabla del Día con el mismo diseño que la del Mes
    async function loadDayData() {
      console.log('Cargando datos del día actual...');
      const container = document.getElementById('ventas-dia-card');
      if (!container) {
        console.error('No se encontró el contenedor #ventas-dia-card');
        return;
      }

      // Leer parámetro ?d= si existe para navegación
      const urlParams = new URLSearchParams(location.search);
      const dParam = urlParams.get('d');
      const cutoffHour = 9, cutoffMinute = 30;
      let effective;
      if (dParam && /^\d{4}-\d{2}-\d{2}$/.test(dParam)) {
        const [y,m,d] = dParam.split('-').map(Number);
        effective = new Date(y, m-1, d, 12, 0, 0);
      } else {
        const nowLocal = new Date();
        const beforeCutoff = (nowLocal.getHours() < cutoffHour) || (nowLocal.getHours() === cutoffHour && nowLocal.getMinutes() < cutoffMinute);
        effective = new Date(nowLocal);
        if (beforeCutoff) effective.setDate(effective.getDate() - 1);
      }
      const diaTexto = `${String(effective.getDate()).padStart(2,'0')}/${String(effective.getMonth()+1).padStart(2,'0')}/${effective.getFullYear()}`;

      // Placeholder de carga
      container.innerHTML = `
        <div class="text-center" style="padding: 12px; color:#666;">Cargando datos del día...</div>
      `;

      try {
        // 1) Construir SIEMPRE desde /api/leads (global, sin filtrar por agente)
        const y = effective.getFullYear();
        const m = String(effective.getMonth()+1).padStart(2,'0');
        const d = String(effective.getDate()).padStart(2,'0');
        const qs = `fechaInicio=${y}-${m}-${d}&fechaFin=${y}-${m}-${d}&scope=day`;
        let dayData = [];
        const startLocal = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate(), 0, 0, 0, 0);
        // Si navegamos con ?d=, capturar TODO el día (00:00 a 23:59:59)
        const urlParams = new URLSearchParams(location.search);
        const isNavigating = urlParams.has('d');
        const endExclusive = isNavigating 
          ? new Date(effective.getFullYear(), effective.getMonth(), effective.getDate() + 1, 0, 0, 0, 0)
          : new Date(effective.getFullYear(), effective.getMonth(), effective.getDate() + 1, cutoffHour, cutoffMinute, 0, 0);
        const leadsResp = await fetchWithAuth(`/api/leads?fechaInicio=${y}-${m}-${d}&fechaFin=${y}-${m}-${d}&skipDate=1&t=${Date.now()}`);
        if (!leadsResp) return;
        const leadsJson = await leadsResp.json();
        const leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
        const getByPath = (obj, path) => { try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch (_) { return undefined; } };
        const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
        const tryDateFrom = (val) => { if (!val) return null; if (typeof val === 'string') { const s = val.trim(); if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [yy,mm,dd] = s.split('-').map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) { const [dd,mm,yy] = s.split(/[\/\-]/).map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } } const dt = new Date(val); return isNaN(dt) ? null : dt; };
        const createdPaths = ['dia_venta','diaVenta','fecha_contratacion','creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha'];
        // Funciones de ayuda para comparar el mismo día, soportando múltiples formatos
        const pad2 = (n)=> String(n).padStart(2,'0');
        const ymd = `${y}-${m}-${d}`; // YYYY-MM-DD del día efectivo
        const dmyNoPad = `${Number(d)}/${Number(m)}/${y}`; // D/M/YYYY
        const dmyPad = `${d}/${m}/${y}`; // DD/MM/YYYY
        const engMonth = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][effective.getMonth()];
        const engRegex = new RegExp(`\\b${engMonth}\\b\\s+${Number(d)}\\s+${y}`, 'i');
        const sameLocalDay = (dt) => dt && dt >= startLocal && dt < endExclusive;
        const isSameDayAny = (val) => {
          if (!val && val !== 0) return false;
          if (val instanceof Date) return sameLocalDay(val);
          if (typeof val === 'number') return sameLocalDay(new Date(val < 1e12 ? val*1000 : val));
          const s = String(val).trim();
          if (!s) return false;
          if (s === ymd || s === dmyNoPad || s === dmyPad) return true;
          if (engRegex.test(s)) return true;
          const dt = tryDateFrom(s);
          return sameLocalDay(dt);
        };
        const inDay = leads.filter(l => {
          const v = findFirst(l, createdPaths);
          return isSameDayAny(v);
        });
        // Construir filas de detalle (agente, servicio, etc.) y exponerlas globalmente
        const normalizeServicio = (lead) => {
          const raw = findFirst(lead, ['servicios_texto','servicios','producto','servicio','tipoProducto','producto.nombre']);
          if (Array.isArray(raw)) return raw.map(s=>String(s).trim()).filter(Boolean).join(', ');
          return (raw ? String(raw) : '').trim();
        };
        const normalizeAgente = (lead) => {
          const raw = findFirst(lead, ['agenteNombre','agente','createdBy','registeredBy','usuario','vendedor']);
          return (raw ? String(raw) : '').trim();
        };
        const detailRows = inDay.map(l => {
          const team = (findFirst(l, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']) || '').toString().trim();
          const servicio = normalizeServicio(l);
          const mercado = (findFirst(l, ['mercado','market','producto','servicio','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
          const pRaw = findFirst(l, ['puntaje','score','puntos']);
          const puntaje = typeof pRaw === 'number' ? pRaw : parseFloat(pRaw) || 0;
          const agente = normalizeAgente(l);
          const fechaFuente = findFirst(l, createdPaths);
          return { team, agente, servicio, mercado, puntaje: Number(puntaje || 0), fecha: fechaFuente };
        });
        window.DayDetailRows = { fecha: `${String(effective.getDate()).padStart(2,'0')}/${String(effective.getMonth()+1).padStart(2,'0')}/${effective.getFullYear()}`, rows: detailRows };

        // Intentar agregado del día desde backend (global)
        let preTeamData = null;
        try {
          const dayUrl = `/api/equipos/estadisticas?${qs}&scope=day&forceAll=1`;
          console.log('[DÍA] Solicitando datos a:', dayUrl);
          const aggResp = await fetchWithAuth(dayUrl);
          if (aggResp && aggResp.ok) {
            const dj = await aggResp.json();
            console.log('[DÍA] Respuesta del backend:', dj);
            if (dj && dj.success && Array.isArray(dj.data) && dj.data.length) {
                preTeamData = dj.data.map(equipo => ({
                name: equipo.TEAM || equipo.team || 'Sin equipo',
                ICON: parseFloat(equipo.ICON || 0),
                ACTIVAS: parseFloat(equipo.ACTIVAS || 0),
                BAMO: parseFloat(equipo.BAMO || 0),
                Total: parseFloat(equipo.Total || 0),
                Puntaje: parseFloat(equipo.Puntaje || 0)
              }));
              console.log('[DÍA] Datos procesados:', preTeamData);
            }
          }
        } catch(err) { console.error('[DÍA] Error en fetch principal:', err); }
        // Fallback: si no retornó datos o todo es cero y estamos viendo HOY, consulta sin fechas (scope=day)
        try {
          const sum = (arr)=> (arr||[]).reduce((a,r)=>a+(r.Total||0),0);
          const isTodayView = !new URLSearchParams(location.search).has('d');
          if ((!preTeamData || sum(preTeamData)===0) && isTodayView) {
            console.log('[DÍA] Usando fallback para HOY (sin fechas específicas)');
            const alt = await fetchWithAuth(`/api/equipos/estadisticas?scope=day&forceAll=1`);
            if (alt && alt.ok) {
              const dj2 = await alt.json();
                if (dj2 && dj2.success && Array.isArray(dj2.data) && dj2.data.length) {
                preTeamData = dj2.data.map(equipo => ({
                  name: equipo.TEAM || equipo.team || 'Sin equipo',
                  ICON: parseFloat(((equipo.ACTIVAS !== undefined) ? equipo.ACTIVAS : equipo.ICON) || 0),
                  BAMO: parseFloat(equipo.BAMO || 0),
                  Total: parseFloat(equipo.Total || 0),
                  Puntaje: parseFloat(equipo.Puntaje || 0)
                }));
              }
            }
          }
        } catch(_) {}

        const teamMap = new Map();
        const teamNameOf = (lead) => {
          const t = findFirst(lead, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']);
          const s = (t || '').toString().trim(); return s || 'Sin equipo';
        };
        const mercadoOf = (lead) => (String(findFirst(lead, ['mercado','market','producto','servicio','tipoProducto','producto.nombre'])||'').toUpperCase());
        const puntajeOf = (lead) => { const p = findFirst(lead, ['puntaje','score','puntos']); const n = typeof p === 'number' ? p : parseFloat(p); return isNaN(n) ? 0 : n; };
        if (preTeamData) {
          dayData = preTeamData;
        } else {
          inDay.forEach(l => { const name = teamNameOf(l); if (!teamMap.has(name)) teamMap.set(name, { name, ICON:0, BAMO:0, Total:0, Puntaje:0 }); const agg = teamMap.get(name); agg.Total += 1; const mk = mercadoOf(l); if (mk.includes('ICON')) agg.ICON += 1; else if (mk.includes('BAMO')) agg.BAMO += 1; agg.Puntaje += puntajeOf(l); });
          dayData = Array.from(teamMap.values());
        }

        // Separar LINEAS para panel derecho y excluirlas de la tabla principal
        const isLinea = (n) => /LINEA/i.test(String(n || ''));
        const lineasData = dayData.filter(t => isLinea(t.name)).map(r => ({ name: r.name, ICON: r.ICON || 0 }));
        const lineasTotalICON = lineasData.reduce((acc, r) => acc + (r.ICON || 0), 0);
        const excludeNames = new Set(dayData.filter(t => isLinea(t.name)).map(t => String(t.name).toUpperCase()));
        let mainData = dayData.filter(t => !excludeNames.has(String(t.name).toUpperCase()));

        // (removed duplicate ensureDayRows + porcentaje helper block) - functionality
        // moved to top-level to avoid nested IIFE interference and syntax issues.

          // Helper to force the day card back to its front (table) view and clean up daily chart
          window.__ensureDayFrontVisible = function(){
            try {
              const vp = document.getElementById('day-flip-local');
              if (!vp) return;
              if (!vp.classList.contains('is-flipped')) return;
              const scene = vp.querySelector('.flip-scene');
              const frontFace = vp.querySelector('.flip-face.front');
              // Temporarily disable transition to avoid any transitionend handlers re-hiding the front
              let prevTrans = '';
              try { prevTrans = scene && scene.style ? scene.style.transition || '' : ''; if (scene && scene.style) scene.style.transition = 'none'; } catch(_){}
              // remove flipped state so front becomes visible immediately
              vp.classList.remove('is-flipped');
              try { if (frontFace) { frontFace.classList.remove('flip-front-hidden'); frontFace.classList.add('force-visible'); } } catch(_){ }
              // restore any hidden sticky elements stored earlier
              try {
                const hidden = vp && vp.__hiddenSticky;
                if (hidden && Array.isArray(hidden)) {
                  hidden.forEach(item => { try{ item.el.style.visibility = item.vis || ''; } catch(_){} });
                  vp.__hiddenSticky = null;
                }
              } catch(_){ }
              try { if (window.__dailyChart) { window.__dailyChart.destroy(); window.__dailyChart = null; } } catch(_){ }
              const wrap = vp.querySelector('.chart-wrapper');
              if (wrap) { try { wrap.style.height = ''; wrap.style.maxHeight = ''; wrap.style.overflow = ''; wrap.style.paddingBottom = ''; } catch(_){} }
              // Forcefully restore any table elements inside the front face (in case they were hidden)
              try {
                const tables = (frontFace && frontFace.querySelectorAll) ? Array.from(frontFace.querySelectorAll('table')) : [];
                tables.forEach(tbl => {
                  try {
                    tbl.style.display = '';
                    tbl.style.visibility = 'visible';
                    tbl.style.opacity = '1';
                    tbl.style.pointerEvents = '';
                    try { tbl.style.setProperty('visibility','visible','important'); tbl.style.setProperty('display','table','important'); tbl.style.setProperty('opacity','1','important'); } catch(_){}
                  } catch(_){}
                });
              } catch(_){}
              // Also force the front face visible with !important to override any lingering CSS rules
              try { if (frontFace) { frontFace.style.setProperty('visibility','visible','important'); frontFace.style.setProperty('display','block','important'); frontFace.style.setProperty('opacity','1','important'); } } catch(_){}
              // force reflow then restore transition
              try { void vp.offsetHeight; if (scene && scene.style) scene.style.transition = prevTrans || 'transform 360ms cubic-bezier(.2,.8,.2,1)'; } catch(_){}
              setTimeout(() => { try { vp.style.height = ''; vp.style.minHeight = ''; if (scene) { scene.style.minHeight = ''; scene.style.height = ''; } } catch(_){} }, 200);
              window.__dayFlipAnimating = false;
            } catch(e){ console.warn('ensureDayFrontVisible error', e); }
          };

        // Utility: aggressively clear any inline visibility/display styles that may hide the day front/table
        window.__clearDayHiddenStyles = function(){
          try {
            console.log('[__clearDayHiddenStyles] running');
            const root = document.getElementById('ventas-dia-card');
            if (!root) { console.log('[__clearDayHiddenStyles] no root found'); return; }
            // Clear inline visibility:hidden on the front face and any tables inside
            const vp = root.querySelector('#day-flip-local') || root.querySelector('.conversion-card');
            if (!vp) { console.log('[__clearDayHiddenStyles] no vp found'); return; }
            const fronts = vp.querySelectorAll ? vp.querySelectorAll('.flip-face.front, .conversion-card, .conv-left, .conv-two-col') : [];
            Array.from(fronts).forEach(el => {
              try {
                // remove specific inline properties that may force hidden state
                if (el.style) {
                  if (el.style.visibility && el.style.visibility.indexOf('hidden') !== -1) el.style.visibility = '';
                  if (el.style.display && el.style.display.indexOf('none') !== -1) el.style.display = '';
                  el.style.opacity = el.style.opacity === '0' ? '' : el.style.opacity;
                  el.style.pointerEvents = el.style.pointerEvents === 'none' ? '' : el.style.pointerEvents;
                  el.style.transform = el.style.transform === 'none' ? '' : el.style.transform;
                }
              } catch(_){}
            });
            // Also clear any tables specifically
            const tables = vp.querySelectorAll ? vp.querySelectorAll('table') : [];
            Array.from(tables).forEach(tbl => {
              try {
                if (tbl.style) {
                  if (tbl.style.visibility && tbl.style.visibility.indexOf('hidden') !== -1) tbl.style.visibility = '';
                  if (tbl.style.display && tbl.style.display.indexOf('none') !== -1) tbl.style.display = '';
                  if (tbl.style.opacity === '0') tbl.style.opacity = '';
                  tbl.style.pointerEvents = '';
                }
              } catch(_){}
            });
            // Finally, ensure the root container isn't hidden
            try { if (root.style && root.style.visibility && root.style.visibility.indexOf('hidden') !== -1) root.style.visibility = ''; } catch(_){ }
            try { console.log('[__clearDayHiddenStyles] cleared, tables:', (tables && tables.length) || 0); } catch(_){ }
          } catch(e){ try{ console.warn('__clearDayHiddenStyles error', e); }catch(_){} }
        };

        // Install a MutationObserver to auto-clear any inline visibility:hidden on the day front/table
        window.__installDayVisibilityObserver = function(){
          try {
            if (window.__dayVisibilityObserver) return;
            const root = document.getElementById('ventas-dia-card');
            try { console.log('[VIS-OBSERVER] installing for #ventas-dia-card', !!root); } catch(_){ }
            if (!root) return;
            const obs = new MutationObserver((mutations) => {
              try {
                for (const m of mutations) {
                  if (m.type === 'attributes' && (m.attributeName === 'style' || m.attributeName === 'class')) {
                    const el = m.target;
                    try {
                      const cs = window.getComputedStyle(el);
                      if (cs && cs.visibility === 'hidden' && cs.display !== 'none') {
                        try { console.log('[VIS-OBSERVER] clearing hidden style on', el); } catch(_){}
                        el.style.visibility = '';
                        el.style.display = '';
                        el.style.opacity = '';
                        el.style.pointerEvents = '';
                        el.style.transform = '';
                      }
                    } catch(_){}
                  }
                  if (m.addedNodes && m.addedNodes.length) {
                    Array.from(m.addedNodes).forEach(n => {
                      if (n.nodeType !== 1) return;
                      try {
                        const targets = n.querySelectorAll ? n.querySelectorAll('.flip-face.front, table') : [];
                        Array.from(targets).forEach(el => {
                          try {
                            const cs = window.getComputedStyle(el);
                            if (cs && cs.visibility === 'hidden' && cs.display !== 'none') {
                              try { console.log('[VIS-OBSERVER] clearing hidden on added node', el); } catch(_){}
                              el.style.visibility = '';
                              el.style.display = '';
                              el.style.opacity = '';
                              el.style.pointerEvents = '';
                              el.style.transform = '';
                            }
                          } catch(_){}
                        });
                      } catch(_){}
                    });
                  }
                }
              } catch(e){ try{ console.warn('[VIS-OBSERVER] error', e); }catch(_){} }
            });
            obs.observe(root, { attributes: true, childList: true, subtree: true, attributeFilter: ['style','class'] });
            window.__dayVisibilityObserver = obs;
            try { console.log('[VIS-OBSERVER] installed'); } catch(_){ }
          } catch(e){ try{ console.warn('installDayVisibilityObserver error', e); }catch(_){} }
        };

        // Construir bloque del DÍA (título, flechas y panel derecho) SIN el contenedor externo
        const tablaHtml = `
          <div style="display:flex; align-items:center; justify-content:space-between; padding:8px 12px; background:#fef3c7; border-radius:8px;">
            <button id="day-prev-alt" class="filter-button" style="height:32px;width:32px;font-size:16px;" title="Día anterior">◀</button>
            <div class="conversion-title" style="margin:0; background: transparent;">VENTAS POR MERCADO Y PUNTAJE DEL DÍA (${diaTexto})</div>
            <button id="day-next-alt" class="filter-button" style="height:32px;width:32px;font-size:16px;" title="Día siguiente">▶</button>
          </div>
          <div style="display:flex; justify-content:flex-end; margin:8px 0 6px;">
            <button id="btn-detalle-dia" class="filter-button" style="height:28px;">Ver detalle</button>
          </div>
          <div class="conv-two-col slide-container">
            <div class="conv-left">
              <table class="sales-table" style="width:100%">
                <thead>
                  <tr>
                    <th>EQUIPO</th>
                    <th>ICON</th>
                    <th>BAMO</th>
                    <th>TOTAL</th>
                    <th>PUNTAJE</th>
                  </tr>
                </thead>
                <tbody>
                  ${mainData.map(team => `
                    <tr>
                      <td>${team.name}</td>
                      <td>${team.ICON || 0}</td>
                      <td>${team.BAMO || 0}</td>
                      <td>${team.Total || 0}</td>
                      <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                    </tr>
                  `).join('')}
                  <tr class="total-row">
                    <td>TOTAL</td>
                    <td>${mainData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                    <td>${mainData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                    <td>${mainData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                    <td>${mainData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(2)}</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="conv-right">
              <div class="mini-card">
                <table class="mini-table">
                  <thead>
                    <tr>
                      <th>TEAM LINEAS</th>
                      <th>ICON</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${(lineasData || []).map(r => `
                      <tr>
                        <td>${r.name}</td>
                        <td>${r.ICON || 0}</td>
                      </tr>
                    `).join('')}
                    <tr class="total">
                      <td>TOTAL</td>
                      <td class="total-icon">${lineasTotalICON}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        `;

  container.innerHTML = tablaHtml;
  // Clear any stray inline hidden styles that some browsers may have left behind
  try { if (typeof window.__clearDayHiddenStyles === 'function') window.__clearDayHiddenStyles(); } catch(_){ }
  // Ensure the flip button is injected after we render the day card
  try { if (typeof window.injectDayFlipButton === 'function') window.injectDayFlipButton(); } catch(_){ }
        // Hook botón detalle (con fallback y delegación)
        try {
          const openDetail = () => {
            try { if (typeof ensureDayDetailModal === 'function') ensureDayDetailModal(); } catch(_){}
            try { showDayDetailModal(); }
            catch(e){
              console.warn('Fallback abrir detalle del día', e);
              const overlay = document.getElementById('day-detail-modal');
              if (overlay) overlay.style.display = 'flex';
            }
          };
          const btnDet = document.getElementById('btn-detalle-dia');
          if (btnDet) btnDet.addEventListener('click', openDetail);
          // Delegación por si el botón se re-renderiza
          container.addEventListener('click', (ev)=>{
            const t = ev.target;
            if (t && t.id === 'btn-detalle-dia') { ev.preventDefault(); openDetail(); }
          });
        } catch(_) {}
        // Safety enforcement: on Sundays, force display order to GROUP B in the DOM
        try {
          const dowToday = (new Date()).getDay(); // 0=Sun
          if (dowToday === 0) {
            const ORDER_B = ['Pleitez','Roberto','Marisol'];
            const card = container.querySelector('.conversion-card');
            const tbody = card && card.querySelector('.sales-table tbody');
            if (tbody) {
              const totalRow = tbody.querySelector('.total-row');
              const totalHTML = totalRow ? totalRow.outerHTML : '';
              const buildRow = (name)=>`<tr><td>${name}</td><td>0</td><td>0</td><td>0</td><td class="score-col">0.00</td></tr>`;
              tbody.innerHTML = ORDER_B.map(buildRow).join('') + totalHTML;
              console.log('[ESTADISTICAS][DAY][DOM] Enforced Sunday GROUP B');
            }
            // Also set a MutationObserver to re-apply if the section re-renders later
            if (!window.__statsDayObserverB) {
              const apply = () => {
                const c = document.querySelector('#ventas-dia-card .conversion-card');
                const tb = c && c.querySelector('.sales-table tbody');
                if (!tb) return false;
                const totalRow = tb.querySelector('.total-row');
                const totalHTML = totalRow ? totalRow.outerHTML : '';
                const buildRow = (name)=>`<tr><td>${name}</td><td>0</td><td>0</td><td>0</td><td class="score-col">0.00</td></tr>`;
                tb.innerHTML = ORDER_B.map(buildRow).join('') + totalHTML;
                console.log('[ESTADISTICAS][DAY][DOM] Observer re-applied GROUP B');
                return true;
              };
              // Try now; if not, observe until it appears or timeout
              if (!apply()) {
                const mo = new MutationObserver(() => { if (apply()) { try { mo.disconnect(); } catch(_) {} window.__statsDayObserverB = null; } });
                mo.observe(document.body, { childList: true, subtree: true });
                window.__statsDayObserverB = mo;
                setTimeout(() => { try { mo.disconnect(); } catch(_) {} window.__statsDayObserverB = null; }, 15000);
              }
            }
          }
        } catch(_) {}
        // Hook botón detalle
        const btnDet = document.getElementById('btn-detalle-dia');
        if (btnDet) {
          btnDet.addEventListener('click', () => {
            try { showDayDetailModal(); } catch (e) { console.error('No se pudo abrir detalle del día', e); }
          });
        }
        // Hook flechas navegación día
        try {
          const btnPrev = document.getElementById('day-prev-alt');
          const btnNext = document.getElementById('day-next-alt');
          if (btnPrev) {
            btnPrev.onclick = () => { 
              const d = new Date(effective); 
              d.setDate(d.getDate()-1); 
              location.href = `?d=${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; 
            };
            console.log('[DÍA] Botón anterior conectado');
          } else {
            console.warn('[DÍA] Botón anterior NO encontrado');
          }
          if (btnNext) {
            btnNext.onclick = () => { 
              const d = new Date(effective); 
              d.setDate(d.getDate()+1); 
              location.href = `?d=${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; 
            };
            console.log('[DÍA] Botón siguiente conectado');
          } else {
            console.warn('[DÍA] Botón siguiente NO encontrado');
          }
        } catch(err) { 
          console.error('[DÍA] Error al conectar flechas:', err); 
        }
        // Tabs inline en tarjeta del Día
        try {
          const pad2 = (n)=> String(n).padStart(2,'0');
          const formatDMY = (d)=> `${pad2(d.getDate())}/${pad2(d.getMonth()+1)}/${d.getFullYear()}`;
          const formatMY = (d)=> `${pad2(d.getMonth()+1)}/${d.getFullYear()}`;
          const today = new Date();
          const title = container.querySelector('.conversion-title');
          const table = container.querySelector('.sales-table');
          const btnDay = container.querySelector('#tab-dia-day');
          const btnMonth = container.querySelector('#tab-dia-month');
          const setActive = (which)=>{
            if (!btnDay || !btnMonth) return;
            btnDay.style.background = which==='day' ? '#22b3ec' : '';
            btnDay.style.color = which==='day' ? '#fff' : '';
            btnMonth.style.background = which==='month' ? '#22b3ec' : '';
            btnMonth.style.color = which==='month' ? '#fff' : '';
          };
          const renderTable = (rows)=>{
            const tbody = table?.querySelector('tbody');
            if (!tbody) return;
            const body = (rows||[]).map(r=>`<tr><td>${r.name}</td><td>${r.ICON||0}</td><td>${r.BAMO||0}</td><td>${r.Total||0}</td><td class="score-col">${parseFloat(r.Puntaje||0).toFixed(2)}</td></tr>`).join('');
            const totals = (rows||[]).reduce((a,r)=>({ICON:a.ICON+(r.ICON||0),BAMO:a.BAMO+(r.BAMO||0),Total:a.Total+(r.Total||0),Puntaje:a.Puntaje+parseFloat(r.Puntaje||0)}),{ICON:0,BAMO:0,Total:0,Puntaje:0});
            const total = `<tr class="total-row"><td>TOTAL</td><td>${totals.ICON}</td><td>${totals.BAMO}</td><td>${totals.Total}</td><td>${totals.Puntaje.toFixed(2)}</td></tr>`;
            tbody.innerHTML = body + total;
          };
          const showDay = ()=>{ 
            try { if (typeof window.__ensureDayFrontVisible === 'function') window.__ensureDayFrontVisible(); } catch(_){}
            // As a robust fallback, temporarily force the front face visible
            try {
              const vp = document.getElementById('day-flip-local');
              const front = vp && vp.querySelector ? vp.querySelector('.flip-face.front') : null;
              if (front) {
                front.classList.add('force-visible');
                setTimeout(() => { try { front.classList.remove('force-visible'); } catch(_){} }, 500);
              }
            } catch(_){}
            setActive('day'); if (title) title.textContent = `VENTAS POR MERCADO Y PUNTAJE DEL DÍA (${formatDMY(today)})`; renderTable(window.DayRowsOriginal||[]); };
          const showMonth = ()=>{ 
            try { if (typeof window.__ensureDayFrontVisible === 'function') window.__ensureDayFrontVisible(); } catch(_){}
            try {
              const vp = document.getElementById('day-flip-local');
              const front = vp && vp.querySelector ? vp.querySelector('.flip-face.front') : null;
              if (front) {
                front.classList.add('force-visible');
                setTimeout(() => { try { front.classList.remove('force-visible'); } catch(_){} }, 500);
              }
            } catch(_){}
            setActive('month'); if (title) title.textContent = `VENTAS POR MERCADO Y PUNTAJE DEL MES (${formatMY(today)})`; renderTable(window.MonthDisplayRows||[]); };
          if (btnDay) btnDay.onclick = showDay;
          if (btnMonth) btnMonth.onclick = showMonth;
          // Selección por defecto: Día
          showDay();
        } catch(_) {}
        // Control de equipos se mueve al modal "Ver detalle"
      } catch (e) {
        console.error('Error cargando datos del día:', e);
        container.innerHTML = `
          <div class="conversion-card">
            <div class="conversion-title">VENTAS POR MERCADO Y PUNTAJE DEL DÍA (${diaTexto})</div>
            <div class="conv-two-col">
              <div class="conv-left">
                <table class="sales-table">
                  <thead>
                    <tr>
                      <th>EQUIPO</th>
                      <th>ICON</th>
                      <th>BAMO</th>
                      <th>TOTAL</th>
                      <th>PUNTAJE</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td colspan="5" style="text-align:center; padding:16px; color:#666; font-style:italic;">Error de conexión</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        `;
      }
    }

    // ====== MODAL DETALLE DÍA ======
    // Estilos básicos del modal (inline para no depender de CSS externo)
    (function ensureModalStyles(){
      const css = `
      .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
      .modal{background:#fff;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.2);max-width:960px;width:92%;max-height:80vh;overflow:auto}
      .modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e2e8f0;font-weight:800}
      .close-btn{border:none;background:#e11d48;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
      .table-compact{width:100%;border-collapse:collapse;font-size:.9rem}
      .table-compact th,.table-compact td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left}
      .table-compact th{background:#1f3b63;color:#fff}
      .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
      `;
      const s = document.createElement('style'); s.textContent = css; document.head.appendChild(s);
    })();

    // (El contenedor de modal del día se define estático en el HTML; no recrear dinámicamente)

    function hideDayDetailModal(){
      const el = document.getElementById('day-detail-modal');
      if (el) el.style.display = 'none';
    }

    function showDayDetailModal(){
      try{
        console.log('[MODAL] showDayDetailModal invoked', { DayDetailRows: !!window.DayDetailRows });
        const store = window.DayDetailRows || { fecha:'', rows:[] };
        const rows = Array.isArray(store.rows) ? store.rows : [];
        const overlay = document.getElementById('day-detail-modal');
        if (!overlay) return;
        const tbody = overlay.querySelector('#day-detail-table tbody');
        const sel = overlay.querySelector('#filter-team-select');
        const subtitle = overlay.querySelector('#day-detail-subtitle');

        subtitle.textContent = `Fecha: ${store.fecha}`;

        // Poblar select de equipos
        const teams = Array.from(new Set(rows.map(r => (r.team||'').toString().trim()).filter(Boolean))).sort();
        sel.innerHTML = `<option value="">Todos</option>` + teams.map(t=>`<option value="${t}">${t}</option>`).join('');

        function render(filterTeam){
          const data = rows.filter(r => !filterTeam || String(r.team).trim() === filterTeam);
          tbody.innerHTML = data.map(r => `
            <tr>
              <td>${r.team || ''}</td>
              <td>${r.agente || ''}</td>
              <td>${r.servicio || ''}</td>
              <td>${r.mercado || ''}</td>
              <td>${Number(r.puntaje||0).toFixed(2)}</td>
              <td>${typeof r.fecha==='string' ? r.fecha : (r.fecha instanceof Date ? r.fecha.toISOString() : (r.fecha||''))}</td>
            </tr>
          `).join('');
        }

        render('');
        sel.onchange = () => render(sel.value);

        overlay.style.display = 'flex';
      } catch(e){ console.error('Error abriendo detalle del día', e); }
    }

    // FunciÃ³n para inicializar la tabla de conversiÃ³n
    function initConversionTable() {
      console.log('Inicializando tabla de conversiÃ³n...');
      const convRoot = document.getElementById('conversion-table');
      if (convRoot) {
        console.log('Elemento conversion-table encontrado, renderizando...');
        renderConversionTable(document.getElementById('conversion-table'));
      } else {
        console.error('No se encontrÃ³ el elemento con ID conversion-table');
      }
    }

    // Función para cargar y renderizar la tabla del Día con el mismo diseño que la del Mes
    async function loadDayData() {
      console.log('Cargando datos del día actual...');
      const container = document.getElementById('ventas-dia-card');
      if (!container) {
        console.error('No se encontró el contenedor #ventas-dia-card');
        return;
      }

      // Leer parámetro ?d= si existe para navegación
      const urlParams = new URLSearchParams(location.search);
      const dParam = urlParams.get('d');
      const cutoffHour = 9, cutoffMinute = 30;
      let effective;
      if (dParam && /^\d{4}-\d{2}-\d{2}$/.test(dParam)) {
        const [y,m,d] = dParam.split('-').map(Number);
        effective = new Date(y, m-1, d, 12, 0, 0);
      } else {
        const nowLocal = new Date();
        const beforeCutoff = (nowLocal.getHours() < cutoffHour) || (nowLocal.getHours() === cutoffHour && nowLocal.getMinutes() < cutoffMinute);
        effective = new Date(nowLocal);
        if (beforeCutoff) effective.setDate(effective.getDate() - 1);
      }
      const diaTexto = `${String(effective.getDate()).padStart(2,'0')}/${String(effective.getMonth()+1).padStart(2,'0')}/${effective.getFullYear()}`;

      // Placeholder de carga
      container.innerHTML = `
        <div class="text-center" style="padding: 12px; color:#666;">Cargando datos del día...</div>
      `;

      try {
        // 1) Intentar primero el endpoint de equipos con fecha efectiva
        const y = effective.getFullYear();
        const m = String(effective.getMonth()+1).padStart(2,'0');
        const d = String(effective.getDate()).padStart(2,'0');
        const qs = `fechaInicio=${y}-${m}-${d}&fechaFin=${y}-${m}-${d}&scope=day`;
        // Construir SIEMPRE desde /api/leads con ventana [00:00, +1 día 09:30]
        let dayData = [];
        const startLocal = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate(), 0, 0, 0, 0);
        // Si navegamos con ?d=, capturar TODO el día (00:00 a 23:59:59)
        const urlParams2 = new URLSearchParams(location.search);
        const isNavigating2 = urlParams2.has('d');
        const endExclusive = isNavigating2 
          ? new Date(effective.getFullYear(), effective.getMonth(), effective.getDate() + 1, 0, 0, 0, 0)
          : new Date(effective.getFullYear(), effective.getMonth(), effective.getDate() + 1, cutoffHour, cutoffMinute, 0, 0);
        const leadsResp = await fetchWithAuth(`/api/leads?fechaInicio=${y}-${m}-${d}&fechaFin=${y}-${m}-${d}&skipDate=1&t=${Date.now()}`);
        if (!leadsResp) return;
        const leadsJson = await leadsResp.json();
        const leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
        const getByPath = (obj, path) => { try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch (_) { return undefined; } };
        const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
        const tryDateFrom = (val) => { if (!val) return null; if (typeof val === 'string') { const s = val.trim(); if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [yy,mm,dd] = s.split('-').map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) { const [dd,mm,yy] = s.split(/[\/\-]/).map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } } const dt = new Date(val); return isNaN(dt) ? null : dt; };
        const createdPaths = ['dia_venta','diaVenta','fecha_contratacion','creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha'];
        // Helpers para comparar el mismo día (mismos que el bloque superior)
        const ymd = `${y}-${m}-${d}`;
        const dmyNoPad = `${Number(d)}/${Number(m)}/${y}`;
        const dmyPad = `${d}/${m}/${y}`;
        const engMonth = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][effective.getMonth()];
        const engRegex = new RegExp(`\\b${engMonth}\\b\\s+${Number(d)}\\s+${y}`, 'i');
        const sameLocalDay = (dt) => dt && dt >= startLocal && dt < endExclusive;
        const isSameDayAny = (val) => {
          if (!val && val !== 0) return false;
          if (val instanceof Date) return sameLocalDay(val);
          if (typeof val === 'number') return sameLocalDay(new Date(val < 1e12 ? val*1000 : val));
          const s = String(val).trim();
          if (!s) return false;
          if (s === ymd || s === dmyNoPad || s === dmyPad) return true;
          if (engRegex.test(s)) return true;
          const dt = tryDateFrom(s);
          return sameLocalDay(dt);
        };
        const inDay = leads.filter(l => { const v = findFirst(l, createdPaths); return isSameDayAny(v); });
        // Construir filas de detalle (agente, servicio, etc.) y exponerlas globalmente
        const normalizeServicio = (lead) => {
          const raw = findFirst(lead, ['servicios_texto','servicios','producto','servicio','tipoProducto','producto.nombre']);
          if (Array.isArray(raw)) return raw.map(s=>String(s).trim()).filter(Boolean).join(', ');
          return (raw ? String(raw) : '').trim();
        };
        const normalizeAgente = (lead) => {
          const raw = findFirst(lead, ['agenteNombre','agente','createdBy','registeredBy','usuario','vendedor']);
          return (raw ? String(raw) : '').trim();
        };
        const detailRows = inDay.map(l => {
          const team = (findFirst(l, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']) || '').toString().trim();
          const servicio = normalizeServicio(l);
          const mercado = (findFirst(l, ['mercado','market','producto','servicio','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
          const pRaw = findFirst(l, ['puntaje','score','puntos']);
          const puntaje = typeof pRaw === 'number' ? pRaw : parseFloat(pRaw) || 0;
          const agente = normalizeAgente(l);
          const fechaFuente = findFirst(l, createdPaths);
          return { team, agente, servicio, mercado, puntaje: Number(puntaje || 0), fecha: fechaFuente };
        });
        window.DayDetailRows = { fecha: `${String(effective.getDate()).padStart(2,'0')}/${String(effective.getMonth()+1).padStart(2,'0')}/${effective.getFullYear()}`, rows: detailRows };

        const teamMap = new Map();
        const teamNameOf = (lead) => {
          const t = findFirst(lead, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']);
          const s = (t || '').toString().trim(); return s || 'Sin equipo';
        };
        const mercadoOf = (lead) => (String(findFirst(lead, ['mercado','market','producto','servicio','tipoProducto','producto.nombre'])||'').toUpperCase());
        const puntajeOf = (lead) => { const p = findFirst(lead, ['puntaje','score','puntos']); const n = typeof p === 'number' ? p : parseFloat(p); return isNaN(n) ? 0 : n; };
        inDay.forEach(l => { const name = teamNameOf(l); if (!teamMap.has(name)) teamMap.set(name, { name, ICON:0, BAMO:0, Total:0, Puntaje:0 }); const agg = teamMap.get(name); agg.Total += 1; const mk = mercadoOf(l); if (mk.includes('ICON')) agg.ICON += 1; else if (mk.includes('BAMO')) agg.BAMO += 1; agg.Puntaje += puntajeOf(l); });
        dayData = Array.from(teamMap.values());

        // Separar LINEAS para panel derecho y excluirlas de la tabla principal
        const isLinea = (n) => /LINEA/i.test(String(n || ''));
        const lineasData = dayData.filter(t => isLinea(t.name)).map(r => ({ name: r.name, ICON: r.ICON || 0 }));
        const lineasTotalICON = lineasData.reduce((acc, r) => acc + (r.ICON || 0), 0);
        const excludeNames = new Set(dayData.filter(t => isLinea(t.name)).map(t => String(t.name).toUpperCase()));
        let mainData = dayData.filter(t => !excludeNames.has(String(t.name).toUpperCase()));

        // Completar equipos y fijar orden (siempre todos los equipos)
        (function ensureDayRows(){
          try {
            const norm = (s)=>String(s||'').normalize('NFD').replace(/\p{Diacritic}+/gu,'').trim().toLowerCase();
            const ORDER_ALL = ['Pleitez','Roberto','Marisol','Johana','Irania'];
            const ORDER_A = ['Johana','Irania'];
            const ORDER_B = ['Pleitez','Roberto','Marisol'];
            const dow = effective.getDay();
            let order = ORDER_ALL;
            const map = new Map((mainData||[]).map(t=>[norm(t?.name), t]));
            const ensureRow = (name)=> map.get(norm(name)) || { name, ICON:0, BAMO:0, Total:0, Puntaje:0 };
            mainData = order.map(ensureRow);
            try { window.DayDisplayRows = mainData.slice(); } catch(_) {}
          } catch(e) { console.warn('[ESTADISTICAS][DAY-2] ensure rows error:', e); }
        })();

        // Construir HTML con el mismo diseño (conversion-card + sales-table) incluyendo panel LINEAS a la derecha
        const tablaHtml = `
            <div class="conversion-card">
              <div style="display:flex; align-items:center; justify-content:space-between; padding:8px 12px; background:#fef3c7; border-radius:8px 8px 0 0;">
                <button id="day-prev-alt" class="filter-button" style="height:32px;width:32px;font-size:16px;" title="Día anterior">◀</button>
                <div class="conversion-title" style="margin:0;">VENTAS POR MERCADO Y PUNTAJE DEL DÍA (${diaTexto})</div>
                <button id="day-next-alt" class="filter-button" style="height:32px;width:32px;font-size:16px;" title="Día siguiente">▶</button>
              </div>
              <div style="display:flex; justify-content:flex-end; margin:8px 0 6px;">
                <button id="btn-detalle-dia" class="filter-button" style="height:28px;">Ver detalle</button>
              </div>
              <div class="conv-two-col">
                <div class="conv-left">
                  <table class="sales-table">
                    <thead>
                      <tr>
                        <th>EQUIPO</th>
                        <th>ICON</th>
                        <th>BAMO</th>
                        <th>TOTAL</th>
                        <th>PUNTAJE</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${mainData.map(team => `
                        <tr>
                          <td>${team.name}</td>
                          <td>${team.ICON || 0}</td>
                          <td>${team.BAMO || 0}</td>
                          <td>${team.Total || 0}</td>
                          <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                        </tr>
                      `).join('')}
                      <tr class="total-row">
                        <td>TOTAL</td>
                        <td>${mainData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                        <td>${mainData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                        <td>${mainData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                        <td>${mainData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(2)}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="conv-right">
                  <div class="mini-card">
                    <table class="mini-table">
                      <thead>
                        <tr>
                          <th>TEAM LINEAS</th>
                          <th>ICON</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${(lineasData || []).map(r => `
                          <tr>
                            <td>${r.name}</td>
                            <td>${r.ICON || 0}</td>
                          </tr>
                        `).join('')}
                        <tr class="total">
                          <td>TOTAL</td>
                          <td class="total-icon">${lineasTotalICON}</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          `;

  container.innerHTML = tablaHtml;
  // Clear inline hidden styles just in case a previous flip left elements hidden
  try { if (typeof window.__clearDayHiddenStyles === 'function') window.__clearDayHiddenStyles(); } catch(_){ }
        // Helpers de animación (carrusel) para navegación con ?d=
        const animateSwap = async (rootEl, direction, update) => {
          try {
            const card = container; // usar el propio contenedor
            card.classList.add('slide-card');
            card.classList.remove('slide-enter-from-left','slide-enter-from-right','slide-enter-active');
            card.classList.add(direction === 'prev' ? 'slide-exit-right' : 'slide-exit-left');
            await new Promise(r => setTimeout(r, 200));
            card.classList.remove('slide-exit-right','slide-exit-left');
            await update();
            // Entrada
            card.classList.add('slide-card','slide-enter-base', direction === 'prev' ? 'slide-enter-from-left' : 'slide-enter-from-right');
            requestAnimationFrame(() => {
              card.classList.add('slide-enter-active');
              card.classList.remove('slide-enter-from-left','slide-enter-from-right');
              setTimeout(()=>{ card.classList.remove('slide-card','slide-enter-base','slide-enter-active'); }, 280);
            });
          } catch(_) { await update(); }
        };

        // Hook flechas navegación día (alternativas)
        try {
          // Botones ya no existen, navegar con teclado (opcional) o programático
          const btnPrevAlt = null;
          const btnNextAlt = null;
          document.addEventListener('keydown', async (e) => {
            if (e.key === 'ArrowLeft') {
              const d2 = new Date(effective); d2.setDate(d2.getDate()-1);
              const newQ = `?d=${d2.getFullYear()}-${String(d2.getMonth()+1).padStart(2,'0')}-${String(d2.getDate()).padStart(2,'0')}`;
              await animateSwap(container, 'prev', async () => { history.replaceState({}, '', newQ); await loadDayData(); });
            } else if (e.key === 'ArrowRight') {
              const d2 = new Date(effective); d2.setDate(d2.getDate()+1);
              const newQ = `?d=${d2.getFullYear()}-${String(d2.getMonth()+1).padStart(2,'0')}-${String(d2.getDate()).padStart(2,'0')}`;
              await animateSwap(container, 'next', async () => { history.replaceState({}, '', newQ); await loadDayData(); });
            }
          });
        } catch(_) {}
      } catch (e) {
        console.error('Error cargando datos del día:', e);
        container.innerHTML = `
          <div class="conversion-card">
            <div class="conversion-title">VENTAS POR MERCADO Y PUNTAJE DEL DÍA (${diaTexto})</div>
            <div class="conv-two-col">
              <div class="conv-left">
                <table class="sales-table">
                  <thead>
                    <tr>
                      <th>EQUIPO</th>
                      <th>ICON</th>
                      <th>BAMO</th>
                      <th>TOTAL</th>
                      <th>PUNTAJE</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td colspan="5" style="text-align:center; padding:16px; color:#666; font-style:italic;">Error de conexión</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        `;
      }
    }

    // ===== FUNCIONES DE LA GRÁFICA DE VENTAS Y PUNTAJE =====
    
    // Variables globales para la nueva gráfica
    let ventasPuntajeChart = null;
    
    // Datos de prueba para la gráfica
    const datosPrueba = [
      { fecha: '2025-08-06', ventas: 12, puntaje: 85 },
      { fecha: '2025-08-07', ventas: 8, puntaje: 70 },
      { fecha: '2025-08-08', ventas: 15, puntaje: 95 },
      { fecha: '2025-08-09', ventas: 10, puntaje: 80 },
      { fecha: '2025-08-10', ventas: 20, puntaje: 100 },
      { fecha: '2025-08-11', ventas: 14, puntaje: 88 },
      { fecha: '2025-08-12', ventas: 18, puntaje: 90 }
    ];

    // Función para inicializar la gráfica de ventas y puntaje
    function inicializarGraficaVentasPuntaje() {
      try {
        const canvas = document.getElementById('ventasPuntajeChart');
        if (!canvas) {
          console.error('No se encontró el elemento canvas para la gráfica de ventas y puntaje');
          return null;
        }
        
        if (ventasPuntajeChart) {
          console.log('Destruyendo instancia anterior del gráfico...');
          ventasPuntajeChart.destroy();
          ventasPuntajeChart = null;
        }
        
        const ctx = canvas.getContext('2d');
        const container = canvas.parentElement;
        container.style.width = '100%';
        container.style.height = '400px';
        
        return new Chart(ctx, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Ventas',
                type: 'bar',
                backgroundColor: 'rgba(54, 162, 235, 0.5)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                yAxisID: 'y',
                datalabels: {
                  anchor: 'end',
                  align: 'end',
                  offset: 4,
                  color: '#2c3e50',
                  font: { weight: 'bold' },
                  formatter: (v) => (v != null && !isNaN(v) && Number(v) !== 0 ? Math.round(v) : '')
                }
              },
              {
                label: 'Puntaje',
                type: 'bar',
                backgroundColor: 'rgba(255, 99, 132, 0.7)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                borderRadius: 4,
                yAxisID: 'y1',
                datalabels: {
                  anchor: 'end',
                  align: 'end',
                  offset: 4,
                  color: '#7f1d1d',
                  font: { weight: 'bold' },
                  formatter: (v) => {
                    if (v == null || isNaN(v) || Number(v) === 0) return '';
                    const n = Number(v);
                    return n.toFixed(2).replace(/\.00$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
                  }
                }
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { bottom: 40 } },
            plugins: {
              legend: {
                position: 'right'
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed !== null) {
                      label += context.parsed;
                    }
                    return label;
                  }
                }
              },
              datalabels: {
                display: false,
                formatter: () => '',
                clamp: true,
                clip: false
              }
            },
            scales: {
              y: {
                type: 'linear',
                display: true,
                position: 'left',
                title: { display: false, text: 'Ventas' },
                grid: { display: false, drawTicks: false },
                border: { display: false },
                ticks: { display: false, callback: () => '' }
              },
              y1: {
                type: 'linear',
                display: true,
                position: 'right',
                grid: { display: false, drawOnChartArea: false, drawTicks: false },
                border: { display: false },
                title: { display: false, text: 'Puntaje' },
                ticks: { display: false, callback: () => '' },
                min: 0,
                max: 100
              },
              x: {
                display: true,
                grid: { display: false },
                ticks: { display: false, callback: () => '' },
                title: { display: false, text: '' }
              }
            },
            elements: {
              point: { radius: 0, hoverRadius: 0 }
            }
          }
        });
      } catch (error) {
        console.error('Error al inicializar la gráfica de ventas y puntaje:', error);
        return null;
      }
    }

    // Función para mostrar notificaciones
    function mostrarNotificacion(mensaje, tipo = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${tipo}`;
      notification.innerHTML = `
        <i class="fas ${tipo === 'success' ? 'fa-check-circle' : 'fa-exclamation-triangle'}"></i>
        ${mensaje}
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.classList.add('show');
      }, 100);
      
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    // Función para mostrar mensajes de error
    function mostrarMensajeError(mensaje) {
      mostrarNotificacion(mensaje, 'error');
    }

    // Función para actualizar la gráfica de ventas y puntaje con datos de la API
    async function actualizarGraficaVentasPuntaje(datos = null) {
      try {
        console.log('=== INICIANDO ACTUALIZACIÓN DE GRÁFICA DE VENTAS ===');
        
        // Si se proporcionan datos directamente, úsalos y omite la llamada al backend
        if (Array.isArray(datos) && datos.length) {
          console.log('Usando datos proporcionados para la gráfica');
          return await procesarDatosGraficaEstadisticas(datos);
        }
        
        // Obtener el nombre del agente del localStorage o del DOM
        const userData = JSON.parse(localStorage.getItem('user') || sessionStorage.getItem('user') || '{}');
        const nombreAgente = userData.name || 'Usuario';
        
        // Construir la URL del endpoint de leads con filtro por agente
        let url = '/api/leads';
        try {
          const userStr = localStorage.getItem('user') || sessionStorage.getItem('user') || '{}';
          const user = JSON.parse(userStr);
          const roleLower = ((user && user.role) || '').toString().toLowerCase();
          const agenteNombreQuery = (user && (user.username || user.name)) || nombreAgente || '';
          const u = new URL(url, location.origin);
          const params = new URLSearchParams(u.search);
          // Solo los agentes se filtran por su propio nombre; roles privilegiados ven todo
          if (roleLower === 'agent' && agenteNombreQuery) {
            params.set('agente', agenteNombreQuery);
            console.info('[Filtro agente] (rol agent) Enviado en query a /api/leads:', agenteNombreQuery);
          } else {
            console.info('[Filtro agente] Rol no-agent detectado (', roleLower, '): no se envía parámetro agente');
          }
          const qs = params.toString();
          url = qs ? `${u.pathname}?${qs}` : `${u.pathname}`;
        } catch (e) {
          console.warn('No se pudo construir la URL con filtro por agente:', e?.message);
        }
        console.log('Solicitando datos a:', url);
        
        // Realizar la petición a la API
        const tokenForGet = localStorage.getItem('token') || sessionStorage.getItem('token');
        const baseHeaders = {
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        };
        if (tokenForGet) baseHeaders['Authorization'] = `Bearer ${tokenForGet}`;
        
        const response = await fetch(url, {
          method: 'GET',
          headers: baseHeaders,
          credentials: 'same-origin'
        });
        
        // Verificar si la respuesta es exitosa; si no, usar datos de prueba
        if (!response.ok) {
          let bodyText = '';
          try { bodyText = await response.text(); } catch (_) {}
          console.warn(`Respuesta no OK (${response.status}). Cuerpo:`, bodyText);
          return await procesarDatosGraficaEstadisticas(datosPrueba);
        }
        
        // Obtener los datos de la respuesta
        const responseData = await response.json();
        console.log('Datos recibidos de la API:', responseData);
        
        // Extraer el array de clientes de la respuesta de forma robusta
        const safeData = responseData || {};
        let costumers = [];
        if (Array.isArray(safeData)) {
          costumers = safeData;
        } else if (Array.isArray(safeData.data)) {
          costumers = safeData.data;
        } else if (Array.isArray(safeData.leads)) {
          costumers = safeData.leads;
        } else if (Array.isArray(safeData.customers)) {
          costumers = safeData.customers;
        }

        console.log(`Datos extraídos: ${costumers.length} registros`);

        // Si no hay datos, usar datos de prueba
        if (!Array.isArray(costumers) || costumers.length === 0) {
          console.warn('No se encontraron datos en la respuesta. Usando datos de prueba.');
          return await procesarDatosGraficaEstadisticas(datosPrueba);
        }

        // Procesar datos para agrupar por día
        const BUSINESS_TZ_OFFSET_MIN = -6 * 60; // UTC-6 fijo
        const toISOInTZ_local = (date, tzOffsetMinutes) => {
          const target = new Date(date.getTime() + tzOffsetMinutes * 60000);
          const y = target.getUTCFullYear();
          const m = String(target.getUTCMonth() + 1).padStart(2, '0');
          const d = String(target.getUTCDate()).padStart(2, '0');
          return `${y}-${m}-${d}`;
        };

        // Inicializar los últimos 7 días
        const ventasPorDia = {};
        const fechasUltimos7Dias = new Set();
        const hoyISO = toISOInTZ_local(new Date(), BUSINESS_TZ_OFFSET_MIN);
        const [hy, hm, hd] = hoyISO.split('-').map(Number);
        const baseUTCNoon = new Date(Date.UTC(hy, hm - 1, hd, 12, 0, 0));
        
        for (let i = 6; i >= 0; i--) {
          const fechaUTC = new Date(baseUTCNoon);
          fechaUTC.setUTCDate(baseUTCNoon.getUTCDate() - i);
          const clave = toISOInTZ_local(fechaUTC, BUSINESS_TZ_OFFSET_MIN);
          fechasUltimos7Dias.add(clave);
          ventasPorDia[clave] = { ventas: 0, puntaje: 0 };
        }

        // Helpers para obtener fechas de los registros
        const getByPath = (obj, path) => {
          try {
            return path.split('.').reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : undefined), obj);
          } catch (_) {
            return undefined;
          }
        };

        const findFirst = (obj, paths) => {
          for (const p of paths) {
            const v = getByPath(obj, p);
            if (v !== undefined && v !== null && v !== '') return v;
          }
          return undefined;
        };

        const tryDateFrom = (val) => {
          if (!val) return null;
          if (typeof val === 'string') {
            const s = val.trim();
            if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
              const [y,m,d] = s.split('-').map(Number);
              return new Date(Date.UTC(y, m-1, d, 12, 0, 0));
            }
            if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) {
              const parts = s.split(/[\/\-]/).map(Number);
              const [d,m,y] = parts;
              if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 1900) {
                return new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
              }
            }
          }
          if (typeof val === 'number') return new Date(val < 1e12 ? val*1000 : val);
          const dt = new Date(val); return isNaN(dt) ? null : dt;
        };

        // Procesar los datos de los clientes
        if (Array.isArray(costumers) && costumers.length > 0) {
          costumers.forEach(costumer => {
            // Elegir día de negocio priorizando dia_venta; si no, usar fechas de creación
            const createdPaths = [
              'creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha',
              '_raw.creadoEn','_raw.fecha_creacion','_raw.fechaCreacion','_raw.createdAt','_raw.created_at','_raw.fecha',
              'metadata.createdAt','audit.createdAt','timestamps.createdAt'
            ];
            const diaVentaPaths = ['dia_venta','diaVenta'];

            let fecha = null;
            const diaVentaVal = findFirst(costumer, diaVentaPaths);
            fecha = tryDateFrom(typeof diaVentaVal === 'string' ? diaVentaVal.trim() : diaVentaVal);
            
            if (!fecha) {
              const fechaCreacionVal = findFirst(costumer, createdPaths);
              fecha = tryDateFrom(fechaCreacionVal);
            }

            let fechaStr = '';
            if (fecha && !isNaN(fecha.getTime())) {
              fechaStr = toISOInTZ_local(fecha, BUSINESS_TZ_OFFSET_MIN);
            } else {
              fechaStr = toISOInTZ_local(new Date(), BUSINESS_TZ_OFFSET_MIN);
            }
            
            // Contar solo si la fecha pertenece a los últimos 7 días inicializados
            if (!fechasUltimos7Dias.has(fechaStr)) {
              return;
            }
            
            // Obtener el puntaje
            let puntaje = 0;
            if (typeof costumer.puntaje === 'number') {
              puntaje = costumer.puntaje;
            } else if (typeof costumer.puntaje === 'string') {
              puntaje = parseFloat(costumer.puntaje) || 0;
            } else if (costumer.score) {
              puntaje = parseFloat(costumer.score) || 0;
            }
            
            // Contar la venta y sumar el puntaje
            ventasPorDia[fechaStr].ventas += 1;
            ventasPorDia[fechaStr].puntaje += puntaje;
          });
        }
        
        // Convertir el objeto a un array y ordenar por fecha
        const datosFinales = Object.entries(ventasPorDia)
          .map(([fecha, datos]) => ({
            fecha,
            ventas: datos.ventas,
            puntaje: datos.puntaje
          }))
          .sort((a, b) => new Date(a.fecha) - new Date(b.fecha));
        
        console.log('Datos procesados para la gráfica:', datosFinales);
        
        // Procesar los datos y actualizar la gráfica
        try {
          const resultado = await procesarDatosGraficaEstadisticas(datosFinales);
          console.log('Gráfica de ventas y puntaje actualizada correctamente');
          return resultado;
        } catch (error) {
          console.error('Error al procesar datos para la gráfica:', error);
          mostrarMensajeError('Error al procesar los datos de la gráfica');
          return false;
        }
        
      } catch (error) {
        console.error('Error al actualizar la gráfica de ventas y puntaje:', error);
        // Fallback: mostrar gráfica con datos de prueba
        try {
          return await procesarDatosGraficaEstadisticas(datosPrueba);
        } catch (e) {
          mostrarMensajeError('Error al actualizar la gráfica de ventas');
          return false;
        }
      }
    }

    // Función para inicializar la nueva gráfica
    function initVentasPuntajeChart() {
      console.log('Inicializando gráfica de ventas y puntaje...');
      
      try {
        ventasPuntajeChart = inicializarGraficaVentasPuntaje();
        if (ventasPuntajeChart) {
          // Cargar datos reales de la API
          actualizarGraficaVentasPuntaje().catch(() => {
            // Fallback a datos de prueba si falla la API
            procesarDatosGraficaEstadisticas(datosPrueba);
          });
          console.log('Gráfica de ventas y puntaje inicializada correctamente');
          
          // Configurar filtros de fecha
          setupDateFilters();
        }
      } catch (error) {
        console.error('Error al inicializar la gráfica de ventas y puntaje:', error);
      }
    }

    // Función para configurar los filtros de fecha
    function setupDateFilters() {
      // Llenar el select de días
      const daySelect = document.getElementById('day-select');
      const monthSelect = document.getElementById('month-select');
      const yearSelect = document.getElementById('year-select');
      
      if (!daySelect || !monthSelect || !yearSelect) return;

      // Función para llenar los días según el mes y año seleccionado
      function fillDays() {
        const month = parseInt(monthSelect.value);
        const year = parseInt(yearSelect.value);
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        daySelect.innerHTML = '';
        for (let i = 1; i <= daysInMonth; i++) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = i;
          daySelect.appendChild(option);
        }
      }

      // Configurar fecha actual
      const today = new Date();
      monthSelect.value = today.getMonth();
      yearSelect.value = today.getFullYear();
      fillDays();
      daySelect.value = today.getDate();

      // Event listeners para actualizar días cuando cambie mes o año
      monthSelect.addEventListener('change', fillDays);
      yearSelect.addEventListener('change', fillDays);

      // Event listener para aplicar filtro
      const applyFilterBtn = document.getElementById('apply-filter');
      if (applyFilterBtn) {
        applyFilterBtn.addEventListener('click', () => {
          console.log('Aplicando filtro de fecha...');
          // Actualizar gráfica con datos reales de la API
          actualizarGraficaVentasPuntaje().catch(() => {
            console.warn('Error al cargar datos de la API, usando datos de prueba');
            procesarDatosGraficaEstadisticas(datosPrueba);
          });
          mostrarNotificacion('Filtro aplicado correctamente');
        });
      }

      // Event listener para resetear a hoy
      const resetFilterBtn = document.getElementById('reset-filter');
      if (resetFilterBtn) {
        resetFilterBtn.addEventListener('click', () => {
          const today = new Date();
          monthSelect.value = today.getMonth();
          yearSelect.value = today.getFullYear();
          fillDays();
          daySelect.value = today.getDate();
          
          console.log('Reseteando filtro a fecha actual...');
          // Actualizar gráfica con datos reales de la API
          actualizarGraficaVentasPuntaje().catch(() => {
            console.warn('Error al cargar datos de la API, usando datos de prueba');
            procesarDatosGraficaEstadisticas(datosPrueba);
          });
          mostrarNotificacion('Filtro reseteado a fecha actual');
        });
      }
    }

    // Función simplificada para procesar datos en Estadísticas
    function procesarDatosGraficaEstadisticas(datos) {
      try {
        if (!Array.isArray(datos) || datos.length === 0) {
          console.warn('No hay datos disponibles para mostrar en la gráfica');
          return false;
        }

        // Generar etiquetas y datasets para los últimos 7 días
        const labels = [];
        const ventasData = [];
        const puntajesData = [];
        
        // Procesar datos ordenados por fecha
        const datosOrdenados = [...datos].sort((a, b) => new Date(a.fecha) - new Date(b.fecha));
        
        datosOrdenados.forEach(item => {
          // Parsear 'YYYY-MM-DD' como fecha LOCAL para evitar desfase de un día
          let y, m, d;
          if (typeof item.fecha === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(item.fecha)) {
            [y, m, d] = item.fecha.split('-').map(Number);
          } else {
            const tmp = new Date(item.fecha);
            y = tmp.getFullYear(); m = tmp.getMonth() + 1; d = tmp.getDate();
          }
          const fecha = new Date(y, (m || 1) - 1, d || 1, 12, 0, 0); // medio día local
          const dia = fecha.getDate();
          const diasSemana = ['dom', 'lun', 'mar', 'mié', 'jue', 'vie', 'sáb'];
          const diaSemana = diasSemana[fecha.getDay()];
          const etiqueta = `${diaSemana} ${dia}`;
          
          labels.push(etiqueta);
          ventasData.push(Number(item.ventas) || 0);
          puntajesData.push(Number(item.puntaje) || 0);
        });

        // Calcular máximos para escalar ejes
        const maxVentas = Math.max(...ventasData);
        const maxPuntaje = Math.max(...puntajesData);
        const maxBoth = Math.max(maxVentas, maxPuntaje);

        // Configuración de la gráfica
        const config = {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Ventas',
                data: ventasData,
                backgroundColor: 'rgba(54, 162, 235, 0.7)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                borderRadius: 4,
                yAxisID: 'y',
                categoryPercentage: 0.6,
                barPercentage: 0.9,
                datalabels: {
                  anchor: 'end',
                  align: 'end',
                  offset: 4,
                  color: '#2c3e50',
                  font: { weight: 'bold' },
                  formatter: (v) => (v != null && !isNaN(v) && Number(v) !== 0 ? Math.round(v) : '')
                }
              },
              {
                label: 'Puntaje',
                data: puntajesData,
                type: 'bar',
                backgroundColor: 'rgba(255, 99, 132, 0.7)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                borderRadius: 4,
                yAxisID: 'y1',
                categoryPercentage: 0.6,
                barPercentage: 0.9,
                datalabels: {
                  anchor: 'end',
                  align: 'end',
                  offset: 4,
                  color: '#7f1d1d',
                  font: { weight: 'bold' },
                  formatter: (v) => {
                    if (v == null || isNaN(v) || Number(v) === 0) return '';
                    const n = Number(v);
                    return n.toFixed(2).replace(/\.00$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
                  }
                }
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { bottom: 40 } },
            scales: {
              x: {
                display: true,
                grid: { display: false },
                ticks: {
                  display: true,
                  color: '#4a4a4a',
                  autoSkip: false,
                  maxRotation: 0,
                  minRotation: 0,
                  padding: 8,
                  font: { size: 12 }
                },
                title: { display: true, text: 'Días' }
              },
              y: {
                type: 'linear',
                display: true,
                position: 'left',
                title: { display: false, text: 'N° de Ventas' },
                beginAtZero: true,
                grid: { display: false },
                border: { display: false },
                ticks: { display: false },
                max: Math.max(5, Math.ceil(maxBoth * 1.2))
              },
              y1: {
                type: 'linear',
                display: true,
                position: 'right',
                grid: { display: false, drawOnChartArea: false },
                border: { display: false },
                title: { display: false, text: 'Puntaje' },
                beginAtZero: true,
                min: 0,
                max: Math.max(5, Math.ceil(maxBoth * 1.2)),
                ticks: { display: false }
              }
            },
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) { label += ': '; }
                    if (context.parsed.y !== null) { label += context.parsed.y; }
                    return label;
                  }
                }
              },
              legend: {
                position: 'top',
                labels: { usePointStyle: true, pointStyle: 'circle', padding: 20 }
              },
              datalabels: {
                display: true,
                // allow labels to render outside the bar area (above)
                clamp: false,
                clip: false
              }
            }
          }
        };

        // Reconstruir la gráfica
        const canvasEl = document.getElementById('ventasPuntajeChart');
        if (!canvasEl) throw new Error('Canvas ventasPuntajeChart no encontrado');
        const ctx = canvasEl.getContext('2d');
        if (ventasPuntajeChart) {
          try { ventasPuntajeChart.destroy(); } catch (_) {}
          ventasPuntajeChart = null;
        }
        ventasPuntajeChart = new Chart(ctx, config);
        
        console.log('Gráfica de ventas y puntaje actualizada correctamente');
        return true;
      } catch (error) {
        console.error('Error al procesar datos de la gráfica:', error);
        mostrarMensajeError('Error al procesar los datos de la gráfica');
        return false;
      }
    }

    // Esperar a que todo el DOM y recursos estÃ©n cargados
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initializeApp();
        initConversionTable();
        // Inicializar la nueva gráfica
        setTimeout(() => {
          initVentasPuntajeChart();
        }, 500);
      });
    } else {
      initializeApp();
      initConversionTable();
      // Inicializar la nueva gráfica
      setTimeout(() => {
        initVentasPuntajeChart();
      }, 500);
    }
  </script>
  <script>
    // Delegate clicks for "Ver detalle" buttons (robust against re-renders)
    (function attachDetailDelegation(){
      try {
        document.addEventListener('click', function(ev){
          try {
            const t = ev.target;
            if (!t) return;
            if (t.id === 'btn-detalle-dia' || (t.dataset && t.dataset.detail === 'day')) {
              ev.preventDefault();
              console.log('[DELEGATE] btn-detalle-dia click');
              try { if (typeof showDayDetailModal === 'function') showDayDetailModal(); else console.warn('showDayDetailModal not defined'); } catch(err){ console.warn('delegated showDayDetailModal error', err); }
              return;
            }
            if (t.id === 'btn-detalle-mensual' || (t.dataset && t.dataset.detail === 'month')) {
              ev.preventDefault();
              console.log('[DELEGATE] btn-detalle-mensual click');
              try { if (typeof showMonthDetailModal === 'function') showMonthDetailModal(); else console.warn('showMonthDetailModal not defined'); } catch(err){ console.warn('delegated showMonthDetailModal error', err); }
              return;
            }
          } catch(_){}
        }, true);
      } catch(e){ console.warn('attachDetailDelegation error', e); }
    })();
    // Utility: ensure canvas is rendered crisply on high-DPI (retina) displays
    window.__ensureHiDPICanvas = function(canvas, minH){
      try {
        if (!canvas) return;
        const dpr = window.devicePixelRatio || 1;
        // get css size
        const rect = canvas.getBoundingClientRect();
        const cssW = rect && rect.width ? rect.width : (canvas.clientWidth || 300);
        const cssH = rect && rect.height ? rect.height : (minH || Math.max(220, Math.round(cssW * 0.33)));
        // set actual pixel size
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        const ctx = canvas.getContext('2d');
        if (ctx && typeof ctx.setTransform === 'function') ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      } catch (e) { /* silent */ }
    };

    // Central helper: animate a 3D flip of the monthly card and create/destroy the monthly chart
    window.__toggleMonthlyFlip = function(){
      try {
        const root = document.getElementById('conversion-table');
        if (!root) return;
        const card = root.querySelector('.conversion-card');
        if (!card) return;

        // Inject flip CSS once
        if (!document.getElementById('month-flip-styles')){
          const css = `
            /* Monthly flip styles (adjusted) */
            #month-flip-local { perspective: 1200px; width:100%; display:block; position:relative; }
            #month-flip-local .flip-scene { position:relative; width:100%; transform-style:preserve-3d; transition: transform 360ms cubic-bezier(.2,.8,.2,1); will-change: transform; }
            /* Faces - front is normal flow, back is absolute full-cover */
            #month-flip-local .flip-face { backface-visibility: hidden; -webkit-backface-visibility:hidden; transition: opacity 260ms ease-in-out; overflow: hidden; }
            #month-flip-local .flip-face.front { position:relative; width:100%; z-index:2; }
            #month-flip-local .flip-face.back { position:absolute !important; top:0; left:0; right:0; bottom:0; transform: rotateY(180deg); display:flex; align-items:stretch; opacity:0; z-index:1; }
            /* When flipped, ensure back is on top and front doesn't receive events */
            #month-flip-local.is-flipped .flip-scene { transform: rotateY(180deg); }
            /* back hidden by default, made visible when flipped. keep faces in flow to allow 3D transform animation */
            #month-flip-local .flip-face.back { opacity: 0; visibility: hidden; }
            #month-flip-local.is-flipped .flip-face.back { opacity:1; visibility: visible; z-index:9999; pointer-events: auto; }
        /* Keep the front face occupying layout while fading it out during the 3D rotate.
          We'll only set visibility:hidden after the transition ends via JS to avoid layout jumps. */
        #month-flip-local.is-flipped .flip-face.front { opacity:0; pointer-events: none; visibility: visible; }
        /* Helper classes for JS toggles */
        #month-flip-local .flip-face.front.flip-front-hidden { visibility: hidden !important; pointer-events: none !important; }
        .force-visible { visibility: visible !important; }
            #month-flip-local .chart-wrapper{ width:100%; height:100%; box-sizing:border-box; padding:6px; min-height:320px; }
            /* Ensure canvas fills the back face */
            #month-flip-local canvas { width:100% !important; height:100% !important; display:block; }
          `;
          const s = document.createElement('style'); s.id = 'month-flip-styles'; s.textContent = css; document.head.appendChild(s);
        }

        // Ensure flip viewport and faces exist (reuse if present)
        let vp = card.querySelector('#month-flip-local');
        let frontFace, backFace, scene;
        if (!vp){
          const twoCol = card.querySelector('.conv-two-col');
          if (!twoCol) return;

          // Create structure: vp > scene > front + back
          vp = document.createElement('div'); vp.id = 'month-flip-local'; vp.className = 'month-flip-viewport';
          scene = document.createElement('div'); scene.className = 'flip-scene';
          frontFace = document.createElement('div'); frontFace.className = 'flip-face front';
          backFace = document.createElement('div'); backFace.className = 'flip-face back';

          // Move existing twoCol into frontFace
          frontFace.appendChild(twoCol);

          // Build back face with canvas (reuse existing canvas if any)
          const backWrap = document.createElement('div'); backWrap.className = 'chart-wrapper';
          let canvas = document.getElementById('monthly-team-chart');
          if (!canvas) {
            canvas = document.createElement('canvas'); canvas.id = 'monthly-team-chart';
          } else {
            // if canvas existed elsewhere, remove it from previous parent to avoid duplicates
            try { canvas.parentElement &&   canvas.parentElement.removeChild(canvas); } catch(_){}
          }
          backWrap.appendChild(canvas);
          backFace.appendChild(backWrap);

          scene.appendChild(frontFace);
          scene.appendChild(backFace);
          vp.appendChild(scene);

          // Immediately fix the viewport height to the front face size to avoid layout jumps
          try {
            const initialH = (frontFace && frontFace.getBoundingClientRect && frontFace.getBoundingClientRect().height) || frontFace.offsetHeight || 220;
            vp.style.height = initialH + 'px';
            vp.style.minHeight = initialH + 'px';
            vp.style.overflow = 'hidden';
            // also keep scene min-height so faces don't push
            scene.style.minHeight = initialH + 'px';
          } catch(_) {}

          // Replace the original twoCol in the card with the flip viewport
          // twoCol was moved into frontFace, so find its former container and replace child
          const holder = card.querySelector('.conv-two-col')?.parentElement || card;
          // Try to find the element that previously contained twoCol (we moved it), so replace the empty spot
          // As a safe fallback, append vp to card
          try {
            // If holder still has a reference to the old twoCol (now absent), replace the placeholder
            const possible = Array.from(holder.children).find(ch => ch.classList && ch.classList.contains('conv-two-col'));
            if (possible) holder.replaceChild(vp, possible);
            else card.appendChild(vp);
          } catch(_) { card.appendChild(vp); }
        } else {
          scene = vp.querySelector('.flip-scene');
          frontFace = vp.querySelector('.flip-face.front');
          backFace = vp.querySelector('.flip-face.back');
        }

  // Prevent rapid toggles while animating
  if (window.__monthlyFlipAnimating) return;
  // maintain container height to avoid layout jumps (use bounding rect for more accurate value)
  try {
    const frontEl = frontFace || vp.querySelector('.flip-face.front');
    if (frontEl) {
      const h = (frontEl.getBoundingClientRect && frontEl.getBoundingClientRect().height) || frontEl.offsetHeight || 220;
      vp.style.height = h + 'px';
      vp.style.minHeight = h + 'px';
      vp.style.overflow = 'hidden';
      // also set scene min-height to stabilize 3D transform
      const sc = vp.querySelector('.flip-scene'); if (sc) sc.style.minHeight = h + 'px';
    }
  } catch(_){ }
  const willShowBack = !vp.classList.contains('is-flipped');
  window.__monthlyFlipAnimating = true;

        // Helper to build chart after flip completes
            const buildChart = () => {
          try {
            if (typeof Chart === 'undefined') return;
            const rows = Array.isArray(window.MonthDisplayRows) && window.MonthDisplayRows.length ? window.MonthDisplayRows : (Array.isArray(window.__monthlyTeamData) ? window.__monthlyTeamData : []);
            // build multiline labels (Chart.js supports array-of-strings per label for multiline)
            // Get name from row data
            const labels = rows.map(r => String(r.name || ''));
            try{ console.log('DEBUG: buildChart MONTH start', {labels, rowsLength: rows.length}); } catch(_){}
            const ventas = rows.map(r => Number(r.Total || 0));
            const puntos = rows.map(r => Number(r.Puntaje || 0));
            const canvas = document.getElementById('monthly-team-chart');
            if (!canvas) return;
            // Ensure canvas parent has explicit height so Chart can size properly
            const wrap = canvas.parentElement;
            try {
              const vpH = (vp && vp.getBoundingClientRect && vp.getBoundingClientRect().height) || vp.clientHeight || 320;
              const minH = 320; // ensure chart has a minimum visual height so bars aren't tiny
              const finalH = Math.max(vpH, minH);
              if (wrap) {
                wrap.style.height = finalH + 'px';
                wrap.style.maxHeight = finalH + 'px';
                wrap.style.overflow = 'hidden';
                // add bottom padding so x-axis labels and datalabels have room
                wrap.style.paddingBottom = '28px';
              }
            } catch(_){ }
              try { if (window.__monthlyChart) { window.__monthlyChart.destroy(); } } catch(_){ }
              try { if (typeof window.__ensureHiDPICanvas === 'function') window.__ensureHiDPICanvas(canvas, finalH); } catch(_){}
              const ctx = canvas.getContext('2d');
            window.__monthlyChart = new Chart(ctx, {
              type: 'bar',
              data: { labels, datasets: [
                  { label: 'Ventas', data: ventas, backgroundColor: 'rgba(37,99,235,0.85)' },
                  { label: 'Puntaje', data: puntos, backgroundColor: 'rgba(239,68,68,0.85)' }
              ] },
                options: {
                responsive: true,
                maintainAspectRatio: false,
                // give extra bottom padding so x-axis labels and datalabels have room
                layout: { padding: { top: 12, bottom: 60 } },
                plugins: {
                  legend: { display: true, position: 'top' },
                      datalabels: {
                        // place labels above the bar (outside the bar area)
                        anchor: 'end',
                        align: 'end',
                        offset: -6,
                        clamp: false,
                        clip: false,
                        color: '#0b1220',
                        font: { weight: '600', size: 11 },
                        formatter: v => (v == null ? '' : v)
                      }
                },
                scales: {
                  x: {
                    grid: { display: false },
                    ticks: {
                      display: true,
                      color: '#1e293b',
                      autoSkip: false,
                      maxRotation: 0,
                      minRotation: 0,
                      padding: 12,
                      font: { 
                        size: 12,
                        weight: '500'
                      },
                      textStrokeWidth: 0.5
                    }
                  },
                  y: { beginAtZero: true, grid: { display: false }, ticks: { display: false } }
                }
              },
              plugins: (Chart && Chart.registry && Chart.registry.getPlugin) ? [] : []
            });
          } catch (e) { console.warn('monthly chart build error', e); }
        };

        // Handler for end of transition
        const onTransit = (ev) => {
          if (ev && ev.propertyName && ev.propertyName.indexOf('transform') === -1) return;
          try {
            if (willShowBack) {
              // Now the back face is visible: build the chart
              buildChart();
              // hide the front face from rendering/assistive UI after the back is visible
              try { if (frontFace) { frontFace.classList.add('flip-front-hidden'); } } catch(_){ }
            } else {
              // We're back to front: make sure front face is visible again and destroy chart to free memory
              try { if (frontFace) { frontFace.classList.remove('flip-front-hidden'); frontFace.classList.add('force-visible'); } } catch(_){ }
              try { if (window.__monthlyChart) { window.__monthlyChart.destroy(); window.__monthlyChart = null; } } catch(_){ }
              // Aggressive cleanup: clear inline hidden/display/opacity styles inside the front face
              try {
                if (frontFace && frontFace.querySelectorAll) {
                  Array.from(frontFace.querySelectorAll('*')).forEach(el => {
                    try {
                      if (!el || !el.style) return;
                      if (el.style.visibility && el.style.visibility.indexOf('hidden') !== -1) el.style.visibility = '';
                      if (el.style.display && el.style.display.indexOf('none') !== -1) el.style.display = '';
                      if (el.style.opacity === '0') el.style.opacity = '';
                      if (el.style.pointerEvents === 'none') el.style.pointerEvents = '';
                      if (el.style.transform && el.style.transform.indexOf('rotateY') !== -1) el.style.transform = '';
                    } catch(_){ }
                  });
                }
              } catch(_){ }
              // Also run a delayed, forceful cleanup to counter racey mutations from Chart.js
              try {
                setTimeout(() => {
                  try {
                    if (frontFace) {
                      try { frontFace.classList.remove('flip-front-hidden'); frontFace.classList.remove('force-visible'); } catch(_){}
                      try { frontFace.classList.remove('force-visible'); } catch(_){}
                    }
                    try { if (typeof window.__clearDayHiddenStyles === 'function') window.__clearDayHiddenStyles(); } catch(_){}
                  } catch(_){}
                }, 240);
              } catch(_){}
            }

            // restore any hidden sticky elements
            try {
              const hidden = vp && vp.__hiddenSticky;
              if (hidden && Array.isArray(hidden)) {
                hidden.forEach(item => { try{ item.el.style.visibility = item.vis || ''; } catch(_){} });
                vp.__hiddenSticky = null;
              }
            } catch(_){ }

            // restore table display (in case)
            try { const tbl = vp.querySelector('table'); if (tbl) tbl.style.display = ''; } catch(_){ }
          } finally {
            try {
              // if we flipped back to front, remove any inline sizing after a short delay so layout can resume
              if (!willShowBack) {
                const wrapEl = vp && vp.querySelector && vp.querySelector('.chart-wrapper');
                if (wrapEl) { wrapEl.style.height = ''; wrapEl.style.maxHeight = ''; wrapEl.style.overflow = ''; }
                setTimeout(() => { try { vp.style.height = ''; vp.style.minHeight = ''; if (scene) scene.style.minHeight = ''; } catch(_){} }, 200);
              }
            } catch(_){ }
            // cleanup
            if (scene) scene.removeEventListener('transitionend', onTransit);
            window.__monthlyFlipAnimating = false;
          }
        };

        // Attach transitionend and toggle class to start animation
        if (scene) {
          scene.addEventListener('transitionend', onTransit);
        }
        // Before starting the flip, hide any sticky elements inside the front face so they don't overlap during the 3D rotate
        try {
          if (willShowBack && frontFace) {
            const hidden = [];
            Array.from(frontFace.querySelectorAll('*')).forEach(el => {
              try {
                const cs = window.getComputedStyle(el);
                if (cs && (cs.position === 'sticky' || cs.position === 'fixed')) {
                  hidden.push({el, vis: el.style.visibility});
                  el.style.visibility = 'hidden';
                }
              } catch(_) {}
            });
            // store to restore later
            vp.__hiddenSticky = hidden;
          }
        } catch(_) {}
  // Force reflow then toggle. Ensure frontFace remains occupying layout during the animation.
  try { if (frontFace) frontFace.style.visibility = 'visible'; } catch(_){}
  try { if (scene) { scene.style.height = vp.style.height || (vp.getBoundingClientRect && vp.getBoundingClientRect().height + 'px'); scene.style.boxSizing = 'border-box'; } } catch(_){}
  void vp.offsetHeight;
  if (willShowBack) vp.classList.add('is-flipped'); else vp.classList.remove('is-flipped');

        // Safety: if transitionend doesn't fire (old browsers), fallback after timeout
        setTimeout(() => {
          if (window.__monthlyFlipAnimating) {
            try { onTransit(); } catch(_) { window.__monthlyFlipAnimating = false; }
          }
  }, 500);

      } catch (e) { console.warn('toggleMonthlyFlip error', e); }
    };

    // Fallback global: asegurar flip local y gráfica al pulsar ↻ aunque el HTML varié
    (function(){
      function ensureFlipAndToggle(){
        try{
          if (typeof window.__toggleMonthlyFlip === 'function') {
            window.__toggleMonthlyFlip();
          }
        }catch(e){ console.warn('ensureFlipAndToggle error', e); }
      }
      document.addEventListener('click', function(ev){
        const t = ev.target;
        if (t && t.id === 'btn-flip-monthly'){
          ev.preventDefault();
          ensureFlipAndToggle();
        }
      }, true);
    })();
    
    // Inject helper and fallback for DAY flip (same behavior as monthly)
    (function(){
      // Inject a small toolbar flip button into the day card when it appears
      window.injectDayFlipButton = function(attempt = 0){
        const root = document.getElementById('ventas-dia-card');
        const card = root ? root.querySelector('.conversion-card') : null;
        if (!card) {
          if (attempt < 20) return setTimeout(() => window.injectDayFlipButton(attempt + 1), 300);
          return;
        }
        if (card.querySelector('#btn-flip-day')) return;
        // Find the area where buttons are placed (a small container with Ver detalle)
        const toolbarWrap = card.querySelector('div[style*="justify-content:flex-end"]') || card;
        const btnFlip = document.createElement('button');
        btnFlip.id = 'btn-flip-day';
        btnFlip.className = 'filter-button';
        btnFlip.title = 'Ver gráfica';
        btnFlip.textContent = '↻';
        btnFlip.style.cssText = 'height:28px;width:32px;font-weight:700;margin-left:8px;';
        // Append next to existing detalle button if present
        const detalle = card.querySelector('#btn-detalle-dia');
        if (detalle && detalle.parentElement) detalle.parentElement.appendChild(btnFlip);
        else toolbarWrap.appendChild(btnFlip);
      };

      // Core toggle for day card
      window.__toggleDayFlip = function(){
        try {
          const root = document.getElementById('ventas-dia-card');
          if (!root) return;
          const card = root.querySelector('.conversion-card');
          if (!card) return;

          // Reuse monthly styles if available, otherwise inject day-specific styles
          if (!document.getElementById('day-flip-styles') && document.getElementById('month-flip-styles')){
            // reuse month styles, add a marker
            const s = document.createElement('style'); s.id = 'day-flip-styles'; s.textContent = ''; document.head.appendChild(s);
          } else if (!document.getElementById('day-flip-styles')){
              const css = `
                  /* Day flip styles (adjusted to match monthly) */
                  #day-flip-local { perspective: 1200px; width:100%; display:block; }
                    #day-flip-local .flip-scene { position:relative; width:100%; transform-style:preserve-3d; transition: transform 360ms cubic-bezier(.2,.8,.2,1); will-change: transform; }
                  /* Faces */
                  #day-flip-local .flip-face { backface-visibility: hidden; -webkit-backface-visibility:hidden; position:relative; width:100%; transition: opacity 260ms ease-in-out; overflow:hidden; }
                  #day-flip-local .flip-face.front { z-index:2; }
                  #day-flip-local .flip-face.back { position:absolute; inset:0; transform: rotateY(180deg); display:flex; align-items:stretch; opacity:0; z-index:1; }
                  /* When flipped, ensure back is on top and front doesn't receive events */
                  #day-flip-local.is-flipped .flip-scene { transform: rotateY(180deg); }
                  /* back hidden by default, made visible when flipped. keep faces in flow to allow 3D transform animation */
                  #day-flip-local .flip-face.back { opacity: 0; visibility: hidden; }
                  #day-flip-local.is-flipped .flip-face.back { opacity:1; visibility: visible; z-index:3; pointer-events:auto; }
            /* Keep front face visible (but transparent) during animation to preserve layout.
              Visibility will be toggled in JS when the transition finishes. */
            #day-flip-local.is-flipped .flip-face.front { opacity:0; pointer-events:none; visibility: visible; }
            /* Helper classes for JS toggles */
            #day-flip-local .flip-face.front.flip-front-hidden { visibility: hidden !important; pointer-events: none !important; }
            .force-visible { visibility: visible !important; }
                  #day-flip-local .chart-wrapper{ width:100%; height:100%; box-sizing:border-box; padding:6px; min-height:320px; }
                  #day-flip-local canvas { width:100% !important; height:100% !important; display:block; }
                `;
            const s = document.createElement('style'); s.id = 'day-flip-styles'; s.textContent = css; document.head.appendChild(s);
          }

          // Build the flip viewport if absent
          let vp = card.querySelector('#day-flip-local');
          let scene, frontFace, backFace;
          if (!vp){
            const twoCol = card.querySelector('.conv-two-col');
            if (!twoCol) return;
            vp = document.createElement('div'); vp.id = 'day-flip-local'; vp.className = 'day-flip-viewport';
            scene = document.createElement('div'); scene.className = 'flip-scene';
            frontFace = document.createElement('div'); frontFace.className = 'flip-face front';
            backFace = document.createElement('div'); backFace.className = 'flip-face back';
            frontFace.appendChild(twoCol);
            const backWrap = document.createElement('div'); backWrap.className = 'chart-wrapper';
            let canvas = document.getElementById('daily-team-chart');
            if (!canvas){ canvas = document.createElement('canvas'); canvas.id = 'daily-team-chart'; }
            else { try{ canvas.parentElement && canvas.parentElement.removeChild(canvas); } catch(_){} }
            backWrap.appendChild(canvas); backFace.appendChild(backWrap);
            scene.appendChild(frontFace); scene.appendChild(backFace); vp.appendChild(scene);
            try { const holder = card.querySelector('.conv-two-col')?.parentElement || card; const possible = Array.from(holder.children).find(ch => ch.classList && ch.classList.contains('conv-two-col')); if (possible) holder.replaceChild(vp, possible); else card.appendChild(vp); } catch(_) { card.appendChild(vp); }
          } else { scene = vp.querySelector('.flip-scene'); }

          // Ensure we have a visibility observer installed to auto-recover stray style changes
          try { if (typeof window.__installDayVisibilityObserver === 'function') window.__installDayVisibilityObserver(); } catch(_){}

          if (window.__dayFlipAnimating) return;
          // keep height stable during flip (use bounding rect precision)
          try {
            const frontEl = frontFace || vp.querySelector('.flip-face.front');
            if (frontEl) {
              const h = (frontEl.getBoundingClientRect && frontEl.getBoundingClientRect().height) || frontEl.offsetHeight || 220;
              vp.style.height = h + 'px';
              vp.style.minHeight = h + 'px';
              vp.style.overflow = 'hidden';
              const sc = vp.querySelector('.flip-scene'); if (sc) sc.style.minHeight = h + 'px';
            }
          } catch(_){ }
          const willShowBack = !vp.classList.contains('is-flipped');
          window.__dayFlipAnimating = true;

                  const buildChart = () => {
            try {
              if (typeof Chart === 'undefined') return;
              const rows = Array.isArray(window.DayDisplayRows) && window.DayDisplayRows.length ? window.DayDisplayRows : (Array.isArray(window.dayData) ? window.dayData : []);
              // Get name from row data
              const labels = rows.map(r => String(r.name || ''));
              try{ console.log('DEBUG: buildChart DAY start', {labels, rowsLength: rows.length}); } catch(_){ }
              const ventas = rows.map(r=>Number(r.Total||0));
              const puntos = rows.map(r=>Number(r.Puntaje||0));
              const canvas = document.getElementById('daily-team-chart'); if (!canvas) return;
              const wrap = canvas.parentElement;
              try {
                const vpH = (vp && vp.getBoundingClientRect && vp.getBoundingClientRect().height) || vp.clientHeight || 320;
                const minH = 320;
                const finalH = Math.max(vpH, minH);
                if (wrap) { wrap.style.height = finalH + 'px'; wrap.style.maxHeight = finalH + 'px'; wrap.style.overflow = 'hidden'; wrap.style.paddingBottom = '28px'; }
              } catch(_){ }
                try{ if (window.__dailyChart) { window.__dailyChart.destroy(); } } catch(_){ }
                try { if (typeof window.__ensureHiDPICanvas === 'function') window.__ensureHiDPICanvas(canvas, finalH); } catch(_){}
                const ctx = canvas.getContext('2d');
              window.__dailyChart = new Chart(ctx, {
                type: 'bar',
                data: { labels, datasets: [
                  { label: 'Ventas', data: ventas, backgroundColor: 'rgba(37,99,235,0.85)' },
                  { label: 'Puntaje', data: puntos, backgroundColor: 'rgba(239,68,68,0.85)' }
                ] },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  // give extra bottom padding so x-axis labels and datalabels have room
                  layout: { padding: { top: 12, bottom: 60 } },
                  plugins: {
                    legend: { display: true, position: 'top' },
                    datalabels: {
                      // place labels above the bar (outside the bar area)
                      anchor: 'end',
                      align: 'end',
                      offset: -6,
                      clamp: false,
                      clip: false,
                      color: '#0b1220',
                          font: { weight: '600', size: 12 },
                      formatter: v => (v == null ? '' : v)
                    }
                  },
                  scales: {
                    x: {
                      grid: { display: false },
                      ticks: {
                        display: true,
                        color: '#1e293b',
                        autoSkip: false,
                        maxRotation: 0,
                        minRotation: 0,
                        padding: 12,
                        font: { 
                          size: 13,
                          weight: '500'
                        },
                        textStrokeWidth: 0.5
                      }
                    },
                    y: { beginAtZero: true, grid: { display: false }, ticks: { display: false } }
                  }
                }
              });
            } catch(e){ console.warn('daily chart build error', e); }
          };

          const onTransit = (ev) => {
            if (ev && ev.propertyName && ev.propertyName.indexOf('transform') === -1) return;
            try {
                  // Pause visibility watcher while we perform flip/cleanup to avoid fight conditions
                  try { window.__dayWatcherPaused = true; } catch(_){}
                  try { console.log('[DAY onTransit] willShowBack=', willShowBack, 'property=', ev && ev.propertyName); } catch(_){ }
                  if (willShowBack) {
                    try { console.log('[DAY onTransit] showing back -> buildChart'); } catch(_){ }
                    buildChart();
                    try { if (frontFace) { frontFace.classList.add('flip-front-hidden'); } } catch(_){ }
                  } else {
              try { console.log('[DAY onTransit] showing front -> cleaning and destroying chart'); } catch(_){ }
              try { if (frontFace) { frontFace.classList.remove('flip-front-hidden'); frontFace.classList.add('force-visible');
                  // Destroy chart first to avoid Chart.js or related code re-applying styles while we restore the front face
                  try{ if (window.__dailyChart) { window.__dailyChart.destroy(); window.__dailyChart = null; } } catch(_){ }
                  // After the chart is destroyed, restore visibility on the front face. Use a tiny delay to let any
                  // layout/paint triggered by chart destruction settle before removing the hiding class.
                  try {
                    if (frontFace) {
                      // remove the hidden class after a short tick
                      setTimeout(() => {
                        try { frontFace.classList.remove('flip-front-hidden'); } catch(_){}
                        try { frontFace.classList.add('force-visible'); } catch(_){}
                        try { frontFace.style.setProperty('visibility','visible','important'); frontFace.style.setProperty('opacity','1','important'); } catch(_){ }
                      }, 30);
                    }
                  } catch(_){ }
              } } catch(_){ }
              // Aggressively clear inline styles that could keep the front/table hidden
                    try {
                      if (frontFace && frontFace.querySelectorAll) {
                        Array.from(frontFace.querySelectorAll('*')).forEach(el => {
                          try {
                            if (!el || !el.style) return;
                            if (el.style.visibility && el.style.visibility.indexOf('hidden') !== -1) el.style.visibility = '';
                            if (el.style.display && el.style.display.indexOf('none') !== -1) el.style.display = '';
                            if (el.style.opacity === '0') el.style.opacity = '';
                            if (el.style.pointerEvents === 'none') el.style.pointerEvents = '';
                            if (el.style.transform && el.style.transform.indexOf('rotateY') !== -1) el.style.transform = '';
                          } catch(_){ }
                        });
                      }
                      try { if (typeof window.__clearDayHiddenStyles === 'function') window.__clearDayHiddenStyles(); } catch(_){ }
                      // As an extra last-resort override, set important visibility on any tables in the front face
                      try {
                        const tbls = frontFace && frontFace.querySelectorAll ? Array.from(frontFace.querySelectorAll('table')) : [];
                        tbls.forEach(t => { try { t.style.setProperty('visibility','visible','important'); t.style.setProperty('display','table','important'); t.style.setProperty('opacity','1','important'); } catch(_){} });
                      } catch(_){ }
                    } catch(_){ }
                    }
              // restore any hidden sticky elements
              try {
                const hidden = vp && vp.__hiddenSticky;
                if (hidden && Array.isArray(hidden)) {
                  hidden.forEach(item => { try{ item.el.style.visibility = item.vis || ''; } catch(_){} });
                  vp.__hiddenSticky = null;
                }
              } catch(_){}
            } finally {
              try {
                if (!willShowBack) {
                  const wrapEl = vp && vp.querySelector && vp.querySelector('.chart-wrapper');
                  if (wrapEl) { wrapEl.style.height = ''; wrapEl.style.maxHeight = ''; wrapEl.style.overflow = ''; wrapEl.style.paddingBottom = ''; }
                  setTimeout(() => { try { vp.style.height = ''; vp.style.minHeight = ''; if (scene) { scene.style.minHeight = ''; scene.style.height = ''; } } catch(_){} }, 200);
                }
              } catch(_){}
              if (scene) scene.removeEventListener('transitionend', onTransit);

              // Robust cleanup: retry-check computed styles and clear inline hiding up to a few times.
              (function ensureFrontVisibleRetry(attempt){
                try {
                  if (!frontFace) return;
                  // remove transient force-visible immediately
                  try { frontFace.classList.remove('force-visible'); } catch(_){ }
                  // run global helper to clear suspicious inline styles
                  try { if (typeof window.__clearDayHiddenStyles === 'function') window.__clearDayHiddenStyles(); } catch(_){ }

                  // Check computed style of the front face and any contained tables
                  const cs = window.getComputedStyle(frontFace);
                  try { console.log('[ensureFrontVisibleRetry] attempt=', attempt, 'front computed=', cs ? {visibility: cs.visibility, display: cs.display, opacity: cs.opacity} : null); } catch(_){ }
                  let stillHidden = false;
                  if (cs) {
                    if (cs.visibility === 'hidden' || cs.display === 'none' || Number((cs.opacity || '1')) === 0) stillHidden = true;
                  }
                  if (!stillHidden) {
                    // Also verify tables inside
                    const tbls = frontFace.querySelectorAll ? Array.from(frontFace.querySelectorAll('table')) : [];
                    for (const t of tbls) {
                      try {
                        const cst = window.getComputedStyle(t);
                        if (cst && (cst.visibility === 'hidden' || cst.display === 'none' || Number((cst.opacity||'1')) === 0)) { stillHidden = true; break; }
                      } catch(_){ }
                    }
                  }

                  if (stillHidden) {
                    // collect problematic elements for logging
                    try {
                      const problems = [];
                      const all = frontFace.querySelectorAll ? Array.from(frontFace.querySelectorAll('*')) : [];
                      all.forEach(el => {
                        try {
                          const s = window.getComputedStyle(el);
                          if (s && (s.visibility === 'hidden' || s.display === 'none' || Number((s.opacity||'1')) === 0)) {
                            problems.push({ tag: el.tagName, id: el.id || null, cls: el.className || null, vis: s.visibility, display: s.display, opacity: s.opacity });
                          }
                        } catch(_){}
                      });
                      try { console.log('[ensureFrontVisibleRetry] attempt=', attempt, 'stillHidden=true problems=', problems.slice(0,20)); } catch(_){ }
                    } catch(_){}
                  } else {
                    try { console.log('[ensureFrontVisibleRetry] attempt=', attempt, 'front appears visible'); } catch(_){ }
                  }

                  if (stillHidden && attempt < 3) {
                    // Forcefully clear inline styles on front and tables
                    try {
                      if (frontFace && frontFace.querySelectorAll) {
                        Array.from(frontFace.querySelectorAll('*')).forEach(el => {
                          try {
                            if (!el || !el.style) return;
                            if (el.style.visibility && el.style.visibility.indexOf('hidden') !== -1) el.style.visibility = '';
                            if (el.style.display && el.style.display.indexOf('none') !== -1) el.style.display = '';
                            if (el.style.opacity === '0') el.style.opacity = '';
                            if (el.style.pointerEvents === 'none') el.style.pointerEvents = '';
                            if (el.style.transform && el.style.transform.indexOf('rotateY') !== -1) el.style.transform = '';
                          } catch(_){ }
                        });
                      }
                    } catch(_){ }
                    // schedule another check with exponential backoff
                    setTimeout(() => ensureFrontVisibleRetry(attempt + 1), 80 * Math.pow(2, attempt));
                  }
                } catch(e){ try{ console.warn('ensureFrontVisibleRetry error', e); }catch(_){} }
              })(0);

              // give a little extra time before re-enabling the watcher so any late DOM changes settle
              try { setTimeout(() => { try { window.__dayWatcherPaused = false; } catch(_){} }, 900); } catch(_){ }

              window.__dayFlipAnimating = false;
            }
          };

          if (scene) scene.addEventListener('transitionend', onTransit);
          // Before starting the flip, hide any sticky elements inside the front face so they don't overlap during the 3D rotate
          try {
            if (willShowBack && frontFace) {
              const hidden = [];
              Array.from(frontFace.querySelectorAll('*')).forEach(el => {
                try {
                  const cs = window.getComputedStyle(el);
                  if (cs && (cs.position === 'sticky' || cs.position === 'fixed')) {
                    hidden.push({el, vis: el.style.visibility});
                    el.style.visibility = 'hidden';
                  }
                } catch(_) {}
              });
              // store to restore later
              vp.__hiddenSticky = hidden;
            }
          } catch(_) {}
          try { if (frontFace) frontFace.style.visibility = 'visible'; } catch(_){}
          void vp.offsetHeight;
          if (willShowBack) vp.classList.add('is-flipped'); else vp.classList.remove('is-flipped');
          setTimeout(() => { if (window.__dayFlipAnimating) { try { onTransit(); } catch(_) { window.__dayFlipAnimating = false; } } }, 500);

        } catch(e){ console.warn('toggleDayFlip error', e); }
      };

      // Fallback click listener for day flip
      document.addEventListener('click', function(ev){
        const t = ev.target;
        if (t && t.id === 'btn-flip-day'){
          ev.preventDefault();
          try{ if (typeof window.__toggleDayFlip === 'function') window.__toggleDayFlip(); } catch(e){ console.warn(e); }
        }
      }, true);
    })();
  </script>
</body>
</html>
