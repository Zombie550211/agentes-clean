<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard - EstadÃ­sticas</title>

  <!-- Estilos base y sidebar -->
  <link rel="stylesheet" href="css/theme.css">
  <link rel="stylesheet" href="css/sidebar-shared.css">
  <link rel="stylesheet" href="css/estadisticas.css">
  <script src="/vendor/chartjs/chart.umd.min.js"></script>
  <script src="/vendor/chartjs-plugin/chartjs-plugin-datalabels.min.js"></script>
  <!-- Eliminado kit de Font Awesome (403). Se usa el CSS 5.15.4 ya cargado arriba. -->
  
  <!-- Luego cargar los scripts de la aplicaciÃ³n -->
  <script src="/js/logout-handler.js"></script>
  <script src="/js/user-info.js"></script>
  <script src="/utils/teams.js"></script>
  <script src="js/sidebar-loader.js"></script>
  
  <!-- Script de inicializaciÃ³n de grÃ¡ficos -->
  <script>
    const BUSINESS_TZ_OFFSET_MIN = -6 * 60; // Zona horaria operativa (UTC-6)

    const getBusinessSnapshot = (input) => {
      try {
        const base = input instanceof Date ? input : new Date(input);
        const ms = base?.getTime?.();
        if (Number.isNaN(ms)) return null;
        const shifted = new Date(ms + BUSINESS_TZ_OFFSET_MIN * 60000);
        return {
          year: shifted.getUTCFullYear(),
          month: shifted.getUTCMonth(),
          day: shifted.getUTCDate(),
          hours: shifted.getUTCHours(),
          minutes: shifted.getUTCMinutes(),
          seconds: shifted.getUTCSeconds()
        };
      } catch (_) {
        return null;
      }
    };

    const debugBusinessDate = (label, date) => {
      try {
        const snap = getBusinessSnapshot(date);
        console.log('[ESTADISTICAS][DIA]', label, {
          original: date instanceof Date ? date.toISOString() : date,
          snapshot: snap,
          isoLocal: (date instanceof Date) ? `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}` : date
        });
      } catch (e) {
        console.warn('[ESTADISTICAS][DIA] debugBusinessDate error', label, e);
      }
    };

    const formatMetricValue = (value, decimals = 2) => {
      const num = Number(value);
      if (!Number.isFinite(num)) return '';
      if (Number.isInteger(num)) return String(num);
      const fixed = num.toFixed(decimals);
      return fixed.replace(/(\.\d*?[1-9])0+$/, '$1').replace(/\.0+$/, '');
    };
    // Verificar que Chart.js está disponible
    if (typeof Chart === 'undefined') {
      console.error('Error: No se pudo cargar Chart.js');
    } else {
      try {
        const candidate = window.__chartDataLabelsPlugin
          || (typeof ChartDataLabels !== 'undefined' && (ChartDataLabels.default || ChartDataLabels));
        const plugin = candidate && (candidate.id ? candidate : (candidate.default || candidate));

        if (plugin && typeof Chart.register === 'function') {
          if (window.__chartDataLabelsRegistered !== true) {
            Chart.register(plugin);
            window.__chartDataLabelsPlugin = plugin;
            window.__chartDataLabelsRegistered = true;
          }

          try {
            if (Chart.defaults?.plugins?.datalabels) {
              Chart.defaults.plugins.datalabels.color = '#0f172a';
              Chart.defaults.plugins.datalabels.font = { weight: '600', size: 11 };
            }
          } catch (cfgErr) {
            console.warn('No se pudo configurar el formato global de datalabels:', cfgErr);
          }
        } else if (candidate) {
          console.warn('ChartDataLabels cargado pero no se pudo resolver el plugin (estructura inesperada)');
        } else {
          console.error('ChartDataLabels no disponible');
        }
      } catch (err) {
        console.warn('No se pudo registrar ChartDataLabels globalmente:', err);
      }
    }

    const getMonthKey = (date) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      return `${year}-${month}`;
    };

    window.__monthlyDataCache = window.__monthlyDataCache || new Map();

    const normalizeTeamRow = (row = {}) => ({
      name: String(row.name || row.TEAM || row.team || row.equipo || 'Sin equipo'),
      ICON: Number(row.ICON || 0),
      ACTIVAS: Number(row.ACTIVAS || row.activas || row.activadas || row.ACTIVADAS || 0),
      Total: Number(row.Total || row.total || row.cantidad || 0),
      Puntaje: Number(row.Puntaje || row.puntaje || 0)
    });

    async function fetchMonthAggregates(date, options = {}) {
      const safeDate = (date instanceof Date && !Number.isNaN(date.getTime())) ? new Date(date) : new Date();
      safeDate.setHours(12, 0, 0, 0);
      const key = getMonthKey(safeDate);
      const { force = false } = options || {};

      if (!force && window.__monthlyDataCache.has(key)) {
        const cached = window.__monthlyDataCache.get(key) || [];
        return cached.map(row => ({ ...row }));
      }

      const year = safeDate.getFullYear();
      const month = String(safeDate.getMonth() + 1).padStart(2, '0');
      const firstDay = `${year}-${month}-01`;
      const lastDay = `${year}-${month}-${String(new Date(year, safeDate.getMonth() + 1, 0).getDate()).padStart(2, '0')}`;

      let teamData = [];
      try {
        const url = `/api/equipos/estadisticas?fechaInicio=${firstDay}&fechaFin=${lastDay}`;
        console.log(`[PORCENTAJE DEBUG] URL de API: ${url}`);
        const resp = await fetchWithAuth(url);
        if (resp && resp.ok) {
          const json = await resp.json();
          const mainData = Array.isArray(json?.data) ? json.data : [];
          const lineasData = Array.isArray(json?.lineas) ? json.lineas : [];
          teamData = [...mainData, ...lineasData];
          if (!teamData.length) {
            teamData = Array.isArray(json) ? json : (Array.isArray(json?.leads) ? json.leads : []);
          }
        }
      } catch (apiErr) {
        console.warn('[PORCENTAJE] Error solicitando estadísticas mensuales:', apiErr);
      }

      const isDatasetEmpty = !Array.isArray(teamData) || !teamData.length || teamData.every(t => Number(t.Total || t.total || 0) === 0 && Number(t.ICON || 0) === 0);
      if (isDatasetEmpty) {
        try {
          const leadsUrl = `/api/leads?fechaInicio=${firstDay}&fechaFin=${lastDay}&limit=5000`;
          const r2 = await fetchWithAuth(leadsUrl);
          let leads = [];
          if (r2 && r2.ok) {
            const j2 = await r2.json();
            leads = Array.isArray(j2) ? j2 : (Array.isArray(j2?.data) ? j2.data : (Array.isArray(j2?.leads) ? j2.leads : []));
          }

          const aggregateMap = new Map();
          (leads || []).forEach(ld => {
            try {
              const teamNameRaw = String(ld.team || ld.TEAM || ld.equipo || ld.group || ld.supervisor || ld.assignedTeam || ld.teamName || ld.nombreEquipo || 'Sin equipo').trim();
              const teamName = teamNameRaw || 'Sin equipo';
              const statusRaw = String(ld.status || ld.estado || ld.estadoVenta || ld.workflowStatus || ld.state || ld.saleStatus || '').toLowerCase().trim();
              const statusNorm = statusRaw.replace(/\s+/g, '');
              const boolActive = (ld.activated === true || ld.sold === true || ld.isActive === true || ld.vendido === true);
              const numericActive = (String(ld.activated || ld.sold || ld.isActive || ld.vendido || '').trim() === '1');
              const isActive = boolActive || numericActive || /completed|completad|finaliz|vendid|vendido/i.test(statusRaw) || ['completed','complete','done','finalizado','completado','activada','activado','vendido','ok','cerrada','cerrado','v'].includes(statusNorm);

              if (!aggregateMap.has(teamName)) {
                aggregateMap.set(teamName, { name: teamName, ICON: 0, ACTIVAS: 0, Total: 0, Puntaje: 0 });
              }

              const entry = aggregateMap.get(teamName);
              entry.Total += 1;
              if (isActive) entry.ACTIVAS += 1;
            } catch (_) { /* ignorar registros con formato inesperado */ }
          });

          teamData = Array.from(aggregateMap.values());
          console.log('fetchMonthAggregates: fallback /api/leads', teamData);
        } catch (fallbackErr) {
          console.warn('fallback aggregation desde /api/leads falló', fallbackErr);
        }
      }

      const sanitized = (teamData || []).map(normalizeTeamRow);

      window.__monthlyDataCache.set(key, sanitized.map(row => ({ ...row })));
      return sanitized.map(row => ({ ...row }));
    }

    async function loadVentasActivasForMonth(date){
      const target = (date instanceof Date && !Number.isNaN(date.getTime())) ? new Date(date) : new Date();
      target.setHours(12, 0, 0, 0);
      window.__ventasActivasFecha = new Date(target);
      updateChartTitle('ventas-activas-mes-titulo', window.__ventasActivasFecha);

      try {
        const monthKey = getMonthKey(target);
        let dataset = [];

        try {
          dataset = await fetchMonthAggregates(target, { force: false });
          if (!Array.isArray(dataset) || dataset.length === 0) {
            dataset = await fetchMonthAggregates(target, { force: true });
          }
        } catch(fetchErr) {
          console.warn('[VENTAS-ACTIVAS] No se pudo obtener agregados mensuales', fetchErr);
        }

        try {
          const tableRows = Array.isArray(window.__statsDisplayRows) ? window.__statsDisplayRows : null;
          const tableKey = (window.__tablaMesFecha instanceof Date && !Number.isNaN(window.__tablaMesFecha.getTime()))
            ? getMonthKey(window.__tablaMesFecha)
            : '';
          if (tableRows && tableRows.length && tableKey === monthKey) {
            dataset = tableRows.map(normalizeTeamRow);
          }
        } catch(syncErr) {
          console.warn('[VENTAS-ACTIVAS] No se pudo sincronizar con la tabla mensual', syncErr);
        }

        if (!Array.isArray(dataset) || dataset.length === 0) {
          try {
            if (Array.isArray(window.__monthlyTeamData) && window.__monthlyTeamData.length) {
              dataset = window.__monthlyTeamData.map(normalizeTeamRow);
            }
          } catch(_){ }
        }

        const sanitized = Array.isArray(dataset) ? dataset.map(normalizeTeamRow) : [];
        renderVentasActivasMes(sanitized);
      } catch (err) {
        console.warn('loadVentasActivasForMonth error', err);
        renderVentasActivasMes([]);
      }
    }

    async function loadConversionTableForMonth(date, options = {}){
      const root = document.getElementById('conversion-table');
      if (!root) {
        console.warn('[TABLA] Contenedor conversion-table no encontrado');
        return;
      }

      const target = (date instanceof Date && !Number.isNaN(date.getTime())) ? new Date(date) : new Date();
      target.setHours(12, 0, 0, 0);
      window.__tablaMesFecha = new Date(target);

      const { updateUrl = true } = options || {};
      if (updateUrl) {
        updateURLWithMonth(window.__tablaMesFecha);
      }

      updateTableTitle(window.__tablaMesFecha);

      try {
        await renderConversionTable(root, window.__tablaMesFecha);
      } catch (err) {
        console.warn('[TABLA] Error al renderizar la tabla mensual:', err);
      }
    }
  </script>
  
  <style>
    /* v2025-11-20-15:31 - Force cache refresh */
    /* Layout general consistente con otras pÃ¡ginas */
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f7fa; color: #1e293b; }

    .layout { display: flex; min-height: 100vh; }

    .main-content {
      flex: 1;
      padding: 20px;
      display: flex;
      flex-direction: column;
    }
    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }

    .conversion-title {
      font-weight: 800; 
      margin: 0 0 8px 0; 
      color: #000; 
      font-size: 1rem; 
      text-align: center;
      background: #fff9c2;
      padding: 6px 4px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .conversion-subtitle { 
      display: none; 
    }
    .sales-table { 
      width: 100%; 
      border-collapse: collapse; 
      font-size: 0.85rem;
      margin-bottom: 0;
    }
    .sales-table th, 
    .sales-table td { 
      padding: 4px 6px; 
      text-align: center; 
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
      height: 28px;
    }
    .sales-table th { 
      background: #1f3b63; 
      color: #fff; 
      font-weight: 700; 
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 6px 4px;
    }
    .sales-table td:first-child, 
    .sales-table th:first-child { 
      text-align: left; 
      padding-left: 8px;
      width: 40%;
    }
    .sales-table .total-row { 
      background: #0b5ed7; 
      color: #fff; 
      font-weight: 800; 
      font-size: 0.9rem;
    }
    .sales-table .score-col { 
      background: #ffeb7a; 
      font-weight: 800; 
      color: #000;
    }
    /* Layout mejorado para conversión: tabla + panel LINEAS (Grid asegura uso total de ancho) */
    .conv-two-col { display: grid; grid-template-columns: 640px 1fr; gap: 8px; align-items: start; width: 100%; max-width: 900px; margin: 0 auto; }
    .conv-left { min-width: 640px; max-width: 640px; width: 640px; max-height: 520px; overflow-y: auto; overflow-x: hidden; margin: 0; padding: 0; }
    .conv-left .sales-table { width: 100% !important; table-layout: fixed; }
    .conv-right { width: 100%; min-width: 200px; max-width: 250px; }
    /* Igualar ancho de contenedores MES y DÍA */
    .conversion-card { width: 100%; max-width: 900px; min-width: 848px; margin: 0 auto; }
    #ventas-dia-card { width: 100%; max-width: 900px; min-width: 848px; margin: 0 auto; }
    /* Quitar contenedores externos (solo dentro de la sección MES/DÍA) */
    #mes-dia-section > .card {
      background: transparent !important;
      box-shadow: none !important;
      border: 0 !important;
      padding: 0 !important;
      margin: 0 auto !important;
      display: flex;
      justify-content: center;
    }
    #mes-dia-section > .card > h3 { display: none !important; }
    #mes-dia-section > .card > div { 
      margin: 0 auto;
      display: flex;
      justify-content: center;
    }
    /* Quitar cualquier tarjeta interna generada por el renderer del MES o del DÍA */
    #mes-dia-section .conversion-card,
    #mes-dia-section .ventas-diarias-card {
      background: transparent !important;
      box-shadow: none !important;
      border: 0 !important;
      padding: 0 !important;
      margin: 0 auto !important;
    }
    .mini-card { background: #fff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px; align-self: start; }
    .mini-card .mini-table { width: 100%; }
    .mini-card .mini-table th { padding: 8px; font-size: 0.85rem; }
    .mini-card .mini-table td { padding: 6px 8px; font-size: 0.9rem; text-align: center; }
    @media (max-width: 900px) { 
      .conv-two-col { display: block; width: 100%; } 
      .conv-left { min-width: 0; width: 100%; max-width: 100%; } 
      .conv-right { width: 100%; min-width: 0; max-width: 100%; } 
      .conversion-card { width: 100% !important; max-width: 100% !important; min-width: 0 !important; }
      #ventas-dia-card { width: 100% !important; max-width: 100% !important; min-width: 0 !important; }
    }
    .mini-table { 
      width: 100%; 
      border-collapse: collapse; 
      font-size: 0.85rem;
      margin-top: 15px;
    }
    .mini-table th, 
    .mini-table td { 
      padding: 4px 6px; 
      text-align: center; 
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
      height: 28px;
    }
    .mini-table th { 
      background: #1f3b63; 
      color: #fff; 
      font-weight: 700;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 6px 4px;
    }
    .mini-table .total { 
      background: #0b5ed7; 
      color: #fff; 
      font-weight: 800;
      font-size: 0.9rem;
    }
    .day-nav-btn { min-width: 36px; font-weight: 700; }
    @media (max-width: 900px) { 
      .conversion-grid { 
        grid-template-columns: 1fr; 
      }
      .ventas-diarias-grid { 
        grid-template-columns: 1fr; 
      }
    }
    
    /* Estilos para la secciÃ³n de Ventas Diarias */
    .ventas-diarias-grid {
      display: grid;
      gap: 16px;
      margin-top: 10px;
    }
    
    .ventas-diarias-card {
      background: white;
      border-radius: 4px;
      padding: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    /* Animaciones tipo carrusel */
    .slide-container { position: relative; overflow: hidden; }
    .slide-card { transition: transform 280ms ease, opacity 280ms ease; will-change: transform, opacity; }
    .flip-viewport { perspective: 1200px; position: relative; width: 100%; }
    .flip-scene { position: relative; width: 100%; height: 100%; transform-style: preserve-3d; transition: transform 0.8s ease; }
    .flip-face { position: absolute; inset: 0; width: 100%; height: 100%; backface-visibility: hidden; -webkit-backface-visibility: hidden; }
    .slide-exit-left { transform: translateX(-20%); opacity: 0; }
    .slide-exit-right { transform: translateX(20%); opacity: 0; }
    .slide-enter-base { transform: translateX(0); opacity: 0; }
    .slide-enter-from-left { transform: translateX(-20%); opacity: 0; }
    .slide-enter-from-right { transform: translateX(20%); opacity: 0; }
    .slide-enter-active { transform: translateX(0); opacity: 1; }
    
    .ventas-title {
      font-weight: 800;
      margin: 0 0 10px 0;
      color: #000;
      font-size: 1rem;
      text-align: center;
      background: #fff9c2;
      padding: 6px 4px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Botones flecha para navegación de meses (solo íconos) dentro de tarjetas */
    .porc-nav { display:flex; gap:8px; align-items:center; }
    .porc-nav .porc-arrow { background:#e6eef9; border:1px solid #cfe0fa; color:#0f172a; width:34px; height:34px; border-radius:6px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; font-weight:700; }
    .porc-nav .porc-arrow:hover { background:#d0e7ff; }
    
    .ventas-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin-bottom: 15px;
    }
    
    .ventas-table th,
    .ventas-table td {
      padding: 6px 8px;
      text-align: center;
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
    }
    
    .ventas-table th {
      background: #1f3b63;
      color: #fff;
      font-weight: 700;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 8px 4px;
    }
    
    .ventas-table td:first-child {
      text-align: left;
      padding-left: 10px;
    }
    
    .ventas-table .total-row {
      background: #0b5ed7;
      color: #fff;
      font-weight: 800;
      font-size: 0.9rem;
    }
    
    .ventas-table .score-col {
      background: #ffeb7a;
      font-weight: 800;
      color: #000;
    }
    
    /* Estilos para grÃ¡ficos */
    .chart-card {
      grid-column: 1 / -1;
      margin-bottom: 20px;
    }
    /* Excepción: las tarjetas dentro de #top-charts usan su propio grid (2 columnas)
       Evitamos que la regla global .chart-card las fuerce a 1 columna */
    #top-charts-combined {
      width: 100%;
      max-width: 100%;
      margin: 0 auto 20px auto;
      padding: 20px;
      grid-column: 1 / -1;
    }
    #top-charts-inner {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      align-items: start;
    }
    .top-chart-section {
      min-width: 0;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    .top-chart-section.porcentaje-section {
      display: flex;
      flex-direction: column;
    }
    .top-chart-section.porcentaje-section .chart-subtitle {
      margin-bottom: 15px;
    }
    .porcentaje-content {
      display: flex;
      flex-direction: row;
      gap: 20px;
      align-items: flex-start;
    }
    .porcentaje-left {
      width: 200px;
      min-width: 200px;
      flex-shrink: 0;
    }
    .porcentaje-right {
      flex: 1;
      min-width: 0;
    }
    /* Estilos para Ventas Activas (similar a Porcentaje) */
    .top-chart-section.ventas-activas-section {
      display: flex;
      flex-direction: column;
    }
    .top-chart-section.ventas-activas-section .chart-subtitle {
      margin-bottom: 15px;
    }
    .ventas-activas-content {
      display: flex;
      flex-direction: row;
      gap: 20px;
      align-items: flex-start;
    }
    .ventas-activas-left {
      width: 200px;
      min-width: 200px;
      flex-shrink: 0;
    }
    .ventas-activas-right {
      flex: 1;
      min-width: 0;
    }
    .chart-subtitle {
      font-size: 1rem;
      font-weight: 600;
      color: #1f3b63;
      margin: 0 0 15px 0;
      padding-bottom: 10px;
      border-bottom: 2px solid #e5e7eb;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .chart-subtitle i {
      color: #22b3ec;
    }
    .top-chart-section .chart-wrapper {
      height: 400px;
      min-height: 400px;
      position: relative;
    }
    .top-chart-section .chart-wrapper canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
    @media (max-width: 1200px) {
      #top-charts-inner {
        grid-template-columns: 1fr;
        gap: 40px;
      }
    }

    /* Excepción: fila de Ventas y Productos (dos columnas al mismo nivel) */
    #ventas-products-row .chart-card { grid-column: auto !important; }
  /* match altura de .graph-container para que queden alineados */
  #ventas-products-row .chart-wrapper { min-height: 360px; height: 420px; }
  #ventas-products-row .graph-container { height: 420px; }
  /* asegurar que el canvas llene el wrapper (override inline/Chart.js sizing) */
  #ventas-products-row .chart-wrapper canvas { width: 100% !important; height: 100% !important; display: block; }
    @media (max-width: 900px) {
      /* en pantallas pequeñas, apilar una columna para mejor lectura */
      #ventas-products-row { grid-template-columns: 1fr !important; }
    }
    
    .chart-wrapper {
      position: relative;
      height: 400px;
      width: 100%;
      min-height: 300px;
    }
    
    .chart-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      padding: 20px;
      text-align: center;
      color: #666;
    }
    
    .chart-loading .spinner-border {
      width: 3rem;
      height: 3rem;
    }
    
    .alert {
      padding: 15px;
      margin-bottom: 20px;
      border: 1px solid transparent;
      border-radius: 4px;
    }
    
    .alert-danger {
      color: #721c24;
      background-color: #f8d7da;
      border-color: #f5c6cb;
    }

    /* Estilos para la nueva gráfica de ventas y puntaje */
    .date-filter-container {
      width: fit-content;
      margin-bottom: 15px;
      background: #f8fafc;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }
    
    .date-filter {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
    }
    
    .date-filter label {
      color: #475569;
      font-weight: 500;
      margin-right: 2px;
      font-size: 12px;
      white-space: nowrap;
    }
    
    .date-select {
      padding: 2px 6px;
      border: 1px solid #cbd5e1;
      border-radius: 4px;
      background-color: white;
      font-size: 12px;
      width: 70px;
      height: 26px;
    }
    
    .filter-button {
      padding: 2px 8px;
      background-color: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 11px;
      height: 26px;
      white-space: nowrap;
      transition: background-color 0.2s;
    }
    
    .filter-button:hover {
      background-color: #2563eb;
    }

    /* Estilos para navegación de gráficos */
    .chart-header-with-nav {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      gap: 12px;
    }

    .chart-nav-btn {
      background-color: #3b82f6;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      flex-shrink: 0;
      min-width: 40px;
      height: 36px;
    }

    .chart-nav-btn:hover {
      background-color: #2563eb;
      transform: scale(1.05);
    }

    .chart-nav-btn:disabled {
      background-color: #9ca3af;
      cursor: not-allowed;
      transform: none;
    }

    .chart-subtitle {
      margin: 0;
      flex: 1;
      text-align: center;
    }

    body.dark-theme .chart-nav-btn {
      background-color: #404040;
      color: white;
      border: 1px solid #555;
    }

    body.dark-theme .chart-nav-btn:hover {
      background-color: #525252;
    }
    
    /* Botones de navegación de día */
    .day-nav-btn,
    #day-prev-alt,
    #day-next-alt {
      padding: 6px 12px !important;
      font-size: 16px !important;
      height: auto !important;
      min-width: 38px !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      line-height: 1 !important;
      background-color: #3b82f6 !important;
      color: white !important;
      border: none !important;
      border-radius: 6px !important;
      cursor: pointer !important;
      font-weight: 600 !important;
      transition: all 0.2s !important;
      flex-shrink: 0 !important;
    }
    
    .day-nav-btn:hover,
    #day-prev-alt:hover,
    #day-next-alt:hover {
      background-color: #2563eb !important;
      transform: scale(1.05) !important;
    }
    
    body.dark-theme .day-nav-btn,
    body.dark-theme #day-prev-alt,
    body.dark-theme #day-next-alt {
      padding: 8px 16px !important;
      font-size: 18px !important;
      height: auto !important;
      background-color: #3b82f6 !important;
    }
    
    #reset-filter {
      background-color: #64748b;
      padding: 2px 6px;
    }
    
    #reset-filter:hover {
      background-color: #475569;
    }

    .graph-container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
      width: 100%;
      height: 420px;
      max-height: 420px;
      position: relative;
    }
    
    .graph-canvas {
      width: 100% !important;
      height: 100% !important;
      min-height: 360px;
    }

    /* Estilos para notificaciones */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 25px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      display: flex;
      align-items: center;
      transform: translateX(120%);
      transition: transform 0.3s ease-in-out;
      max-width: 350px;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success {
      background-color: #10b981;
      border-left: 4px solid #059669;
    }

    .notification.error {
      background-color: #ef4444;
      border-left: 4px solid #dc2626;
    }

    .notification i {
      margin-right: 10px;
      font-size: 20px;
    }
    
    /* Estilos para el modal de detalle del día */
    .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
    .modal{background:#fff;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.2);max-width:960px;width:92%;max-height:80vh;overflow:auto}
    .modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e2e8f0;font-weight:800}
    .modal-body{padding:12px 16px}
    .close-btn{border:none;background:#e11d48;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
    .table-compact{width:100%;border-collapse:collapse;font-size:.9rem}
    .table-compact th,.table-compact td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left}
    .table-compact th{background:#1f3b63;color:#fff}
    .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}

    /* Dark theme overrides for tables */
    body.dark-theme .ventas-table,
    body.dark-theme .sales-table,
    body.dark-theme .mini-table,
    body.dark-theme .table-compact {
      background-color: transparent;
    }

    body.dark-theme .ventas-table th,
    body.dark-theme .sales-table th,
    body.dark-theme .mini-table th,
    body.dark-theme .table-compact th {
      background: #1e3a5f !important;
      color: #e2e8f0 !important;
      border-color: #334155;
    }

    body.dark-theme .ventas-table td,
    body.dark-theme .sales-table td,
    body.dark-theme .mini-table td,
    body.dark-theme .table-compact td {
      background-color: #1e293b;
      color: #cbd5e1;
      border-color: #334155;
    }

    body.dark-theme .ventas-table tbody tr:nth-child(even) td,
    body.dark-theme .sales-table tbody tr:nth-child(even) td {
      background-color: #1a2436;
    }

    body.dark-theme .ventas-table tbody tr:hover td,
    body.dark-theme .sales-table tbody tr:hover td {
      background-color: #253147;
    }
  </style>
</head>
<body>
  <div class="layout">
    <!-- SIDEBAR (cargado dinámicamente) -->
    <nav class="sidebar sidebar-inicio" data-active="estadisticas"></nav>

    <main class="main-content">
      <header class="page-header">
        <h1 class="page-title"><i class="fas fa-chart-line" ></i> Estadísticas</h1>
        <div class="page-actions">
          <button id="btn-refresh" class="btn-refresh" class="btn-refresh">Actualizar</button>
        </div>
      </header>

      <section class="stats-grid">
        <!-- STAGE 1: Combined top chart - Porcentaje de Activación y Ventas Activas del mes -->
        <div id="top-charts-combined" class="card chart-card">
          <h3 >
            <i class="fas fa-chart-pie" ></i> 
            Estadísticas del Mes
          </h3>
          <div id="top-charts-inner">
            <!-- Gráfico izquierdo: Porcentaje de Activación -->
            <div class="top-chart-section porcentaje-section">
              <div class="chart-header-with-nav">
                <button id="porcentaje-prev" class="chart-nav-btn" title="Mes anterior">◀</button>
                <h4 class="chart-subtitle"><i class="fas fa-percent"></i> Porcentaje de Activación (<span id="porcentaje-mes-titulo">12/2025</span>)</h4>
                <button id="porcentaje-next" class="chart-nav-btn" title="Mes siguiente">▶</button>
              </div>
              <div class="porcentaje-content">
                <div class="porcentaje-left">
                  <div id="porc-team-list" ></div>
                  <div id="porc-activas-note" ></div>
                </div>
                <div class="porcentaje-right">
                  <div class="chart-wrapper">
                    <canvas id="chart-porcentaje-activacion"></canvas>
                  </div>
                </div>
              </div>
            </div>

            <!-- Gráfico derecho: Ventas Activas -->
            <div class="top-chart-section ventas-activas-section">
              <div class="chart-header-with-nav">
                <button id="ventas-activas-prev" class="chart-nav-btn" title="Mes anterior">◀</button>
                <h4 class="chart-subtitle"><i class="fas fa-chart-bar"></i> Ventas Activas (<span id="ventas-activas-mes-titulo">12/2025</span>)</h4>
                <button id="ventas-activas-next" class="chart-nav-btn" title="Mes siguiente">▶</button>
              </div>
              <div class="ventas-activas-content">
                <div class="ventas-activas-left">
                  <div id="ventas-activas-team-list" ></div>
                  <div id="ventas-activas-note" ></div>
                </div>
                <div class="ventas-activas-right">
                  <div class="chart-wrapper">
                    <canvas id="chart-ventas-activas-mes"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div id="mes-dia-section" >
          <div class="card">
            <h3></h3>
            <div id="conversion-table" class="conversion-grid"></div>
          </div>

          <div class="card">
            <div class="ventas-diarias-grid">
              <div id="ventas-dia-card" class="ventas-diarias-card"><!-- Renderizado por JS --></div>
            </div>
          </div>
        </div>

        <!-- Nueva Sección: Gráfica de Ventas y Puntaje (Últimos 7 días) + Productos vendidos en el mes -->
  <div id="ventas-products-row" >
          <div class="card chart-card">
            <h3><i class="fas fa-chart-bar" ></i> Ventas y Puntaje - Últimos 7 días</h3>
            
            <!-- Filtro de Fecha -->
            <div class="date-filter-container" style="margin-bottom: 20px;">
              <div class="date-filter">
                <label for="month-select">Mes:</label>
                <select id="month-select" class="date-select">
                  <option value="0">Enero</option>
                  <option value="1">Febrero</option>
                  <option value="2">Marzo</option>
                  <option value="3">Abril</option>
                  <option value="4">Mayo</option>
                  <option value="5">Junio</option>
                  <option value="6">Julio</option>
                  <option value="7">Agosto</option>
                  <option value="8">Septiembre</option>
                  <option value="9">Octubre</option>
                  <option value="10">Noviembre</option>
                  <option value="11">Diciembre</option>
                </select>
                
                <label for="day-select">Día:</label>
                <select id="day-select" class="date-select">
                  <!-- Los días se llenarán dinámicamente -->
                </select>
                
                <label for="year-select">Año:</label>
                <select id="year-select" class="date-select">
                  <option value="2023">2023</option>
                  <option value="2024">2024</option>
                  <option value="2025" selected>2025</option>
                  <option value="2026">2026</option>
                </select>
                
                <button id="apply-filter" class="filter-button">Aplicar Filtro</button>
                <button id="reset-filter" class="filter-button">Hoy</button>
              </div>
            </div>

            <!-- Gráfica de Ventas y Puntaje -->
            <div class="graph-container">
              <canvas id="ventasPuntajeChart" class="graph-canvas"></canvas>
            </div>
          </div>

          <div class="card chart-card">
            <div class="conversion-title-wrapper">
              <button id="products-prev" class="products-nav-btn chart-nav-btn" title="Mes anterior" type="button">◀</button>
              <div id="products-month-title" class="conversion-title" >Productos vendidos en Noviembre 2025</div>
              <button id="products-next" class="products-nav-btn chart-nav-btn" title="Mes siguiente" type="button">▶</button>
            </div>
            <div class="chart-wrapper">
              <canvas id="productsChart"></canvas>
            </div>
          </div>
        </div>
      </div>
      </section>
    </main>
  </div>

  <!-- Modal de detalle del día -->
  <div id="day-detail-modal" class="modal-overlay">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="dayDetailTitle">
      <div class="modal-header">
        <div id="dayDetailTitle">Detalle de Ventas del Día</div>
        <button class="close-btn" id="day-detail-close">Cerrar</button>
      </div>
      <div class="modal-body">
        <div class="toolbar">
          <label for="filter-team-select" >Equipo:</label>
          <select id="filter-team-select"></select>
          <span id="day-detail-subtitle" ></span>
        </div>
        <div >
          <table class="table-compact" id="day-detail-table">
            <thead>
              <tr>
                <th>Equipo</th>
                <th>Agente</th>
                <th>Servicio</th>
                <th>Mercado</th>
                <th>Puntaje</th>
                <th>Fecha</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Datos de ejemplo para visualizaciÃ³n inicial (puedes reemplazar por datos reales)
    function rand(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }  
    function rand(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }  

    async function renderConversionTable(root, explicitDate) {
      try {
        console.log('Iniciando renderConversionTable con root:', root);
        if (!root) {
          console.error('Error: No se proporcionÃ³ un elemento raÃ­z vÃ¡lido');
          return;
        }

        // Eliminar cualquier botón de fallback heredado de renders anteriores
        try {
          const fallbackBtn = document.getElementById('btn-fallback-leads');
          if (fallbackBtn && fallbackBtn.parentElement) {
            const wrapper = fallbackBtn.parentElement;
            if (wrapper && wrapper.parentElement) {
              wrapper.parentElement.removeChild(wrapper);
            }
          }
        } catch(_){ }
        
        // Verificar autenticaciÃ³n
        if (!checkAuth()) return;
        
        // Mostrar indicador de carga
        root.innerHTML = '<div class="text-center py-4"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Cargando...</span></div><p class="mt-2">Cargando datos de equipos...</p></div>';
        
        // Determinar el mes objetivo sin depender del estado de otros módulos
        let targetMonth;
        if (explicitDate instanceof Date && !Number.isNaN(explicitDate.getTime())) {
          targetMonth = new Date(explicitDate);
          console.log('[TABLA DEBUG] Usando fecha explÃ­cita para tabla:', targetMonth);
        } else if (window.__tablaMesFecha instanceof Date && !Number.isNaN(window.__tablaMesFecha.getTime())) {
          targetMonth = new Date(window.__tablaMesFecha);
          console.log('[TABLA DEBUG] Usando window.__tablaMesFecha como respaldo:', targetMonth);
        } else if (window.__porcentajeFecha instanceof Date && !Number.isNaN(window.__porcentajeFecha.getTime())) {
          targetMonth = new Date(window.__porcentajeFecha);
          console.log('[TABLA DEBUG] Usando window.__porcentajeFecha como respaldo heredado:', targetMonth);
        } else {
          console.warn('[TABLA DEBUG] Sin fecha previa, usando fecha actual para tabla mensual');
          targetMonth = new Date();
        }
        targetMonth.setHours(12, 0, 0, 0);
        window.__tablaMesFecha = new Date(targetMonth);
        // Rango del MES COMPLETO (desde día 1 hasta último día del mes)
        let fechaInicio = '';
        let fechaFin = '';
        {
          const primerDiaMes = new Date(targetMonth.getFullYear(), targetMonth.getMonth(), 1);
          const ultimoDiaMes = new Date(targetMonth.getFullYear(), targetMonth.getMonth() + 1, 0);
          const fmt = (d)=>`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
          fechaInicio = fmt(primerDiaMes);
          fechaFin = fmt(ultimoDiaMes);
          console.log('[ESTADISTICAS DEBUG] Mes objetivo:', { 
            mes: `${targetMonth.getMonth()+1}/${targetMonth.getFullYear()}`, 
            fechaInicio, 
            fechaFin,
            targetMonth: targetMonth.toISOString()
          });
        }

        const now = new Date();
        const isCurrentMonth = targetMonth.getMonth() === now.getMonth() && targetMonth.getFullYear() === now.getFullYear();
        
        // Construir URL con parámetros
        let url = '/api/equipos/estadisticas';
        const params = new URLSearchParams();
        
        if (fechaInicio) params.append('fechaInicio', fechaInicio);
        if (fechaFin) params.append('fechaFin', fechaFin);
        // Si el rol es agente, forzar que el backend devuelva TODOS los equipos
        try {
          const u = JSON.parse(sessionStorage.getItem('user') || localStorage.getItem('user') || 'null');
          const role = (u?.role || '').toString().trim().toLowerCase();
          if (role === 'agent' || role === 'agente') params.append('forceAll', '1');
        } catch(_){ }
        
        // Agregar parámetros a la URL
        if (params.toString()) {
          url += '?' + params.toString();
        }
        
        console.log('[ESTADISTICAS] Solicitando datos a:', url);
        
        // Realizar petición a la API usando la función fetchWithAuth
        console.log('[ESTADISTICAS] Realizando petición a la API...');
        const response = await fetchWithAuth(url);
        console.log('Respuesta recibida:', response);
        
        if (!response) {
          console.error('No se recibiÃ³ respuesta de la API (posible error de autenticaciÃ³n)');
          return; // Error de autenticaciÃ³n ya manejado
        }
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Error en la respuesta:', {
            status: response.status,
            statusText: response.statusText,
            error: errorText
          });
          throw new Error(`Error HTTP: ${response.status} - ${errorText}`);
        }
        
        let data = await response.json();
        let usedAllFallback = false;
        console.log('Datos recibidos de la API (MES):', {
          success: data.success,
          message: data.message,
          total: data.total,
          data: data.data ? `Array de ${data.data.length} elementos` : 'No hay datos'
        });
        
        // Eliminado fallback all=1 para mostrar solo datos del MES ACTUAL
        
        if (!data.success) {
          console.error('Formato de respuesta invÃ¡lido:', data);
          throw new Error('Formato de respuesta invÃ¡lido');
        }

        
        // Si no hay datos (o según rol), podremos forzar fallback con /api/leads
        let teamData = [];
        // Determinar si el payload está vacío o si trae solo equipos en cero
        const payloadEmpty = !data.data || data.data.length === 0;
        const payloadZero = Array.isArray(data.data) && data.data.length > 0 && data.data.every(e => (Number(e.Total||0) === 0) && (Number(e.ICON||0) === 0) && (Number(e.BAMO||0) === 0) && (Number(e.Puntaje||0) === 0));

        if (!(payloadEmpty || payloadZero)) {
          // Mapear datos de la API al formato esperado (mantener Puntaje como número)
          teamData = data.data.map(equipo => ({
            name: equipo.TEAM || equipo.team || 'Sin equipo',
            ICON: parseFloat(equipo.ICON || 0),
            ACTIVAS: parseFloat(equipo.ACTIVAS || 0),
            BAMO: parseFloat(equipo.BAMO || 0),
            Total: parseFloat(equipo.Total || 0),
            Puntaje: parseFloat(equipo.Puntaje || 0)
          }));
        }

        // Si la respuesta viene vacía/cero se resolverá automáticamente mediante la agregación local
        // Separar TEAM LINEAS a tabla aparte y mantener principal sin LINEA(S)
        const lineasData = Array.isArray(data.lineas) ? data.lineas.map(r => ({
          name: r.name || r.TEAM || 'SIN NOMBRE',
          ICON: parseFloat(r.ICON || 0)
        })) : [];
        const lineasTotalICON = typeof data.lineasTotalICON === 'number' ? data.lineasTotalICON : lineasData.reduce((acc, r) => acc + (r.ICON || 0), 0);
        const excludeNames = new Set(['TEAM LINEA','TEAM LINEAS']);
        let fallbackTeamData = teamData.filter(t => !excludeNames.has((t.name || '').toUpperCase()));
        // Nota: la verificación de "activas" era realizada en el cliente (consultando /api/leads).
        // Se ha eliminado aquí para evitar llamadas redundantes y condiciones de carrera.
        // El conteo autoritativo de ACTIVAS debe provenir del backend (`/api/equipos/estadisticas`).
        const allZero = fallbackTeamData.length > 0 && fallbackTeamData.every(t => Number(t.Total||0) === 0 && (Number(t.ICON||0) === 0) && (Number(t.BAMO||0) === 0) && (Number(t.Puntaje||0) === 0));

        let shouldUseFallback = fallbackTeamData.length === 0 || allZero;
        const needsLeadsAggregation = shouldUseFallback;

        const buildMonthlyLeadsAggregation = async () => {
          try {
            const mesTexto = `${String(targetMonth.getMonth() + 1).padStart(2, '0')}/${targetMonth.getFullYear()}`;
            console.log(`[LEADS MENSUAL] Construyendo datos desde /api/leads para ${mesTexto}`);

            const getByPath = (obj, path) => {
              try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch (_) { return undefined; }
            };
            const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
            const tryDateFrom = (val) => {
              if (!val) return null;
              if (val instanceof Date) return isNaN(val.getTime()) ? null : val;
              if (typeof val === 'number') {
                const asDate = val < 1e12 ? new Date(val * 1000) : new Date(val);
                return isNaN(asDate.getTime()) ? null : asDate;
              }
              const str = String(val).trim();
              if (!str) return null;
              if (/^\d{4}-\d{2}-\d{2}(?:T.*)?$/.test(str)) {
                const d = new Date(str.includes('T') ? str : `${str}T00:00:00.000Z`);
                return isNaN(d.getTime()) ? null : d;
              }
              if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(str)) {
                const [dd, mm, yyyy] = str.split(/[\/\-]/).map(Number);
                const d = new Date(Date.UTC(yyyy, mm - 1, dd, 0, 0, 0, 0));
                return isNaN(d.getTime()) ? null : d;
              }
              const d = new Date(str);
              return isNaN(d.getTime()) ? null : d;
            };

            const startUTC = new Date(Date.UTC(targetMonth.getFullYear(), targetMonth.getMonth(), 1, 0, 0, 0, 0));
            const endUTC = new Date(Date.UTC(targetMonth.getFullYear(), targetMonth.getMonth() + 1, 0, 23, 59, 59, 999));
            const fmt = (d) => `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2, '0')}-${String(d.getUTCDate()).padStart(2, '0')}`;
            const startStr = fmt(startUTC);
            const endStr = fmt(endUTC);
            console.log(`[LEADS MENSUAL] Rango solicitado: ${startStr} → ${endStr}`);

            const matchesTargetMonth = (val) => {
              const parsed = tryDateFrom(val);
              return parsed ? (parsed >= startUTC && parsed <= endUTC) : false;
            };

            const leadsResp = await fetchWithAuth(`/api/leads?fechaInicio=${startStr}&fechaFin=${endStr}`);
            if (!leadsResp || !leadsResp.ok) {
              console.warn(`[LEADS MENSUAL] No se pudo obtener /api/leads (status: ${leadsResp ? leadsResp.status : 'sin respuesta'})`);
              return [];
            }

            const leadsJson = await leadsResp.json();
            let leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
            console.log(`[LEADS MENSUAL] Recibidos ${leads.length} registros ANTES del filtro por dia_venta`);

            const inRange = leads.filter(lead => {
              const diaVenta = findFirst(lead, ['dia_venta','diaVenta']);
              if (!diaVenta) return false;
              const parsed = tryDateFrom(diaVenta);
              if (!parsed) return false;
              return parsed >= startUTC && parsed <= endUTC;
            });
            console.log(`[LEADS MENSUAL] Filtrados ${inRange.length} registros DESPUÉS del filtro por dia_venta`);
            if (inRange.length === 0) {
              console.log(`[LEADS MENSUAL] No hay leads con dia_venta dentro del rango ${startStr} - ${endStr}`);
            }

            // Deduplicar por identificadores estables (numero_cuenta, telefono, dia_venta)
            const sanitize = (value) => (value || '').toString().trim().toUpperCase();
            const onlyDigits = (value) => (value || '').toString().replace(/\D+/g, '');
            const dedupeKeyOf = (lead) => {
              const numeroCuenta = sanitize(findFirst(lead, ['numero_cuenta','numeroCuenta','accountNumber']));
              const telefono = onlyDigits(findFirst(lead, ['telefono_principal','telefonoPrincipal','telefono']));
              const diaVenta = sanitize(findFirst(lead, ['dia_venta','diaVenta']));
              const servicio = sanitize(findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']));
              const parts = [numeroCuenta, telefono, diaVenta, servicio].filter(Boolean);
              if (parts.length) return parts.join('|');
              const fallbackId = sanitize(findFirst(lead, ['_id','id','uid']));
              return fallbackId || JSON.stringify(lead);
            };

            const deduped = [];

            // Deduplicación avanzada: conservar el lead con mayor puntaje y, en empate, el más reciente
            const dedupMap = new Map();
            for (const lead of inRange) {
              const key = dedupeKeyOf(lead);
              if (!key) {
                deduped.push(lead);
                continue;
              }
              const puntaje = getPuntaje(lead);
              // Buscar fecha de creación o venta
              const fechaVenta = findFirst(lead, ['dia_venta','diaVenta','fecha_venta','fechaVenta','createdAt','created_at','fecha','date']);
              const fechaMs = fechaVenta ? (tryDateFrom(fechaVenta)?.getTime() || 0) : 0;
              if (!dedupMap.has(key)) {
                dedupMap.set(key, {lead, puntaje, fechaMs});
              } else {
                const actual = dedupMap.get(key);
                if (puntaje > actual.puntaje || (puntaje === actual.puntaje && fechaMs > actual.fechaMs)) {
                  dedupMap.set(key, {lead, puntaje, fechaMs});
                }
              }
            }
            deduped.push(...Array.from(dedupMap.values()).map(x => x.lead));

            if (deduped.length !== inRange.length) {
              console.log(`[LEADS MENSUAL] Eliminados ${inRange.length - deduped.length} duplicados después del filtro del mes.`);
            }

            const teamMap = new Map();
            const teamNameOf = (lead) => {
              const t = findFirst(lead, ['TEAM','team','equipo','grupo','department','team_name','Team']);
              const s = (t || '').toString().trim();
              return s || 'Sin equipo';
            };
            const isICON = (lead) => {
              const v = (findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
              return v.includes('ICON');
            };
            const isBAMO = (lead) => {
              const v = (findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
              return v.includes('BAMO');
            };
            const getPuntaje = (lead) => {
              const p = findFirst(lead, ['puntaje','score','puntos']);
              const n = typeof p === 'number' ? p : parseFloat(p);
              return isNaN(n) ? 0 : n;
            };
            const isActiveLead = (lead) => {
              try {
                const rawStatus = (findFirst(lead, ['status','estado','estadoVenta','workflowStatus','state','saleStatus']) || '').toString().toLowerCase().trim();
                const statusNorm = rawStatus.replace(/\s+/g, '');
                const boolActive = (lead.activated === true || lead.sold === true || lead.isActive === true || lead.vendido === true || lead.activada === true);
                const numericActive = ['1','true','sí','si'].includes(String(findFirst(lead, ['activated','sold','isActive','vendido','activada','activadas']) || '').toString().trim().toLowerCase());
                if (boolActive || numericActive) return true;
                if (!rawStatus) return false;
                return /completed|completad|finaliz|vendid|vendido|activad|cerrad|ok/i.test(rawStatus) || ['completed','complete','done','finalizado','completado','activada','activado','vendido','ok','cerrada','cerrado','v'].includes(statusNorm);
              } catch(_) { return false; }
            };

            deduped.forEach(l => {
              const name = teamNameOf(l);
              if (!teamMap.has(name)) teamMap.set(name, { name, ICON: 0, BAMO: 0, Total: 0, Puntaje: 0, ACTIVAS: 0 });
              const agg = teamMap.get(name);
              agg.Total += 1;
              if (isICON(l)) agg.ICON += 1; else if (isBAMO(l)) agg.BAMO += 1;
              agg.Puntaje += getPuntaje(l);
              if (isActiveLead(l)) agg.ACTIVAS += 1;
            });

            return Array.from(teamMap.values()).filter(t => !excludeNames.has((t.name || '').toUpperCase()));
          } catch (err) {
            console.error('[LEADS MENSUAL] Error construyendo aggregation mensual:', err);
            return [];
          }
        };

        let leadsAggregation = [];
        if (needsLeadsAggregation) {
          leadsAggregation = await buildMonthlyLeadsAggregation();
        }

        if (!isCurrentMonth) {
          if (shouldUseFallback) {
            console.log(`[TABLA] Mes navegando ${String(targetMonth.getMonth() + 1).padStart(2,'0')}/${targetMonth.getFullYear()} no es el actual y el backend viene vacío/cero. Usando aggregation por dia_venta (${leadsAggregation.length} registros).`);
            fallbackTeamData = Array.isArray(leadsAggregation) ? leadsAggregation : [];
            teamData = fallbackTeamData.slice();
            shouldUseFallback = false;
          } else {
            console.log(`[TABLA] Mes navegando ${String(targetMonth.getMonth() + 1).padStart(2,'0')}/${targetMonth.getFullYear()} no es el actual. Usando datos del backend /api/equipos/estadisticas.`);
          }
        } else if (shouldUseFallback) {
          console.log(`[FALLBACK] Mes actual sin datos válidos. Usando aggregation por dia_venta (${leadsAggregation.length} registros).`);
          fallbackTeamData = Array.isArray(leadsAggregation) ? leadsAggregation : [];
          teamData = fallbackTeamData.slice();
          shouldUseFallback = false;
        }
        
        
        // Visibilidad (MES): no filtrar por fin de semana; siempre considerar todos los equipos
        (function applyMonthVisibility(){
          try {
            const norm = (s)=>String(s||'').normalize('NFD').replace(/\p{Diacritic}+/gu,'').trim().toLowerCase();
            const teamCanon = (name)=>{
              const n = norm(name).replace(/^team\s+/, '');
              if (n.includes('pleitez')) return 'Pleitez';
              if (n.includes('roberto')) return 'Roberto';
              if (n.includes('marisol')) return 'Marisol';
              if (n.includes('johana') || n.includes('johanna')) return 'Johana';
              if (n.includes('irania')) return 'Irania';
              return name || 'Sin equipo';
            };
            const groupA = new Set(['johana','irania']);
            const groupB = new Set(['pleitez','roberto','marisol']);
            const today = new Date();
            // No filtrar por día: mantener todos los equipos del mes

            // Asegurar presencia de filas en 0 para equipos faltantes
            const allTeams = (function(){
              try {
                if (window.Teams && typeof window.Teams.getAllTeams === 'function') {
                  const arr = window.Teams.getAllTeams(); // devuelve nombres
                  return Array.isArray(arr) ? arr : [];
                }
              } catch(_){ }
              // fallback estático
              return [];
            })();
            const targetSet = new Set(allTeams.map(x=>norm(x)));
            const ensureRows = (arr)=>{
              try {
                const have = new Set((arr||[]).map(t=>norm(t?.name)));
                const out = Array.isArray(arr) ? arr.slice() : [];
                for (const t of targetSet) {
                  if (!have.has(t)) {
                    // no incluir TEAM LINEAS aquí (va aparte)
                    out.push({ name: t.charAt(0).toUpperCase()+t.slice(1), ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });
                  }
                }
                return out;
              } catch(_) { return arr; }
            };
            fallbackTeamData = ensureRows(fallbackTeamData);
            teamData = ensureRows(teamData);
          } catch(e) { console.warn('[ESTADISTICAS] Weekend visibility filter error:', e); }
        })();

        // Calcular totales preliminares (serán recalculados tras el orden final)
        let totals = teamData.reduce((acc, r) => ({
          ICON: acc.ICON + (r.ICON || 0),
          BAMO: acc.BAMO + (r.BAMO || 0),
          Total: acc.Total + (r.Total || 0),
          Puntaje: acc.Puntaje + parseFloat(r.Puntaje || 0),
          ACTIVAS: acc.ACTIVAS + (r.ACTIVAS || 0)
        }), { ICON: 0, BAMO: 0, Total: 0, Puntaje: 0, ACTIVAS: 0 });

        // Orden fijo MES: siempre mostrar todos los equipos en ORDER_ALL
        (function applyFinalOrdering(){
          try {
            const norm = (s)=>String(s||'').normalize('NFD').replace(/\p{Diacritic}+/gu,'').trim().toLowerCase();
            const teamCanon = (name)=>{
              const n = norm(name).replace(/^team\s+/, '');
              if (n.includes('pleitez')) return 'Pleitez';
              if (n.includes('roberto')) return 'Roberto';
              if (n.includes('marisol')) return 'Marisol';
              if (n.includes('johana') || n.includes('johanna')) return 'Johana';
              if (n.includes('irania')) return 'Irania';
              return name || 'Sin equipo';
            };
            const ORDER_ALL = ['Pleitez','Roberto','Marisol','Johana','Irania'];
            const ORDER_A = ['Johana','Irania'];
            const ORDER_B = ['Pleitez','Roberto','Marisol'];
            let order = ORDER_ALL;
            const canonRows = (fallbackTeamData||[]).map(t=>({ ...t, name: teamCanon(t?.name) }));
            const map = new Map(canonRows.map(t=>[norm(t?.name), t]));
            const ensureRow = (name)=> map.get(norm(name)) || { name, ICON:0, BAMO:0, Total:0, Puntaje:0, ACTIVAS:0 };
            const ordered = order.map(ensureRow);
            const displayRows = ordered;
            fallbackTeamData = displayRows;
            // mantener teamData en sincronía para totales
            teamData = displayRows.slice();
            try { window.MonthDisplayRows = displayRows.slice(); } catch(_){ }
            // Datos para la gráfica mensual (flip)
            try { window.__monthlyTeamData = displayRows.slice(); } catch(_){ }
            try { window.__monthlyRange = { start: fechaInicio, end: fechaFin }; } catch(_){ }
            // recalcular totales definitivos con displayRows
            totals = (displayRows||[]).reduce((acc, r) => ({
              ICON: acc.ICON + (r.ICON || 0),
              BAMO: acc.BAMO + (r.BAMO || 0),
              Total: acc.Total + (r.Total || 0),
              Puntaje: acc.Puntaje + parseFloat(r.Puntaje || 0),
              ACTIVAS: acc.ACTIVAS + (r.ACTIVAS || 0)
            }), { ICON: 0, BAMO: 0, Total: 0, Puntaje: 0, ACTIVAS: 0 });
            try { window.__statsDisplayRows = displayRows.slice(); } catch(_) {}
            try {
              const chartDate = (window.__porcentajeFecha instanceof Date && !Number.isNaN(window.__porcentajeFecha.getTime()))
                ? window.__porcentajeFecha
                : null;
              const sameMonth = chartDate
                && chartDate.getFullYear() === targetMonth.getFullYear()
                && chartDate.getMonth() === targetMonth.getMonth();
              if (sameMonth && typeof renderPorcentajeTeams === 'function') {
                const clonedRows = displayRows.map(row => ({ ...row }));
                try { window.__porcIsInitializing = false; } catch(_){ }
                renderPorcentajeTeams(clonedRows);
              }
            } catch(syncErr) {
              console.warn('[TABLA] No se pudo sincronizar Porcentaje de Activación con la tabla', syncErr);
            }
          } catch(e) { console.warn('[ESTADISTICAS] Final ordering error:', e); }
        })();

        // Encabezado: siempre mostrar MES (mm/yyyy) para esta tabla (izquierda)
        const mesTexto = `${String(targetMonth.getMonth()+1).padStart(2,'0')}/${targetMonth.getFullYear()}`;
        const encabezadoTitulo = `VENTAS POR MERCADO Y PUNTAJE DEL MES (${mesTexto})`;

        // Generar HTML de la tabla de equipos
        let html = `
          <div class="conversion-card">
            <div class="conversion-title-wrapper">
              <button id="month-prev" class="filter-button" class="filter-button" title="Mes anterior">◀</button>
              <div id="tabla-mes-titulo" class="conversion-title">${encabezadoTitulo}</div>
              <button id="month-next" class="filter-button" class="filter-button" title="Mes siguiente">▶</button>
            </div>
            <div style="display:flex; justify-content:flex-end; margin:8px 0 6px; gap:8px;">
              <button id="btn-detalle-mensual" class="filter-button" class="filter-button">Ver detalle</button>
              <button id="btn-flip-monthly" class="filter-button" title="Ver gráfica" class="filter-button">↻</button>
            </div>
            <div class="flip-viewport" id="month-flip-local">
              <div class="flip-scene">
                <div class="flip-face front" id="month-front-face">
                  <div class="conv-two-col">
                    <div class="conv-left">
                      <table class="sales-table">
                        <thead>
                          <tr>
                            <th>EQUIPO</th>
                            <th>ICON</th>
                            <th>BAMO</th>
                            <th>TOTAL</th>
                            <th>PUNTAJE</th>
                          </tr>
                        </thead>
                        <tbody>
                          ${(!fallbackTeamData || fallbackTeamData.length === 0) ? `
                            <tr>
                              <td colspan="5" >
                                No hay datos disponibles para la fecha seleccionada
                              </td>
                            </tr>
                          ` : (fallbackTeamData || []).map(team => `
                            <tr>
                              <td>${team.name}</td>
                              <td>${team.ICON || 0}</td>
                              <td>${team.BAMO || 0}</td>
                              <td>${team.Total || 0}</td>
                              <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                            </tr>
                          `).join('')}
                          ${ (fallbackTeamData && fallbackTeamData.length > 0) ? `
                            <tr class="total-row">
                              <td>TOTAL</td>
                              <td>${totals.ICON}</td>
                              <td>${totals.BAMO}</td>
                              <td>${totals.Total}</td>
                              <td>${Number(totals.Puntaje).toFixed(2)}</td>
                            </tr>
                          ` : ''}
                        </tbody>
                      </table>
                    </div>
                    <div class="conv-right">
                      <div class="mini-card">
                        <table class="mini-table">
                          <thead>
                            <tr>
                              <th>TEAM LINEAS</th>
                              <th>ICON</th>
                            </tr>
                          </thead>
                          <tbody>
                            ${lineasData.map(r => `
                              <tr>
                                <td>${r.name}</td>
                                <td>${r.ICON || 0}</td>
                              </tr>
                            `).join('')}
                            <tr class="total">
                              <td>TOTAL</td>
                              <td class="total-icon">${lineasTotalICON}</td>
                            </tr>
                          </tbody>
                        </table>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="flip-face back">
                  <div class="chart-wrapper">
                    <canvas id="monthly-team-chart"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;
        
    // Asignar el HTML generado al elemento raíz (mostrar la tabla de conversión)
    root.innerHTML = html;
        // Overlay + handler del botón ↻ (mostrar gráfica en el mismo contenedor)
        try {
          const card = root.querySelector('.conversion-card');
          if (card && !card.querySelector('.month-chart-overlay')) {
            card.insertAdjacentHTML(
              'beforeend',
              '<div class="month-chart-overlay"><div class="chart-wrapper"><canvas id="monthly-team-chart"></canvas></div></div>'
            );
          }
          const flipBtn = document.getElementById('btn-flip-monthly');
          if (flipBtn && card) {
            // Single, robust handler: toggle using helper (if present), then create/destroy chart
            flipBtn.onclick = function(){
              try {
                // Use centralized helper to lock heights and toggle class when available
                if (typeof window.__toggleMonthlyFlip === 'function') {
                  window.__toggleMonthlyFlip();
                } else {
                  card.classList.toggle('show-chart');
                }

                // Defer chart creation/destruction slightly to allow layout/overlay to settle
                setTimeout(() => {
                  try {
                    const showing = card.classList.contains('show-chart');
                    const canvas = document.getElementById('monthly-team-chart');
                    if (showing) {
                      if (!canvas) return;
                      const rows = (Array.isArray(window.MonthDisplayRows) && window.MonthDisplayRows.length)
                        ? window.MonthDisplayRows
                        : (Array.isArray(window.__monthlyTeamData) ? window.__monthlyTeamData : []);
                      const labels = rows.map(r => String(r.name || ''));
                      const ventas  = rows.map(r => Number(r.Total   || 0));
                      const puntos  = rows.map(r => Number(r.Puntaje || 0));
                      try { if (window.__monthlyChart) { window.__monthlyChart.destroy(); window.__monthlyChart = null; } } catch(_) {}
                      const ctx = canvas.getContext('2d');
                      try {
                        window.__monthlyChart = new Chart(ctx, {
                          type: 'bar',
                          data: { labels, datasets: [
                            { label: 'Ventas',  data: ventas,  backgroundColor: 'rgba(37,99,235,0.85)' },
                            { label: 'Puntaje', data: puntos,  backgroundColor: 'rgba(239,68,68,0.85)' }
                          ] },
                          options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
                        });
                      } catch(chartErr){ console.warn('monthly chart create error', chartErr); }
                      try { if (window.__monthlyChart && typeof window.__monthlyChart.resize === 'function') window.__monthlyChart.resize(); } catch(_){}
                    } else {
                      // hiding -> destroy chart to free memory and avoid stray drawings
                      try { if (window.__monthlyChart) { window.__monthlyChart.destroy(); window.__monthlyChart = null; } } catch(_){}
                    }
                  } catch(err){ console.warn('deferred monthly overlay handler error', err); }
                }, 80);
              } catch(e) { console.warn('overlay error', e); }
            };
          }
        } catch(_) {}
        
        // Ajustar altura del contenedor flip local al alto real de la tabla
        try {
          // No extra handler here: the flip button's onclick above covers toggling and chart lifecycle
        } catch(_) {}
        // Hook flechas navegación mes - SIN recargar página
        try {
          const btnPrev = document.getElementById('month-prev');
          const btnNext = document.getElementById('month-next');
          if (btnPrev) {
            btnPrev.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              console.log('[TABLA] Navegando a mes anterior...');
              const next = new Date(window.__tablaMesFecha || targetMonth);
              next.setMonth(next.getMonth() - 1);
              loadConversionTableForMonth(next);
            });
            console.log('[MES] Botón anterior conectado (independiente)');
          } else {
            console.warn('[MES] Botón anterior NO encontrado');
          }
          if (btnNext) {
            btnNext.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              console.log('[TABLA] Navegando a mes siguiente...');
              const next = new Date(window.__tablaMesFecha || targetMonth);
              next.setMonth(next.getMonth() + 1);
              loadConversionTableForMonth(next);
            });
            console.log('[MES] Botón siguiente conectado (independiente)');
          } else {
            console.warn('[MES] Botón siguiente NO encontrado');
          }
        } catch(err) {
          console.error('[MES] Error al conectar flechas:', err);
        }
        
        // Filtro eliminado: no se requiere manejar eventos de filtrado
      } catch (e) {
        console.error('Error renderizando tabla de conversiÃ³n', e);
        console.log('Usando datos de prueba para la tabla de conversiÃ³n...');
        
        // Datos de prueba cuando falla la API
        const hoy = new Date();
        const fecha = hoy.toLocaleDateString('es-ES', { day:'2-digit', month:'2-digit', year:'numeric' });
        const fallbackTeamData = [
          { name: 'TEAM IRANIA', ICON: 8, BAMO: 7, Total: 15, Puntaje: '8.5' },
          { name: 'TEAM ROBERTO VELASQUEZ', ICON: 12, BAMO: 11, Total: 23, Puntaje: '9.2' },
          { name: 'TEAM BRYAN PLEITEZ', ICON: 9, BAMO: 9, Total: 18, Puntaje: '7.8' },
          { name: 'TEAM MARISOL BELTRAN', ICON: 6, BAMO: 6, Total: 12, Puntaje: '7.1' },
          { name: 'TEAM RANDAL MARTINEZ', ICON: 11, BAMO: 9, Total: 20, Puntaje: '8.9' },
          { name: 'TEAM LINEA', ICON: 4, BAMO: 4, Total: 8, Puntaje: '6.5' }
        ];

        // Generar HTML de la tabla con datos de prueba
        let html = `
          <div class="conversion-card">
            <div class="conversion-title-wrapper">
              <button id="month-prev" class="filter-button" title="Mes anterior">◀</button>
              <div id="tabla-mes-titulo" class="conversion-title">VENTAS POR MERCADO Y PUNTAJE DEL MES</div>
              <button id="month-next" class="filter-button" title="Mes siguiente">▶</button>
            </div>
            <div class="conv-two-col">
              <div class="conv-left">
                <table class="sales-table">
                  <thead>
                    <tr>
                      <th>EQUIPO</th>
                      <th>ICON</th>
                      <th>BAMO</th>
                      <th>TOTAL</th>
                      <th>PUNTAJE</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${fallbackTeamData.length === 0 ? `
                      <tr>
                        <td colspan="5" >
                          No hay datos disponibles para la fecha seleccionada
                        </td>
                      </tr>
                    ` : fallbackTeamData.map(team => `
                      <tr>
                        <td>${team.name}</td>
                        <td>${team.ICON || 0}</td>
                        <td>${team.BAMO || 0}</td>
                        <td>${team.Total || 0}</td>
                        <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                      </tr>
                    `).join('')}
                    ${fallbackTeamData.length > 0 ? `
                      <tr class="total-row">
                        <td>TOTAL</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(1)}</td>
                      </tr>
                    ` : ''}
                  </tbody>
                </table>
              </div>
              ${true ? `
              <div class="conv-right">
                <div class="mini-card">
                  <table class="mini-table">
                    <thead>
                      <tr>
                        <th>TEAM LINEAS</th>
                        <th>ICON</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${lineasData.map(r => `
                        <tr>
                          <td>${r.name}</td>
                          <td>${r.ICON || 0}</td>
                        </tr>
                      `).join('')}
                      <tr class="total">
                        <td>TOTAL</td>
                        <td class="total-icon">${lineasTotalICON}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              ` : ''}
            </div>DÃA (${fecha})</div>
            <div class="alert alert-warning mb-3" style="padding: 10px; margin-bottom: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; color: #856404; font-size: 0.9rem;">
              <i class="fas fa-exclamation-triangle me-2"></i>
              Mostrando datos de prueba (Error de conexiÃ³n con la base de datos)
            </div>
            <div >
              <div class="card">
                <h3></h3>
                <div id="conversion-table" class="conversion-grid">
                  <table class="sales-table">
                    <thead>
                      <tr>
                        <th>EQUIPO</th>
                        <th>ICON</th>
                        <th>BAMO</th>
                        <th>TOTAL</th>
                        <th>PUNTAJE</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${fallbackTeamData.map(team => `
                        <tr>
                          <td>${team.name}</td>
                          <td>${team.ICON || 0}</td>
                          <td>${team.BAMO || 0}</td>
                          <td>${team.Total || 0}</td>
                          <td class="score-col">${team.Puntaje || '0.0'}</td>
                        </tr>
                      `).join('')}
                      <tr class="total-row">
                        <td>TOTAL</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(1)}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        `;
        
    // Asignar el HTML generado al elemento raíz (mostrar la tabla de conversión)
    root.innerHTML = html;
        
        // Agregar evento al botÃ³n de filtrar
        const btnFiltrar = document.getElementById('btnFiltrarEquipos');
        if (btnFiltrar) {
          btnFiltrar.addEventListener('click', () => {
            const next = (window.__tablaMesFecha instanceof Date && !Number.isNaN(window.__tablaMesFecha.getTime()))
              ? new Date(window.__tablaMesFecha)
              : new Date();
            loadConversionTableForMonth(next, { updateUrl: false });
          });
        }
      }
    }

    // Variable para mantener la referencia al grÃ¡fico
    let ventasChart = null;
    
    // Función para verificar autenticación
    function checkAuth() {
      // Verificar si hay un usuario en sessionStorage o localStorage
      const user = JSON.parse(sessionStorage.getItem('user') || localStorage.getItem('user') || 'null');
      if (!user) {
        console.error('No se encontró sesión de usuario activa');
        window.location.href = '/login.html';
        return false;
      }
      // Acceso permitido para todos los usuarios autenticados
      console.log('Usuario autenticado con acceso a Estadísticas:', user.username || user.name);
      return true;
    }
    
    // FunciÃ³n para realizar peticiones autenticadas
    async function fetchWithAuth(url, options = {}) {
      if (!checkAuth()) return null;
      
      const defaultHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      };
      // Adjuntar token si está disponible (algunos endpoints lo requieren)
      try {
        const storedUser = sessionStorage.getItem('user') || localStorage.getItem('user');
        const user = storedUser ? JSON.parse(storedUser) : null;
        const token = (user && user.token) || localStorage.getItem('token') || sessionStorage.getItem('token');
        if (token) {
          defaultHeaders['Authorization'] = `Bearer ${token}`;
        }
      } catch(_) {}
      
      const response = await fetch(url, {
        ...options,
        headers: {
          ...defaultHeaders,
          ...(options.headers || {})
        },
        credentials: 'include' // Importante para enviar las cookies de autenticaciÃ³n
      });
      
      if (response.status === 401) {
        // No autorizado - redirigir al login
        console.error('Error de autenticaciÃ³n - Redirigiendo al login');
        window.location.href = '/login.html';
        return null;
      }
      
      return response;
    }
    
    function renderVentasPorEquipoChart(teamData) {
      const ctx = document.getElementById('chart-ventas-dia');
      if (!ctx) return;

      // Filtrar equipos sin ventas para no saturar el gráfico
      // Filtrar equipos para fines de semana: solo mostrar si Total > 0
      const today = new Date();
      const isWeekend = today.getDay() === 0 || today.getDay() === 6; // 0 = domingo, 6 = sábado
      const filteredDayTeams = isWeekend ? teamData.filter(team => team.Total > 0) : teamData;
      const labels = filteredDayTeams.map(t => (t.name || t._id || 'SIN EQUIPO'));
      const data = filteredDayTeams.map(t => t.Total);

      // Paleta de colores atractiva (más colores si es necesario)
      const colors = [
        '#22b3ec', '#3498db', '#5dade2', '#85c1e9', '#aed6f1',
        '#36c2cf', '#48c9b0', '#76d7c4', '#a3e4d7', '#d1f2eb',
        '#f39c12', '#e67e22', '#e74c3c', '#9b59b6', '#34495e'
      ];

      // Destruir el grÃ¡fico anterior si existe para evitar conflictos
      if (window.ventasPorEquipoChart) {
        window.ventasPorEquipoChart.destroy();
      }

      window.ventasPorEquipoChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ventas por Equipo',
            data: data,
            backgroundColor: colors.slice(0, data.length),
            borderColor: '#fff',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  let label = context.label || '';
                  if (label) {
                    label += ': ';
                  }
                  if (context.parsed !== null) {
                    label += context.parsed;
                  }
                  return label + ' ventas';
                }
              }
            }
          }
        }
      });
    }

    // Nuevo: renderiza un donut que muestra % de activación (ICON vs resto)
    function renderPorcentajeActivacion(teamData) {

      const canvas = document.getElementById('chart-porcentaje-activacion');
      showChartSpinner(canvas, true);
      try {
        if (!canvas) return;

        // Si no se pasan datos, intentar cargar del cache
        if (!teamData || !Array.isArray(teamData) || teamData.length === 0) {
          const cached = localStorage.getItem('cache_porcentaje_activacion');
          if (cached) {
            try { teamData = JSON.parse(cached); } catch(_) { teamData = []; }
          }
        } else {
          // Guardar en cache los datos actuales
          try { localStorage.setItem('cache_porcentaje_activacion', JSON.stringify(teamData)); } catch(_){}
        }

        teamData = Array.isArray(teamData) ? teamData : [];
        const totalICON = teamData.reduce((s, t) => s + (Number(t.ICON || 0)), 0);
        const total = teamData.reduce((s, t) => s + (Number(t.Total || 0)), 0) || 0;
        const active = totalICON;
        const inactive = Math.max(0, total - totalICON);

        // Si no hay datos (total === 0) mostramos el último cache o un placeholder
        if (total === 0) {
          // Si hay cache previo, mostrarlo
          const cached = localStorage.getItem('cache_porcentaje_activacion');
          if (cached) {
            try {
              const cachedData = JSON.parse(cached);
              if (Array.isArray(cachedData) && cachedData.length > 0) {
                showChartSpinner(canvas, false);
                return renderPorcentajeActivacion(cachedData);
              }
            } catch(_){}
          }
          // Si no hay cache, limpiar canvas
          try { if (window.porcentajeActivacionChart) { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } } catch(_){ }
          try {
            const ctxClear = canvas.getContext('2d');
            ctxClear.clearRect(0,0,canvas.width, canvas.height);
            try { canvas.style.display = 'none'; } catch(_){}
          } catch(_){ }
          // Mostrar mensaje de no datos
          let msg = document.getElementById('porc-no-data-msg');
          if (!msg) {
            msg = document.createElement('div');
            msg.id = 'porc-no-data-msg';
            msg.style = 'text-align:center;color:#64748b;font-size:1rem;padding:30px 0;';
            canvas.parentElement.appendChild(msg);
          }
          msg.textContent = 'Sin datos para este mes.';
          showChartSpinner(canvas, false);
          return;
        } else {
          // Ocultar mensaje si hay datos
          let msg = document.getElementById('porc-no-data-msg');
          if (msg) msg.remove();
        }

        // Destruir instancia previa si existe (limpiar labels primero)
        if (window.porcentajeActivacionChart) try { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } catch(_){ }

        const ctx = canvas.getContext('2d');
        try { canvas.style.display = 'block'; } catch(_){}
        // Crear gráfico (sin número central) - mostramos sólo el donut
        const donutPlugins = [];
        if (window.__chartDataLabelsRegistered !== true) {
          const candidate = window.__chartDataLabelsPlugin
            || (typeof ChartDataLabels !== 'undefined' && (ChartDataLabels.default || ChartDataLabels));
          if (candidate) {
            donutPlugins.push(candidate);
          }
        }

        window.porcentajeActivacionChart = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: ['Activadas', 'No activadas'],
            datasets: [{
              data: [active, inactive],
              backgroundColor: ['#588A87', '#DFD9CA'],
              borderColor: ['#fff','#fff'],
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: '65%',
            plugins: {
              legend: { position: 'right' },
              tooltip: { callbacks: { label: function(ctx){ return `${ctx.label}: ${ctx.parsed} (${(total?((ctx.parsed/total)*100):0).toFixed(1)}%)`; } } },
              datalabels: {
                display: true,
                color: '#1f3b63',
                font: { weight: 'bold', size: 14 },
                anchor: 'end',
                align: 'end',
                offset: 8,
                formatter: function(value, context) {
                  // Mostrar valor absoluto y porcentaje
                  const percent = total ? ((value/total)*100).toFixed(1) : '0.0';
                  return `${value} (${percent}%)`;
                }
              }
            }
          },
          plugins: donutPlugins
        });

        // Forzar resize por si el canvas parent cambió de tamaño
        try { if (window.porcentajeActivacionChart && typeof window.porcentajeActivacionChart.resize === 'function') window.porcentajeActivacionChart.resize(); } catch(_){}
        showChartSpinner(canvas, false);
      } catch (e) { showChartSpinner(canvas, false); console.warn('renderPorcentajeActivacion error', e); }
    }


    // Spinner overlay helper (reutilizable)
    function showChartSpinner(canvas, show) {
      try {
        if (!canvas) return;
        const wrapper = canvas.parentElement || document.body;
        if (wrapper && getComputedStyle(wrapper).position === 'static') {
          wrapper.style.position = 'relative';
        }
        
        let overlay = wrapper.querySelector('.chart-spinner-overlay');
        if (show) {
          if (!overlay) {
            overlay = document.createElement('div');
            overlay.className = 'chart-spinner-overlay';
            overlay.innerHTML = '<div class="porc-spinner" aria-hidden="true"></div>';
            overlay.style.position = 'absolute';
            overlay.style.inset = '0';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '30';
            wrapper.appendChild(overlay);
          }
        } else {
          if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
        }
      } catch(e){ console.warn('showChartSpinner error', e); }
    }

    function ensureChartFitsContainer(chart, canvas) {
      try {
        if (!chart || !canvas) return;
        const wrapper = canvas.parentElement;
        if (!wrapper) return;

        const id = canvas.id || '';
        if (!window.__chartResizeObservers) window.__chartResizeObservers = {};

        const resizeNow = () => {
          try {
            if (typeof chart.resize === 'function') chart.resize();
            if (typeof chart.update === 'function') chart.update('none');
          } catch (_) {}
        };

        // Reintentos por timing del layout (sidebar, fuentes, etc.)
        requestAnimationFrame(() => requestAnimationFrame(resizeNow));
        setTimeout(resizeNow, 250);
        setTimeout(resizeNow, 900);

        if (id && window.__chartResizeObservers[id]) return;

        if (typeof ResizeObserver !== 'undefined') {
          const ro = new ResizeObserver(() => resizeNow());
          ro.observe(wrapper);
          if (id) window.__chartResizeObservers[id] = ro;
        }
      } catch (e) {
        console.warn('ensureChartFitsContainer error', e);
      }
    }

    // Renderiza un gráfico de barras con ventas activas por equipo
    function renderVentasActivasMes(teamData) {
      try {
        console.log('[VENTAS ACTIVAS] Datos recibidos:', teamData);
        const canvas = document.getElementById('chart-ventas-activas-mes');
        showChartSpinner(canvas, true);
        setTimeout(() => { // Simula carga asíncrona, reemplaza por fetch real si aplica
          try {
            const listEl = document.getElementById('ventas-activas-team-list');
            const noteEl = document.getElementById('ventas-activas-note');
            // Si no se pasan datos, intentar cargar del cache
            if (!teamData || !Array.isArray(teamData) || teamData.length === 0) {
              const cached = localStorage.getItem('cache_ventas_activas_mes');
              if (cached) {
                try { teamData = JSON.parse(cached); } catch(_) { teamData = []; }
              }
            } else {
              // Guardar en cache los datos actuales
              try { localStorage.setItem('cache_ventas_activas_mes', JSON.stringify(teamData)); } catch(_){}
            }
            if (!canvas) {
              console.warn('[VENTAS ACTIVAS] Canvas no encontrado');
              showChartSpinner(canvas, false);
              return;
            }
            // Procesar datos
            teamData = Array.isArray(teamData) ? teamData : [];
            const EQUIPOS_ORDER = ['Pleitez', 'Roberto', 'Marisol', 'Johana', 'Irania', 'JONATHAN F', 'LUIS G'];
            const mapByName = new Map();
            for (const team of teamData) {
              const key = String(team.name || '').trim().toUpperCase();
              if (!mapByName.has(key)) {
                mapByName.set(key, {
                  name: team.name,
                  ACTIVAS: Number(team.ACTIVAS || 0),
                  Total: Number(team.Total || 0)
                });
              } else {
                const existing = mapByName.get(key);
                existing.ACTIVAS = (existing.ACTIVAS || 0) + Number(team.ACTIVAS || 0);
                existing.Total = (existing.Total || 0) + Number(team.Total || 0);
              }
            }
            for (const teamName of EQUIPOS_ORDER) {
              const key = teamName.trim().toUpperCase();
              if (!mapByName.has(key)) {
                mapByName.set(key, {
                  name: teamName,
                  ACTIVAS: 0,
                  Total: 0
                });
              }
            }
            const filtered = Array.from(mapByName.values());
            const labels = filtered.map(t => t.name);
            const dataVals = filtered.map(t => t.ACTIVAS);
            // Asegurar que el canvas esté visible
            canvas.style.display = 'block';
            // Eliminar mensaje de sin datos si existe
            let msg = document.getElementById('ventas-activas-no-data-msg');
            if (msg) msg.remove();
            if (window.ventasActivasMesChart) try { window.ventasActivasMesChart.destroy(); window.ventasActivasMesChart = null; } catch(_){ }
            const ctx = canvas.getContext('2d');
            window.ventasActivasMesChart = new Chart(ctx, {
              type: 'bar',
              data: {
                labels,
                datasets: [{
                  label: 'Ventas activas',
                  data: dataVals,
                  backgroundColor: '#10b981',
                  borderRadius: 6,
                  maxBarThickness: 38
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                  padding: { top: 30, right: 10, bottom: 10, left: 10 }
                },
                plugins: { 
                  legend: { display: false },
                  tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    padding: 12,
                    cornerRadius: 8,
                    displayColors: true,
                    callbacks: {
                      label: function(context) {
                        const idx = context.dataIndex;
                        const activas = dataVals[idx];
                        const total = filtered[idx].Total;
                        return `Activas: ${activas} de ${total}`;
                      }
                    }
                  },
                  datalabels: {
                    display: (context) => {
                      const raw = context?.dataset?.data?.[context.dataIndex];
                      const n = Number(raw);
                      return !Number.isNaN(n) && n !== 0;
                    },
                    anchor: 'end',
                    align: 'top',
                    color: '#1f3b63',
                    font: {
                      weight: 'bold',
                      size: 13
                    },
                    offset: 4,
                    formatter: function(value, context) {
                      return formatMetricValue(value);
                    }
                  }
                }
              },
              plugins: [
                {
                  id: 'barShadow3D',
                  beforeDatasetDraw: (chart) => {
                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;
                  },
                  afterDatasetDraw: (chart) => {
                    chart.ctx.restore();
                  }
                }
              ]
            });
            ensureChartFitsContainer(window.ventasActivasMesChart, canvas);
            // Forzar un resize para asegurar que el gráfico se renderice correctamente
            try {
              if (window.ventasActivasMesChart && typeof window.ventasActivasMesChart.resize === 'function') {
                setTimeout(() => {
                  try {
                    window.ventasActivasMesChart.resize();
                    window.ventasActivasMesChart.update('none');
                  } catch(_) {}
                }, 100);
              }
            } catch(_) {}
            console.log('[VENTAS ACTIVAS] Gráfico renderizado exitosamente');
            showChartSpinner(canvas, false);
          } catch (e) { 
            showChartSpinner(canvas, false);
            console.error('[VENTAS ACTIVAS] Error al renderizar:', e); 
          }
        }, 0); // Quitar el setTimeout si ya es asíncrono
      } catch (e) { 
        showChartSpinner(document.getElementById('chart-ventas-activas-mes'), false);
        console.error('[VENTAS ACTIVAS] Error general:', e); 
      }
    }

    // --- Productos vendidos en el mes: helpers y gráfico ---
    const SOLD = new Set(['vendido','cerrado','aprobado','approved','sold','closed']);
    function pickDateForProduct(lead){
      const cand = lead && (lead.dia_venta || lead.diaVenta || lead.fecha_venta || lead.fechaVenta || lead.fecha_contratacion || lead.fechaContrato || lead.fecha_registro || lead.fechaRegistro || lead.createdAt || lead.created_at || lead.createdOn || lead.created_on || lead.fecha || lead.date || lead.updatedAt || lead.updated_at);
      if (!cand) return null;

      const ensureMidday = (dt) => {
        if (!(dt instanceof Date) || Number.isNaN(dt.getTime())) return null;
        return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), 12, 0, 0, 0);
      };

      if (cand instanceof Date) {
        return ensureMidday(cand);
      }

      if (typeof cand === 'number') {
        // Diferenciar segundos vs milisegundos
        const val = cand < 1e12 ? cand * 1000 : cand;
        return ensureMidday(new Date(val));
      }

      const str = String(cand).trim();
      if (!str) return null;

      // yyyy-mm-dd
      if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
        const [y, m, d] = str.split('-').map(Number);
        return new Date(y, m - 1, d, 12, 0, 0, 0);
      }

      // yyyy-mm-ddTHH:mm... (ISO)
      if (/^\d{4}-\d{2}-\d{2}T/.test(str)) {
        const isoDate = new Date(str);
        return ensureMidday(isoDate);
      }

      // dd/mm/yyyy o dd-mm-yyyy
      if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(str)) {
        const parts = str.split(/[\/\-]/).map(Number);
        const [d, m, y] = parts;
        return new Date(y, m - 1, d, 12, 0, 0, 0);
      }

      const parsed = new Date(str);
      return ensureMidday(parsed);
    }

    function isInProductsMonth(date, referenceDate){
      if (!(referenceDate instanceof Date) || Number.isNaN(referenceDate.getTime())) return false;
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) return false;
      return date.getFullYear() === referenceDate.getFullYear() && date.getMonth() === referenceDate.getMonth();
    }

    let productsChartRef = null;
    function renderProducts(leads){
      const canvas = document.getElementById('productsChart');
      showChartSpinner(canvas, true);
      setTimeout(() => { // Simula carga asíncrona, reemplaza por fetch real si aplica
        try{
          leads = Array.isArray(leads) ? leads : [];
          const now = new Date();
          now.setHours(12,0,0,0);
          const monthSales = leads.filter(l => {
            const d = pickDateForProduct(l);
            return d ? isInProductsMonth(d, now) : false;
          });
          const getProd = (l) => {
            const v = l.servicios_texto || l.tipo_servicios || l.tipo_servicio || l.servicios || l.producto || (l.producto && l.producto.nombre) || l.product || l.service || l.servicio || '';
            return v ? String(v).replace(/[-_]/g,' ').toUpperCase() : 'SIN PRODUCTO';
          };
          const counts = {};
          monthSales.forEach(l => { const k = getProd(l); if (!k) return; counts[k] = (counts[k]||0) + 1; });
          const entries = Object.entries(counts).sort((a,b) => b[1] - a[1]);
          const labels = entries.map(e => e[0]);
          const dataVals = entries.map(e => e[1]);
          if (!canvas) return;
          // Si todos los valores son 0 o no hay datos, mostrar mensaje de sin datos
          if (dataVals.length === 0 || dataVals.every(v => v === 0)) {
            try { if (productsChartRef) productsChartRef.destroy(); } catch(_){}
            try {
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0,0,canvas.width,canvas.height);
              canvas.style.display = 'none';
            } catch(_){}
            let msg = document.getElementById('products-no-data-msg');
            if (!msg) {
              msg = document.createElement('div');
              msg.id = 'products-no-data-msg';
              msg.style = 'text-align:center;color:#64748b;font-size:1rem;padding:30px 0;';
              canvas.parentElement.appendChild(msg);
            }
            msg.textContent = 'Sin datos para este mes.';
            showChartSpinner(canvas, false);
            return;
          } else {
            let msg = document.getElementById('products-no-data-msg');
            if (msg) msg.remove();
          }
          const ctx = canvas.getContext('2d');
          if (productsChartRef) try { productsChartRef.destroy(); } catch(_){}
          productsChartRef = new Chart(ctx, {
            type: 'bar',
            data: { labels, datasets: [{ label: 'Cantidad', data: dataVals, backgroundColor: 'rgba(54,162,235,.7)', borderColor: 'rgba(54,162,235,1)', borderWidth: 1, borderRadius: 4 }] },
            options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } }, x: { ticks: { autoSkip: false, maxRotation: 45, minRotation: 45 } } } }
          });
        } catch (e) { console.warn('renderProducts error', e); }
        showChartSpinner(canvas, false);
      }, 0); // Quitar el setTimeout si ya es asíncrono
    }

    // Variables para el control de navegación de productos por mes
    let currentProductsDate = new Date();
    function normalizeCurrentProductsDate() {
      if (!(currentProductsDate instanceof Date) || Number.isNaN(currentProductsDate.getTime())) {
        currentProductsDate = new Date();
      }
      currentProductsDate.setDate(1);
      currentProductsDate.setHours(12, 0, 0, 0);
    }
    normalizeCurrentProductsDate();
    const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];

    async function loadProductsChart(){
      try{
        if (!checkAuth()) return;
        
        // Actualizar título del mes primero para feedback inmediato
        const titleElement = document.getElementById('products-month-title');
        if (titleElement) {
          titleElement.textContent = `PRODUCTOS VENDIDOS EN ${monthNames[currentProductsDate.getMonth()].toUpperCase()} ${currentProductsDate.getFullYear()}`;
        }

        // Construir rango de fechas para el mes seleccionado
        const startDate = new Date(currentProductsDate.getFullYear(), currentProductsDate.getMonth(), 1);
        const endDate = new Date(currentProductsDate.getFullYear(), currentProductsDate.getMonth() + 1, 0);
        const startStr = startDate.toISOString().split('T')[0];
        const endStr = endDate.toISOString().split('T')[0];

        console.log('Cargando productos para:', monthNames[currentProductsDate.getMonth()], currentProductsDate.getFullYear());
        console.log('Rango de fechas:', { startStr, endStr });

        const resp = await fetchWithAuth(`/api/leads?fechaInicio=${startStr}&fechaFin=${endStr}&limit=5000`);
        if (!resp || !resp.ok) { 
          console.warn('loadProductsChart: error en la respuesta de /api/leads'); 
          showNoDataMessage();
          return; 
        }
        
        const json = await resp.json();
        const leads = Array.isArray(json) ? json : (Array.isArray(json.data) ? json.data : (Array.isArray(json.leads) ? json.leads : []));
        console.log(`Obtenidos ${leads.length} leads para el mes`);

        // Filtrar ventas del mes seleccionado usando la zona operativa
        const referenceDate = new Date(currentProductsDate);
        referenceDate.setHours(12, 0, 0, 0);
        const monthSales = leads.filter(l => {
          const d = pickDateForProduct(l);
          return d ? isInProductsMonth(d, referenceDate) : false;
        });
        console.log(`Filtrados ${monthSales.length} ventas para el mes`);

        if (monthSales.length === 0) {
          showNoDataMessage();
          return;
        }

        // Contar productos
        const counts = {};
        monthSales.forEach(l => {
          const prod = l.servicios_texto || l.tipo_servicios || l.tipo_servicio || l.servicios || 
                      l.producto || (l.producto && l.producto.nombre) || l.product || l.service || 
                      l.servicio || 'SIN PRODUCTO';
          const key = prod ? String(prod).replace(/[-_]/g,' ').toUpperCase() : 'SIN PRODUCTO';
          counts[key] = (counts[key] || 0) + 1;
        });

        // Ordenar por cantidad
        const entries = Object.entries(counts).sort((a,b) => b[1] - a[1]);
        const labels = entries.map(e => e[0]);
        const dataVals = entries.map(e => e[1]);

        // Actualizar gráfico
        const canvas = document.getElementById('productsChart');
        if (!canvas) return;

        if (productsChartRef) {
          productsChartRef.destroy();
        }

        productsChartRef = new Chart(canvas.getContext('2d'), {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              label: 'Cantidad',
              data: dataVals,
              backgroundColor: 'rgba(54,162,235,.7)',
              borderColor: 'rgba(54,162,235,1)',
              borderWidth: 1,
              borderRadius: 4
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
              padding: { top: 30, right: 10, bottom: 10, left: 10 }
            },
            plugins: {
              legend: { display: false },
              title: {
                display: true,
                text: `Total: ${dataVals.reduce((a,b) => a + b, 0)} ventas`,
                padding: {top: 10, bottom: 10},
                font: { size: 14, weight: 'bold' }
              },
              datalabels: {
                display: true,
                anchor: 'end',
                align: 'top',
                offset: 4,
                color: '#333',
                font: {
                  weight: 'bold',
                  size: 13
                },
                formatter: function(value) {
                  return formatMetricValue(value);
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: { stepSize: 1 }
              },
              x: {
                ticks: {
                  autoSkip: false,
                  maxRotation: 45,
                  minRotation: 45
                }
              }
            }
          }
          // ChartDataLabels ya está registrado globalmente desde el CDN
        });

      } catch(e) { 
        console.error('Error en loadProductsChart:', e);
        showNoDataMessage();
      }
    }

    // Función auxiliar para mostrar mensaje cuando no hay datos
    function showNoDataMessage() {
      const canvas = document.getElementById('productsChart');
      if (!canvas) return;

      if (productsChartRef) {
        productsChartRef.destroy();
      }

      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#666666';
      ctx.font = '14px Arial';
      ctx.fillText('No hay datos disponibles para este mes', canvas.width / 2, canvas.height / 2);
      ctx.restore();
    }
    

    // Función auxiliar para mostrar mensaje cuando no hay datos
    function showNoDataMessage() {
      const canvas = document.getElementById('productsChart');
      if (!canvas) return;

      if (productsChartRef) {
        productsChartRef.destroy();
      }

      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#666666';
      ctx.font = '14px Arial';
      ctx.fillText('No hay datos disponibles para este mes', canvas.width / 2, canvas.height / 2);
      ctx.restore();
    }

    // Configurar eventos de navegación después de que el DOM esté listo
    document.addEventListener('DOMContentLoaded', () => {
      const prevBtn = document.getElementById('products-prev');
      const nextBtn = document.getElementById('products-next');

      if (prevBtn) {
        prevBtn.addEventListener('click', () => {
          currentProductsDate.setMonth(currentProductsDate.getMonth() - 1);
          normalizeCurrentProductsDate();
          loadProductsChart();
        });
      }

      if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          currentProductsDate.setMonth(currentProductsDate.getMonth() + 1);
          normalizeCurrentProductsDate();
          loadProductsChart();
        });
      }
    });

    async function initCharts(){
      // Esta funciÃ³n se deja vacÃ­a intencionalmente para dar paso al nuevo grÃ¡fico de dona.
      console.log('initCharts ya no renderiza el grÃ¡fico de barras diario.');
    }
    
    // FunciÃ³n para renderizar el grÃ¡fico de ventas diarias
    function renderVentasDiarias(container, labels, data, isFallback) {
      if (!container) return;
      
      const warningHtml = isFallback ? `
        <div class="alert alert-warning mb-3" style="padding: 10px; margin-bottom: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; color: #856404;">
          <i class="fas fa-exclamation-triangle me-2"></i>
          Mostrando datos de prueba (Error de conexiÃ³n con la base de datos)
        </div>
      ` : '';
      
      container.innerHTML = `
        ${warningHtml}
        <canvas id="chart-ventas-diarias"></canvas>
      `;
      
      const canvas = container.querySelector('#chart-ventas-diarias');
      if (!canvas) {
        console.error('No se pudo crear el canvas para el grÃ¡fico de ventas diarias');
        return;
      }
      
      // Destruir grÃ¡fico anterior si existe
      if (window.ventasDiariasChart) {
        window.ventasDiariasChart.destroy();
      }
      
      // ConfiguraciÃ³n del grÃ¡fico
      const config = {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ventas',
            data: data,
            backgroundColor: 'rgba(34, 179, 236, 0.8)',
            borderColor: 'rgba(26, 144, 193, 1)',
            borderWidth: 1,
            borderRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: { top: 30, right: 10, bottom: 10, left: 10 }
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Ventas: ${context.raw}`;
                }
              }
            },
            datalabels: {
              display: true,
              anchor: 'end',
              align: 'top',
              color: '#1f3b63',
              font: {
                weight: 'bold',
                size: 13
              },
              formatter: function(value) {
                return formatMetricValue(value);
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'NÃºmero de ventas',
                font: {
                  weight: 'bold'
                }
              },
              ticks: {
                stepSize: 1,
                precision: 0
              }
            },
            x: {
              title: {
                display: true,
                text: 'Fechas',
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
        // ChartDataLabels ya está registrado globalmente desde el CDN
      };
      
      // Crear el grÃ¡fico
      window.ventasDiariasChart = new Chart(canvas, config);
    }
    

    // FunciÃ³n auxiliar para renderizar el grÃ¡fico
    function renderChart(container, labels, data, isFallback) {
      if (!container) return;
      
      const warningHtml = isFallback ? `
        <div class="alert alert-warning mb-3" style="padding: 10px; margin-bottom: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; color: #856404;">
          <i class="fas fa-exclamation-triangle me-2"></i>
          Mostrando datos de prueba (Error de conexiÃ³n con la base de datos)
        </div>
      ` : '';
      
      container.innerHTML = `
        ${warningHtml}
        <canvas id="chart-ventas-canvas"></canvas>
      `;
      
      const canvas = container.querySelector('#chart-ventas-canvas');
      if (!canvas) {
        console.error('No se pudo crear el canvas');
        return;
      }
      
      // Destruir grÃ¡fico anterior si existe
      if (window.ventasChart) {
        window.ventasChart.destroy();
      }
      
      // Crear nuevo grÃ¡fico
      const chartConfig = {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ventas',
            backgroundColor: '#22b3ec',
            borderColor: '#1a90c1',
            borderWidth: 1,
            borderRadius: 6,
            data: data
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: { top: 30, right: 10, bottom: 10, left: 10 }
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Ventas: ${context.raw}`;
                }
              }
            },
            datalabels: {
              display: true,
              anchor: 'end',
              align: 'top',
              color: '#1f3b63',
              font: {
                weight: 'bold',
                size: 13
              },
              formatter: function(value) {
                return formatMetricValue(value);
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'NÃºmero de ventas',
                font: { weight: 'bold' }
              }
            },
            x: {
              title: {
                display: true,
                text: 'Equipos',
                font: { weight: 'bold' }
              },
              ticks: {
                autoSkip: false,
                maxRotation: 45,
                minRotation: 45
              }
            }
          }
        }
        // ChartDataLabels ya está registrado globalmente desde el CDN
      };
      
      try {
        window.ventasChart = new Chart(canvas, chartConfig);
        console.log('GrÃ¡fico creado exitosamente');
      } catch (error) {
        console.error('Error al crear el grÃ¡fico:', error);
        container.innerHTML = `
          <div class="alert alert-danger">
            <i class="fas fa-exclamation-triangle me-2"></i>
            Error al crear el grÃ¡fico: ${error.message}
          </div>
        `;
      }

      // Renderizar tabla de ConversiÃ³n por equipo
      console.log('Buscando elemento con ID conversion-table...');
      const convRoot = document.getElementById('conversion-table');
      console.log('Elemento encontrado:', convRoot);
      if (convRoot) {
        console.log('Elemento conversion-table encontrado, procediendo a renderizar...');
        // Establecer fechas por defecto (Ãºltimos 30 dÃ­as)
        const fechaFin = new Date();
        const fechaInicio = new Date();
        fechaInicio.setDate(fechaInicio.getDate() - 30);
        
        // Formatear fechas para los inputs
        const fechaInicioInput = document.getElementById('fechaInicio');
        const fechaFinInput = document.getElementById('fechaFin');
        
        if (fechaInicioInput) fechaInicioInput.valueAsDate = fechaInicio;
        if (fechaFinInput) fechaFinInput.valueAsDate = fechaFin;
        
        // Cargar datos del mes actual sin mutar la URL
        loadConversionTableForMonth(window.__tablaMesFecha, { updateUrl: false });
      }

      const rendCtx = document.getElementById('chart-rendimiento-mes');
      if (rendCtx) {
        new Chart(rendCtx, {
          type: 'line',
          data: {
            labels: ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'],
            datasets: [{
              label: 'Puntos',
              data: Array.from({length: 12}, () => rand(10, 40)),
              borderColor: '#10b981',
              backgroundColor: 'rgba(16,185,129,0.12)',
              fill: true,
              tension: 0.35
            }]
          },
          options: { responsive: true, maintainAspectRatio: false }
        });
      }
    }

    function initializeApp() {
      console.log('Inicializando aplicación...');
      
      // Verificar que Chart esté disponible
      if (typeof Chart === 'undefined') {
        console.error('Error: Chart.js no se ha cargado correctamente');
        const chartContainer = document.querySelector('.chart-wrapper');
        if (chartContainer) {
          chartContainer.innerHTML = `
            <div class="alert alert-danger">
              <i class="fas fa-exclamation-triangle me-2"></i>
              Error: No se pudo cargar la biblioteca de gráficos. Por favor, recarga la página.
            </div>
          `;
        }
        return;
      }
      
      console.log('Chart.js cargado correctamente:', Chart.version);
      
      // Inicializar gráficos
      initCharts();
      
      // Configurar botón de actualización
      const btn = document.getElementById('btn-refresh');
      if (btn) {
        btn.addEventListener('click', () => {
          console.log('Actualizando gráficos...');
          initCharts();
        });
      }

      // Inicializar tabla de conversión después de que el DOM esté listo
      setTimeout(() => {
        initConversionTable();
        loadDayData();
        
        // Cargar gráfico de Porcentaje de Activación
        try { 
          console.log('[INIT] Cargando gráfico de Porcentaje de Activación...');
          if (typeof loadPorcentajeForMonth === 'function') {
            loadPorcentajeForMonth(new Date());
          } else {
            console.error('[INIT] loadPorcentajeForMonth no está definida');
          }
        } catch(e) { 
          console.error('[INIT] Error cargando Porcentaje de Activación:', e); 
        }
        
        try { prepareMonthDetails(); } catch(_){ }
        // Inyectar el botón dentro del contenedor mensual cuando esté renderizado
  try { injectMonthlyDetailButton(); } catch(_){ }
  // Inyectar botón flip para la tarjeta del DÍA
  try { injectDayFlipButton(); } catch(_){ }
    // Inyectar flechas de navegación para la tarjeta de Porcentaje de Activacion
    try { if (typeof window.injectPorcentajeNavButtons === 'function') window.injectPorcentajeNavButtons(); } catch(_){ }
    // mark porcentaje loader as initializing so we don't render placeholder charts
    try { window.__porcIsInitializing = true; } catch(_){}
        // Cargar gráfico de Ventas Activas con navegación independiente
        try {
          if (typeof loadVentasActivasForMonth === 'function') {
            loadVentasActivasForMonth(new Date());
          } else {
            console.error('[INIT] loadVentasActivasForMonth no está definida');
          }
        } catch (e) {
          console.error('[INIT] Error cargando Ventas Activas:', e);
        }
        // Asegurar barra de toggles del DÍA aún si el render cambió
        try { ensureDayTogglesFallback(); } catch(_){ }
        // Agregar tabs Día/Mes a ambas tarjetas
        try { ensureStatsTabs(); } catch(_){ }
        // Cargar gráfica de Productos vendidos en el mes
        try { loadProductsChart(); } catch(_){ }
        // Igualar alturas entre la gráfica izquierda y la tarjeta de productos para evitar espacios
        try { setTimeout(() => { try { equalizeVentasProductsHeights(); } catch(_){} }, 300); } catch(_){}
      }, 200); // Delay para asegurar que el DOM esté listo
    }

  // Igualar alturas de las dos tarjetas (Ventas vs Productos) para evitar espacio en blanco
  function equalizeVentasProductsHeights(){
    try{
      const row = document.getElementById('ventas-products-row'); if (!row) return;
      const left = row.querySelector('.graph-container');
      const right = row.querySelector('.chart-wrapper');
      if (!left || !right) return;
      const h = left.clientHeight;
      right.style.height = h + 'px';
      // also ensure canvas fills
      const cvs = right.querySelector('canvas'); if (cvs) { cvs.style.width='100%'; cvs.style.height='100%'; }
    } catch(e){ console.warn('equalizeVentasProductsHeights error', e); }
  }
  window.addEventListener('resize', () => { try{ equalizeVentasProductsHeights(); }catch(_){} });

    // Deshabilitado: ya no se inyectan toggles fuera del modal
    function ensureDayTogglesFallback(){ return; }
    // ====== MODAL DETALLE DÍA ======
    // Estilos básicos del modal (inline para no depender de CSS externo)
    (function ensureModalStyles(){
      const css = `
      .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
      .modal{background:#fff;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.2);max-width:960px;width:92%;max-height:80vh;overflow:auto}
      .modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e2e8f0;font-weight:800}
      .close-btn{border:none;background:#e11d48;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
      .table-compact{width:100%;border-collapse:collapse;font-size:.9rem}
      .table-compact th,.table-compact td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left}
      .table-compact th{background:#1f3b63;color:#fff}
      .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
      `;
      const s = document.createElement('style'); s.textContent = css; document.head.appendChild(s);
    })();

    // Force-visible helper CSS (used as a robust fallback to make front face/table visible)
    (function(){
      if (document.getElementById('flip-force-styles')) return;
      const css = `
        /* force-visible: used sparingly to nudge visibility without changing table layout
           avoid forcing display:block globally which breaks table/tr layout */
        .force-visible { visibility: visible !important; opacity: 1 !important; pointer-events: auto !important; transform: none !important; }
        .force-visible table { display: table !important; visibility: visible !important; opacity: 1 !important; }

        /* Stronger, scoped override: when the flip viewport is NOT flipped, ensure the front face
           is visible and interactive. This targets the transient race where CSS with
           .flip-front-hidden (which uses !important) may still be present or re-applied.
           Using :not(.is-flipped) and placing this style late in the document gives it
           the correct cascade precedence without affecting the flipped state. */
        #day-flip-local:not(.is-flipped) .flip-face.front { visibility: visible !important; opacity: 1 !important; pointer-events: auto !important; transform: none !important; }
        #day-flip-local:not(.is-flipped) .flip-face.front table { display: table !important; visibility: visible !important; opacity: 1 !important; }
      `;
      const s = document.createElement('style'); s.id = 'flip-force-styles'; s.textContent = css; document.head.appendChild(s);
    })();

    // Styles for the monthly overlay so showing the monthly chart doesn't change layout flow
    (function ensureMonthlyOverlayStyles(){
      if (document.getElementById('monthly-overlay-styles')) return;
      const css = `
        /* Ensure conversion card is a positioning context for the absolute overlay */
        .conversion-card { position: relative; }

        /* The overlay is absolutely positioned and hidden by default so it doesn't affect layout */
        .conversion-card .month-chart-overlay {
          position: absolute;
          inset: 0;
          display: none;
          padding: 12px;
          box-sizing: border-box;
          background: #fff;
          z-index: 5;
          align-items: center;
          justify-content: center;
        }

        /* When the card has show-chart, display the overlay as a flex container (no reflow) */
        .conversion-card.show-chart .month-chart-overlay { display: flex; }

        /* Ensure the inner chart wrapper fills the overlay */
        .month-chart-overlay .chart-wrapper { width: 100%; height: 100%; }

        /* Prevent the overlay from changing document flow when visible */
        .month-chart-overlay canvas { width: 100% !important; height: 100% !important; }
      `;
      const s = document.createElement('style'); s.id = 'monthly-overlay-styles'; s.textContent = css; document.head.appendChild(s);
    })();

    // Inyectar flechas en la tarjeta de Porcentaje de Activasion (solo íconos)
    window.injectPorcentajeNavButtons = function(attempt = 0){
      try {
        const topCharts = document.getElementById('top-charts');
        if (!topCharts) {
          if (attempt < 20) return setTimeout(() => window.injectPorcentajeNavButtons(attempt+1), 300);
          return;
        }
        // Buscar la tarjeta que contiene chart-porcentaje-activacion
        const canvas = document.getElementById('chart-porcentaje-activacion');
        if (!canvas) return;
        const card = canvas.closest('.card');
        if (!card) return;
        // No duplicar
        if (card.querySelector('.porc-nav')) return;
        const nav = document.createElement('div'); nav.className = 'porc-nav';
        const prev = document.createElement('button'); prev.className = 'porc-arrow'; prev.innerHTML = '◀';
        const next = document.createElement('button'); next.className = 'porc-arrow'; next.innerHTML = '▶';
        nav.appendChild(prev); nav.appendChild(next);
        // Insertar al inicio del header
        const header = card.querySelector('h3');
        if (header) header.parentNode.insertBefore(nav, header.nextSibling);

        // Handlers: navegar mes anterior/siguiente mediante ?m=YYYY-MM
        const urlParams = new URLSearchParams(location.search);
        const mParam = urlParams.get('m');
        let base;
        if (mParam && /^\d{4}-\d{2}$/.test(mParam)) {
          const [y,m] = mParam.split('-').map(Number); base = new Date(y, m-1, 15);
        } else {
          base = new Date();
        }
  // Wire to in-place loader (no full page reload)
  window.currentPorcMonth = base;
  prev.onclick = () => { try { window.shiftPorcMonth(-1); } catch(e){ console.warn(e); } };
  next.onclick = () => { try { window.shiftPorcMonth(1); } catch(e){ console.warn(e); } };
  // Auto-load porcentaje for the current month (if function available). If the loader
  // isn't defined yet, schedule a short retry so the chart appears without manual console call.
  try{
    if (typeof loadPorcentajeForMonth === 'function') {
      loadPorcentajeForMonth(base);
    } else {
      setTimeout(()=>{ try{ if (typeof loadPorcentajeForMonth === 'function') loadPorcentajeForMonth(base); }catch(_){}} , 250);
    }
  }catch(_){ }
      } catch(e){ if (attempt < 20) return setTimeout(() => window.injectPorcentajeNavButtons(attempt+1), 300); }
    };

      // --- Porcentaje de Activacion: in-place month loader and per-team donut renderer ---
      // Moved here to avoid nesting inside other IIFEs and to keep top-level functions stable.
      window.shiftPorcMonth = function(delta){
        try{
          if (!window.currentPorcMonth) window.currentPorcMonth = new Date();
          const d = new Date(window.currentPorcMonth);
          d.setMonth(d.getMonth() + delta);
          window.currentPorcMonth = d;
          try { loadPorcentajeForMonth(d); } catch(e){ console.warn('loadPorcentajeForMonth error', e); }
        } catch(e){ console.warn('shiftPorcMonth error', e); }
      };

      async function loadPorcentajeForMonth(date){
        console.log('[LOADPORCENTAJE DEBUG] Función llamada con fecha:', date);
        try{
          try { window.__porcIsInitializing = true; } catch(_){ }

          const baseDate = (date instanceof Date && !Number.isNaN(date.getTime())) ? new Date(date) : new Date();
          baseDate.setHours(12, 0, 0, 0);
          try { window.currentPorcMonth = new Date(baseDate); } catch(_){ }
          window.__porcentajeFecha = new Date(baseDate);
          updateChartTitle('porcentaje-mes-titulo', window.__porcentajeFecha);

          const year = baseDate.getFullYear();
          const month = String(baseDate.getMonth() + 1).padStart(2, '0');
          const monthKey = `${year}-${month}`;

          let donutData = [];
          try {
            let aggregated = await fetchMonthAggregates(baseDate, { force: false });
            if (!Array.isArray(aggregated) || aggregated.length === 0) {
              try {
                aggregated = await fetchMonthAggregates(baseDate, { force: true });
              } catch(forceErr) {
                console.warn('[PORCENTAJE] fetchMonthAggregates con force=true falló', forceErr);
              }
            }
            if (Array.isArray(aggregated)) {
              donutData = aggregated.map(normalizeTeamRow);
            }
          } catch(aggErr) {
            console.warn('[PORCENTAJE] No se pudieron obtener agregados mensuales', aggErr);
          }

          try {
            const tableRows = Array.isArray(window.__statsDisplayRows) ? window.__statsDisplayRows : null;
            const tableDate = (window.__tablaMesFecha instanceof Date && !Number.isNaN(window.__tablaMesFecha.getTime()))
              ? `${window.__tablaMesFecha.getFullYear()}-${String(window.__tablaMesFecha.getMonth() + 1).padStart(2, '0')}`
              : '';
            if (tableRows && tableRows.length && tableDate === monthKey) {
              donutData = tableRows.map(normalizeTeamRow);
            }
          } catch(syncErr) {
            console.warn('[PORCENTAJE] No se pudo sincronizar con la tabla mensual', syncErr);
          }

          try {
            if ((!Array.isArray(donutData) || donutData.length === 0) && Array.isArray(window.__monthlyTeamData)) {
              donutData = window.__monthlyTeamData.map(normalizeTeamRow);
            }
          } catch(_){ }

          try {
            const firstDay = `${year}-${month}-01`;
            const lastDay = `${year}-${month}-${String(new Date(year, baseDate.getMonth() + 1, 0).getDate()).padStart(2, '0')}`;
            window.__monthlyTeamData = donutData.map(row => ({ ...row }));
            window.__monthlyRange = { start: firstDay, end: lastDay };
          } catch(_){ }

          try { window.__porcIsInitializing = false; if (typeof showPorcSpinner === 'function') showPorcSpinner(false); } catch(_){ }
          renderPorcentajeTeams(donutData);
        } catch(e){ console.warn('loadPorcentajeForMonth error', e); }
        // ensure the initializing flag is cleared even on unexpected errors
        try { window.__porcIsInitializing = false; if (typeof showPorcSpinner === 'function') showPorcSpinner(false); } catch(_){ }
      }

      // ============ NAVEGACIÓN DE GRÁFICOS ============
      
      // Variables globales para navegación - inicializar según parámetro URL
      function initializeDateFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        const mParam = urlParams.get('m');
        
        if (mParam && /^\d{4}-\d{2}$/.test(mParam)) {
          const [year, month] = mParam.split('-').map(Number);
          const targetDate = new Date(year, month - 1, 15, 12, 0, 0);
          console.log('[NAVEGACIÓN] Inicializando con fecha de URL:', mParam, '→', targetDate);
          return targetDate;
        } else {
          console.log('[NAVEGACIÓN] Sin parámetro de mes válido, usando fecha actual');
          return new Date();
        }
      }
      
      window.__porcentajeFecha = initializeDateFromURL();
      window.__ventasActivasFecha = new Date(window.__porcentajeFecha);
      window.__tablaMesFecha = new Date(window.__porcentajeFecha);
      
      // Función para actualizar título de mes
      function updateChartTitle(elementId, fecha) {
        const element = document.getElementById(elementId);
        if (element) {
          const mes = String(fecha.getMonth() + 1).padStart(2, '0');
          const año = fecha.getFullYear();
          element.textContent = `${mes}/${año}`;
          console.log(`[NAVEGACIÓN] Título actualizado:`, elementId, '→', `${mes}/${año}`);
        }
      }
      
      // Función para actualizar título de la tabla
      function updateTableTitle(fecha) {
        const element = document.getElementById('tabla-mes-titulo');
        if (element) {
          const mes = String(fecha.getMonth() + 1).padStart(2, '0');
          const año = fecha.getFullYear();
          const mesTexto = `${mes}/${año}`;
          element.textContent = `VENTAS POR MERCADO Y PUNTAJE DEL MES (${mesTexto})`;
          console.log(`[NAVEGACIÓN] Título de tabla actualizado → ${mesTexto}`);
        } else {
          console.warn(`[NAVEGACIÓN] Elemento tabla-mes-titulo no encontrado`);
        }
      }
      
      // Función para actualizar URL con parámetro de mes
      function updateURLWithMonth(fecha) {
        try {
          const mes = String(fecha.getMonth() + 1).padStart(2, '0');
          const año = fecha.getFullYear();
          const newParam = `${año}-${mes}`;
          
          const url = new URL(window.location);
          url.searchParams.set('m', newParam);
          // Usar replaceState en lugar de pushState para evitar problemas de historial
          window.history.replaceState({}, '', url);
          console.log('[NAVEGACIÓN] URL actualizada (replaceState):', url.toString());
        } catch (e) {
          console.error('[NAVEGACIÓN] Error actualizando URL:', e);
        }
      }
      
      // Navegación para Porcentaje de Activación
      function initPorcentajeNavigation() {
        console.log('[NAVEGACION DEBUG] Iniciando initPorcentajeNavigation...');
        const btnPrev = document.getElementById('porcentaje-prev');
        const btnNext = document.getElementById('porcentaje-next');
        
        console.log('[NAVEGACION DEBUG] btnPrev encontrado:', btnPrev);
        console.log('[NAVEGACION DEBUG] btnNext encontrado:', btnNext);
        
        if (btnPrev) {
          console.log('[NAVEGACION DEBUG] Agregando event listener a btnPrev...');
          btnPrev.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('[NAVEGACION DEBUG] PREV CLICKED - Fecha actual antes:', window.__porcentajeFecha);
            window.__porcentajeFecha.setMonth(window.__porcentajeFecha.getMonth() - 1);
            console.log('[NAVEGACION DEBUG] PREV CLICKED - Fecha actual después:', window.__porcentajeFecha);
            updateChartTitle('porcentaje-mes-titulo', window.__porcentajeFecha);
            updateURLWithMonth(window.__porcentajeFecha);
            
            console.log('[PORCENTAJE] Navegando a mes anterior:', window.__porcentajeFecha);
            console.log('[NAVEGACION DEBUG] Llamando loadPorcentajeForMonth con:', window.__porcentajeFecha);
            loadPorcentajeForMonth(window.__porcentajeFecha);
          });
          console.log('[NAVEGACION DEBUG] Event listener PREV registrado correctamente');
        } else {
          console.error('[NAVEGACION DEBUG] NO SE ENCONTRÓ btnPrev');
        }
        
        if (btnNext) {
          console.log('[NAVEGACION DEBUG] Agregando event listener a btnNext...');
          btnNext.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('[NAVEGACION DEBUG] NEXT CLICKED - Fecha actual antes:', window.__porcentajeFecha);
            window.__porcentajeFecha.setMonth(window.__porcentajeFecha.getMonth() + 1);
            console.log('[NAVEGACION DEBUG] NEXT CLICKED - Fecha actual después:', window.__porcentajeFecha);
            updateChartTitle('porcentaje-mes-titulo', window.__porcentajeFecha);
            updateURLWithMonth(window.__porcentajeFecha);
            
            console.log('[PORCENTAJE] Navegando a mes siguiente:', window.__porcentajeFecha);
            console.log('[NAVEGACION DEBUG] Llamando loadPorcentajeForMonth con:', window.__porcentajeFecha);
            loadPorcentajeForMonth(window.__porcentajeFecha);
          });
          console.log('[NAVEGACION DEBUG] Event listener NEXT registrado correctamente');
        } else {
          console.error('[NAVEGACION DEBUG] NO SE ENCONTRÓ btnNext');
        }
        
        // Inicializar títulos
        updateChartTitle('porcentaje-mes-titulo', window.__porcentajeFecha);
      }
      
      // Navegación para Ventas Activas
      function initVentasActivasNavigation() {
        const btnPrev = document.getElementById('ventas-activas-prev');
        const btnNext = document.getElementById('ventas-activas-next');
        
        if (btnPrev) {
          btnPrev.onclick = async () => {
            window.__ventasActivasFecha.setMonth(window.__ventasActivasFecha.getMonth() - 1);
            updateChartTitle('ventas-activas-mes-titulo', window.__ventasActivasFecha);
            updateURLWithMonth(window.__ventasActivasFecha);
            console.log('[VENTAS-ACTIVAS] Navegando a mes anterior:', window.__ventasActivasFecha);
            loadVentasActivasForMonth(window.__ventasActivasFecha);
          };
        }
        
        if (btnNext) {
          btnNext.onclick = async () => {
            window.__ventasActivasFecha.setMonth(window.__ventasActivasFecha.getMonth() + 1);
            updateChartTitle('ventas-activas-mes-titulo', window.__ventasActivasFecha);
            updateURLWithMonth(window.__ventasActivasFecha);
            console.log('[VENTAS-ACTIVAS] Navegando a mes siguiente:', window.__ventasActivasFecha);
            loadVentasActivasForMonth(window.__ventasActivasFecha);
          };
        }
        
        // Inicializar título local
        updateChartTitle('ventas-activas-mes-titulo', window.__ventasActivasFecha);
      }
      
      // ========== PRECALENTAMIENTO DE ESTADÍSTICAS (FAST PATH) ==========
      function tryLoadFromPrecachedEstadisticas() {
        try {
          const storedData = sessionStorage.getItem('estadisticasData');
          const storedTimestamp = sessionStorage.getItem('estadisticasTimestamp');
          
          if (!storedData || !storedTimestamp) {
            console.log('[PRECACHE-ESTADISTICAS] ℹ️ Sin datos en caché, usando API');
            return null;
          }

          // Validar que el caché no esté expirado (5 minutos = 300000ms)
          const cacheAge = Date.now() - new Date(storedTimestamp).getTime();
          const TTL = 5 * 60 * 1000;
          
          if (cacheAge > TTL) {
            console.log(`[PRECACHE-ESTADISTICAS] ⏰ Caché expirado (${Math.round(cacheAge/1000)}s > ${Math.round(TTL/1000)}s)`);
            sessionStorage.removeItem('estadisticasData');
            sessionStorage.removeItem('estadisticasTimestamp');
            return null;
          }

          const data = JSON.parse(storedData);
          console.log('[PRECACHE-ESTADISTICAS] ✅ Usando datos cacheados:', {
            teamsData: data.teamsData?.length || 0,
            agentsData: data.agentsData?.length || 0,
            leadsChartData: data.leadsChartData?.length || 0,
            statusSummary: Object.keys(data.statusSummary || {}).length,
            age: `${Math.round(cacheAge/1000)}s`
          });

          // Retornar los datos cacheados para usar en la página
          return {
            success: true,
            data: data,
            fromCache: true,
            loadTime: 0
          };
        } catch (e) {
          console.warn('[PRECACHE-ESTADISTICAS] ⚠️ Error procesando caché:', e?.message);
          return null;
        }
      }
      
      // Inicializar navegación cuando la página esté lista
      document.addEventListener('DOMContentLoaded', () => {
        // FAST PATH: Intentar cargar datos del caché primero
        const precachedResponse = tryLoadFromPrecachedEstadisticas();
        
        if (precachedResponse) {
          console.log('[ESTADISTICAS-INIT] ⚡ FAST PATH: Usando datos precacheados');
          // Aquí se pueden usar los datos del caché para inicializar gráficos rápidamente
          // Los datos están disponibles en precachedResponse.data
          window.__precachedEstadisticasData = precachedResponse.data;
        } else {
          console.log('[ESTADISTICAS-INIT] 🔄 SLOW PATH: Cargando datos desde API');
          // La página cargará datos normalmente desde la API cuando sea necesario
        }
        
        // Usar un polling más robusto para asegurar que los elementos estén disponibles
        function waitForElements() {
          const btnPrev = document.getElementById('porcentaje-prev');
          const btnNext = document.getElementById('porcentaje-next');
          
          if (btnPrev && btnNext) {
            console.log('[NAVEGACIÓN] Elementos encontrados, inicializando navegación de gráficos...');
            initPorcentajeNavigation();
            initVentasActivasNavigation();
          } else {
            console.log('[NAVEGACIÓN] Esperando elementos...', { btnPrev: !!btnPrev, btnNext: !!btnNext });
            setTimeout(waitForElements, 100);
          }
        }
        
        setTimeout(waitForElements, 500);
      });

      // Escuchar evento de precalentamiento desde login.html
      window.addEventListener('estadisticasPreheated', (event) => {
        console.log('[ESTADISTICAS-PREHEATED] 🎯 Datos precalculados recibidos:', event.detail);
        sessionStorage.setItem('estadisticasData', JSON.stringify(event.detail));
        window.__precachedEstadisticasData = event.detail;
      });
      
      // ============ FIN NAVEGACIÓN DE GRÁFICOS ============

      // Helpers: DOM-based external labels for porcentaje donuts (robust outside-canvas numeric labels)
      function cleanupPorcLabels(chart){
        try{
          if (!chart) return;
          try { if (chart._porcLabelsContainer && chart._porcLabelsContainer.parentNode) chart._porcLabelsContainer.parentNode.removeChild(chart._porcLabelsContainer); } catch(_){}
          try { if (chart._porcResizeHandler) { window.removeEventListener('resize', chart._porcResizeHandler); chart._porcResizeHandler = null; } } catch(_){}
          try { if (chart._porcObserver) { chart._porcObserver.disconnect(); chart._porcObserver = null; } } catch(_){}
          // restore original update if we wrapped it
          try { if (chart.__origUpdate) { chart.update = chart.__origUpdate; chart.__origUpdate = null; } } catch(_){}
        } catch(_){}
      }

      function attachPorcLabels(chart, rowsArr, useTotals){
        try{
          if (!chart || !chart.canvas) return;
          cleanupPorcLabels(chart);
          const canvas = chart.canvas;
          const wrapper = canvas.parentElement || document.body;
          if (wrapper && getComputedStyle(wrapper).position === 'static') wrapper.style.position = 'relative';
          const container = document.createElement('div');
          container.className = 'porc-labels-overlay';
          // Use fixed positioning anchored to the canvas bounding rect. This
          // avoids ancestor transforms/stacking contexts that can shift absolute
          // positioned overlays and makes mapping from chart pixels -> screen
          // pixels more reliable across browsers/devices.
          container.style.position = 'fixed';
          container.style.pointerEvents = 'none';
          container.style.zIndex = '40';
          // align overlay to the canvas surface so arc.x/arc.y map 1:1 to overlay coords
          try {
            // Anchor the overlay to the canvas bounding box in viewport coordinates
            // so subsequent label placement can use viewport absolute coords.
            const canvasRect = canvas.getBoundingClientRect();
            container.style.left = Math.round(canvasRect.left) + 'px';
            container.style.top = Math.round(canvasRect.top) + 'px';
            container.style.width = Math.round(canvasRect.width) + 'px';
            container.style.height = Math.round(canvasRect.height) + 'px';
          } catch(_) {
            container.style.inset = '0';
            container.style.top = '0';
            container.style.left = '0';
            container.style.width = '100%';
            container.style.height = '100%';
          }
          wrapper.appendChild(container);
          chart._porcLabelsContainer = container;

          const update = function(){
            try {
              container.innerHTML = '';
              const meta = chart.getDatasetMeta(0);
              if (!meta || !Array.isArray(meta.data)) return;
                  meta.data.forEach((arc, i) => {
                try {
                  const rawVal = (chart.data && chart.data.datasets && chart.data.datasets[0] && chart.data.datasets[0].data && chart.data.datasets[0].data[i]) ? chart.data.datasets[0].data[i] : 0;
                  const value = (rawVal === null || rawVal === undefined) ? 0 : rawVal;
                  // skip labels for zero-sized slices to avoid clutter
                  if (!value || Number(value) === 0) return;
                  // compute slice color for contrast adjustments
                  let sliceColor = null;
                  try { sliceColor = (chart.data && chart.data.datasets && chart.data.datasets[0] && chart.data.datasets[0].backgroundColor && chart.data.datasets[0].backgroundColor[i]) ? chart.data.datasets[0].backgroundColor[i] : null; } catch(_) { sliceColor = null; }
                  // place label at the middle of the slice (midpoint between inner and outer radius)
                  const angle = (arc.startAngle + arc.endAngle) / 2;
                  const outer = (typeof arc.outerRadius === 'number') ? arc.outerRadius : Math.min(chart.width, chart.height) / 2;
                  const inner = (typeof arc.innerRadius === 'number') ? arc.innerRadius : Math.max(0, outer * 0.4);
                  // pull labels slightly inward from the exact midpoint so they stay
                  // visually inside the donut slice (helps for thin/adjacent slices)
                  const span = Math.abs((arc.endAngle || 0) - (arc.startAngle || 0));
                  let midRadius = (inner + outer) / 2;
                  if (span < 0.6) {
                    // narrow slice: push label closer to inner radius so it fits
                    midRadius = inner + (outer - inner) * 0.38;
                  } else {
                    // normal slice: slight inward nudge
                    midRadius = midRadius * 0.7;
                  }
                  const cx = (typeof arc.x === 'number') ? arc.x : (chart.width / 2);
                  const cy = (typeof arc.y === 'number') ? arc.y : (chart.height / 2);
                  // Chart internal coordinates may be in device pixels; map to the
                  // overlay (which uses CSS pixels) using the canvas bounding rect.
                  const cRect = canvas.getBoundingClientRect();
                  // Use the canvas backing buffer size (canvas.width/height) which are
                  // in device pixels. Mapping from chart internal pixels -> CSS pixels
                  // is done by ratio = cssSize / backingSize.
                  const backingW = (canvas.width || chart.width || cRect.width);
                  const backingH = (canvas.height || chart.height || cRect.height);
                  const ratioX = (cRect.width || 1) / backingW;
                  const ratioY = (cRect.height || 1) / backingH;
                  // Prefer the arc's built-in center/tooltip position if available
                  // (Chart.js provides element.tooltipPosition() / getCenterPoint()).
                  let pos = null;
                  try {
                    if (typeof arc.getCenterPoint === 'function') pos = arc.getCenterPoint();
                    else if (typeof arc.tooltipPosition === 'function') pos = arc.tooltipPosition();
                  } catch(_) { pos = null; }
                  // Fallback: use our computed midpoint if Chart element helpers are missing
                  let xChart, yChart;
                  if (pos && typeof pos.x === 'number' && typeof pos.y === 'number') {
                    xChart = pos.x; yChart = pos.y;
                  } else {
                    xChart = cx + Math.cos(angle) * midRadius;
                    yChart = cy + Math.sin(angle) * midRadius;
                  }
                  // Compute absolute screen coordinates for the label and then map
                  // them into the overlay's coordinate system. This avoids offsets
                  // caused by padding/margins or different positioning contexts.
                  const absoluteX = cRect.left + (xChart * ratioX);
                  const absoluteY = cRect.top  + (yChart * ratioY);
                  // container is fixed and aligned to canvas bounding rect, so map
                  // absolute viewport coords into the overlay by subtracting its
                  // bounding rect. This avoids issues when wrapper has transforms.
                  const containerRect = container.getBoundingClientRect();
                  // coordinates relative to the overlay
                  let x = absoluteX - containerRect.left;
                  let y = absoluteY - containerRect.top;
                  // keep labels inside the overlay bounds (padding 6px)
                  try {
                    const maxW = container.clientWidth || containerRect.width || cRect.width || 1;
                    const maxH = container.clientHeight || containerRect.height || cRect.height || 1;
                    x = Math.max(6, Math.min(maxW - 6, x));
                    y = Math.max(6, Math.min(maxH - 6, y));
                  } catch(_){}
                  const lbl = document.createElement('div');
                  lbl.className = 'porc-label';
                  lbl.style.position = 'absolute';
                  lbl.style.left = x + 'px';
                  lbl.style.top = y + 'px';
                  lbl.style.transform = 'translate(-50%, -50%)';
                  lbl.style.pointerEvents = 'none';
                  // make label visually compact so it fits inside slices
                  lbl.style.background = 'rgba(255,255,255,0.9)';
                  lbl.style.borderRadius = '6px';
                  lbl.style.padding = '2px 6px';
                  lbl.style.fontWeight = '700';
                  lbl.style.fontSize = '11px';
                  lbl.style.color = '#0f172a';
                  lbl.style.boxShadow = '0 1px 2px rgba(0,0,0,0.06)';
                  lbl.style.border = '1px solid rgba(0,0,0,0.06)';
                  // adjust foreground/background for readability depending on slice color
                  try {
                    if (sliceColor) {
                      const hexToRgb = (h) => {
                        try {
                          if (h.startsWith('#')) {
                            const v = h.slice(1);
                            const bigint = parseInt(v.length===3 ? v.split('').map(c=>c+c).join('') : v, 16);
                            return [(bigint>>16)&255, (bigint>>8)&255, bigint&255];
                          }
                          // rgba(...) or rgb(...)
                          const m = h.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
                          if (m) return [parseInt(m[1]), parseInt(m[2]), parseInt(m[3])];
                        } catch(_){}
                        return null;
                      };
                      const rgb = hexToRgb(String(sliceColor));
                      if (rgb) {
                        const [r,g,b] = rgb.map(n => Number(n)/255);
                        // relative luminance
                        const lum = 0.2126 * (r<=0.03928 ? r/12.92 : Math.pow((r+0.055)/1.055,2.4))
                                  + 0.7152 * (g<=0.03928 ? g/12.92 : Math.pow((g+0.055)/1.055,2.4))
                                  + 0.0722 * (b<=0.03928 ? b/12.92 : Math.pow((b+0.055)/1.055,2.4));
                        if (lum < 0.45) {
                          // dark slice -> light text, slight dark translucent bg
                          lbl.style.color = '#ffffff';
                          lbl.style.background = 'rgba(0,0,0,0.38)';
                        } else {
                          // light slice -> dark text, light translucent bg
                          lbl.style.color = '#0f172a';
                          lbl.style.background = 'rgba(255,255,255,0.85)';
                        }
                      }
                    }
                  } catch(_){}
                  lbl.textContent = String(value);
                  container.appendChild(lbl);
                } catch(_){}
              });
            } catch(e){ console.warn('update porc labels error', e); }
          };

          // initial placement: run several times and after next frame to handle
          // Chart.js internal layout timing (first draw may change canvas size).
          try { update(); } catch(_){}
          try { setTimeout(update, 30); } catch(_){}
          try { requestAnimationFrame(() => { try { update(); } catch(_){} }); } catch(_){}
          try { setTimeout(update, 220); } catch(_){ }
          try { setTimeout(update, 600); } catch(_){ }
          try { setTimeout(update, 1200); } catch(_){ }

          // keep handler for later cleanup and recompute overlay bounds on resize
          chart._porcResizeHandler = function(){
            try {
              // Re-anchor the fixed overlay to the canvas viewport rect so
              // scrolling/resizes keep labels positioned correctly.
              const cRect = canvas.getBoundingClientRect();
              container.style.left = Math.round(cRect.left) + 'px';
              container.style.top = Math.round(cRect.top) + 'px';
              container.style.width = Math.round(cRect.width) + 'px';
              container.style.height = Math.round(cRect.height) + 'px';
            } catch(_){}
            try { update(); } catch(_){}
          };
          window.addEventListener('resize', chart._porcResizeHandler);

          // observe canvas size/attr changes to update labels
          try { const mo = new MutationObserver(update); mo.observe(canvas, { attributes: true, attributeFilter: ['width','height','style'] }); chart._porcObserver = mo; } catch(_){}

          // wrap update so labels refresh when chart.update() called
          try { if (!chart.__origUpdate) { chart.__origUpdate = chart.update.bind(chart); chart.update = function(){ const res = chart.__origUpdate.apply(this, arguments); try { update(); } catch(_){} return res; }; } } catch(_){}

          // Expose a simple forced update helper so callers (e.g. animation.onComplete)
          // can request a multi-pass refresh. This schedules a few delayed retries
          // to handle devicePixelRatio/layout shifts on first paint.
          try {
            chart._porcForceUpdate = function(){ try { update(); } catch(_){}
              try { setTimeout(update, 350); } catch(_){}
              try { setTimeout(update, 700); } catch(_){}
              try { setTimeout(update, 1200); } catch(_){}
            };
          } catch(_){ }
        } catch(e){ console.warn('attachPorcLabels error', e); }
      }

      function renderPorcentajeTeams(teamData, selectedIndex = 0){
        try {
          const canvas = document.getElementById('chart-porcentaje-activacion');
          const listRoot = document.getElementById('porc-team-list');
          
          console.log('[PORCENTAJE] Iniciando render...', {
            canvasFound: !!canvas,
            listRootFound: !!listRoot,
            teamDataLength: teamData?.length,
            selectedIndex
          });
          
          if (!canvas) {
            console.error('[PORCENTAJE] Canvas no encontrado!');
            return;
          }
          if (!Array.isArray(teamData)) teamData = [];
          
          console.log('[PORCENTAJE] TeamData:', teamData);

          // Lista completa de equipos ordenada
          const EQUIPOS_ORDER = ['Pleitez', 'Roberto', 'Marisol', 'Johana', 'Irania', 'JONATHAN F', 'LUIS G'];
          
          // while inicializando no dibujar gráficos provisionales
          if (window.__porcIsInitializing) {
            try {
              if (canvas.getContext) {
                const ctx = canvas.getContext('2d');
                try { ctx.clearRect(0,0,canvas.width || canvas.clientWidth, canvas.height || canvas.clientHeight); } catch(_){}
              }
              return;
            } catch(_) {}
          }

          // Deduplicar por nombre y asegurar que todos los equipos estén presentes
          const mapByName = new Map();
          
          // Primero procesar los datos existentes
          for (const team of teamData) {
            const key = String(team.name || '').trim().toUpperCase();
            if (!mapByName.has(key)) {
              mapByName.set(key, {
                name: team.name,
                ICON: Number(team.ICON || 0),
                ACTIVAS: Number(team.ACTIVAS || 0),
                Total: Number(team.Total || 0),
                Puntaje: Number(team.Puntaje || 0)
              });
            } else {
              // Si hay duplicados, sumar sus valores
              const existing = mapByName.get(key);
              existing.ICON = (existing.ICON || 0) + Number(team.ICON || 0);
              existing.ACTIVAS = (existing.ACTIVAS || 0) + Number(team.ACTIVAS || 0);
              existing.Total = (existing.Total || 0) + Number(team.Total || 0);
              existing.Puntaje = (existing.Puntaje || 0) + Number(team.Puntaje || 0);
            }
          }

          // Asegurar que todos los equipos requeridos estén presentes
          for (const teamName of EQUIPOS_ORDER) {
            const key = teamName.trim().toUpperCase();
            if (!mapByName.has(key)) {
              mapByName.set(key, {
                name: teamName,
                ICON: 0,
                ACTIVAS: 0,
                Total: 0,
                Puntaje: 0
              });
            }
          }

          // Convertir los equipos procesados a un array ordenado según EQUIPOS_ORDER
          const rows = EQUIPOS_ORDER.map(teamName => {
            const team = mapByName.get(teamName.trim().toUpperCase()) || {
              name: teamName,
              ICON: 0,
              ACTIVAS: 0,
              Total: 0,
              Puntaje: 0
            };
            
            // Calcular el porcentaje de activación usando solo ventas completadas (ACTIVAS)
            const totalVentas = Number(team.Total || 0);
            const totalActivas = Number(team.ACTIVAS || 0); // Solo usar ACTIVAS, no ICON
            const porcentaje = totalVentas > 0 ? (totalActivas / totalVentas) * 100 : 0;
            
            return {
              ...team,
              porcentajeActivacion: Math.round(porcentaje * 100) / 100 // Redondear a 2 decimales
            };
          });
          // Verificar si hay datos para mostrar
          if (rows.length === 0) {
            try {
              // Limpiar y ocultar el canvas si no hay datos
              if (window.porcentajeActivacionChart) {
                try { 
                  cleanupPorcLabels(window.porcentajeActivacionChart);
                  window.porcentajeActivacionChart.destroy();
                  window.porcentajeActivacionChart = null;
                } catch(_){ }
              }
              if (canvas && canvas.getContext) {
                const ctx = canvas.getContext('2d');
                try { 
                  ctx.clearRect(0, 0, canvas.width || canvas.clientWidth, canvas.height || canvas.clientHeight);
                  canvas.style.display = 'none';
                } catch(_){ }
              }
              return;
            } catch(_){ }
          }

          // Spinner overlay management for Porcentaje de Activacion
          function showPorcSpinner(show) {
            try {
              if (!canvas) return;
              const wrapper = canvas.parentElement || document.body;
              // ensure wrapper is a positioning context
              if (wrapper && getComputedStyle(wrapper).position === 'static') {
                wrapper.style.position = 'relative';
              }
              let overlay = wrapper.querySelector('.porc-spinner-overlay');
              if (show) {
                if (!overlay) {
                  overlay = document.createElement('div');
                  overlay.className = 'porc-spinner-overlay';
                  overlay.innerHTML = '<div class="porc-spinner" aria-hidden="true"></div>';
                  // align overlay to canvas bounds
                  try {
                    overlay.style.left = (canvas.offsetLeft || 0) + 'px';
                    overlay.style.top = (canvas.offsetTop || 0) + 'px';
                    overlay.style.width = (canvas.clientWidth || canvas.width || 200) + 'px';
                    overlay.style.height = (canvas.clientHeight || canvas.height || 200) + 'px';
                  } catch(_) { overlay.style.inset = '0'; }
                  wrapper.appendChild(overlay);
                }
              } else {
                try { 
                  if (overlay && overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                  }
                } catch(_){ }
              }
            } catch(e){ console.warn('showPorcSpinner error', e); }
          }
          if (listRoot) {
            try{ 
              listRoot.style.display = 'flex';
              listRoot.style.flexDirection = 'column';
              listRoot.innerHTML = '';
              
              // Generar la lista de equipos con sus porcentajes
              const itemsHtml = rows.map(team => {
                const totalVentas = Number(team.Total || 0);
                const totalActivas = Number(team.ACTIVAS || 0); // Solo usar ventas completadas (ACTIVAS)
                const porcentaje = totalVentas > 0 ? (totalActivas / totalVentas) * 100 : 0;
                return `
                  <div style="display:grid;grid-template-columns:1fr auto;column-gap:10px;align-items:center;padding:6px 4px;border-bottom:1px solid rgba(0,0,0,0.04);">
                    <div style="font-weight:700;color:#0f172a;font-size:0.95rem;">${team.name}</div>
                    <div style="text-align:right;color:#6b7280;font-size:0.85rem;line-height:1.1;">
                      Total: <span style='font-weight:700;color:#111;'>${totalVentas}</span><br>
                      Activas: <span style='font-weight:700;color:#111;'>${totalActivas}</span><br>
                      <span style='color:#059669;font-weight:700;'>${porcentaje.toFixed(2)}%</span>
                    </div>
                  </div>`;
              }).join('');

              listRoot.innerHTML = `<div style="display:block;">${itemsHtml}</div>`;
            } catch(_){ }
          }

          // By default render the aggregated 'all teams' donut when there are multiple teams
          if (rows.length > 1) {
            // default: render all teams view
            renderPorcentajeAllTeams(rows);
            return;
          }

          // fallback single team render
          renderPorcentajeForTeam(rows, selectedIndex);

          // --- helper: render a single team's donut ---
          function renderPorcentajeForTeam(rowsArr, selIdx){
            try{
              const team = rowsArr[selIdx] || rowsArr[0];
              // Usar solo ventas completadas (ACTIVAS) para el cálculo
              const active = Number(team.ACTIVAS || 0);
              const total = Number(team.Total || 0);
              const inactive = Math.max(0, total - active);
              // If the team has no total sales at all, clear and hide the canvas
              // but if Total > 0 we still render a donut (with Activadas possibly 0)
              if (!total || Number(total) === 0) {
                try { if (window.porcentajeActivacionChart) { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } } catch(_){ }
                try { const ctx = canvas.getContext && canvas.getContext('2d'); if (ctx) ctx.clearRect(0,0,canvas.width || canvas.clientWidth, canvas.height || canvas.clientHeight); try { canvas.style.display = 'none'; } catch(_){} } catch(_){ }
                return;
              }
              if (window.porcentajeActivacionChart) try { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } catch(_){ }
              const ctx = canvas.getContext('2d');
              try { canvas.style.display = 'block'; } catch(_){}
              // Usar la paleta de la imagen: #588A87, #B6C6BE, #DFD9CA, #EFCABF, #EEA995
              window.porcentajeActivacionChart = new Chart(ctx, {
                type: 'doughnut',
                data: { labels: ['Activadas','No activadas'], datasets: [{ data: [active, inactive], backgroundColor: ['#588A87','#DFD9CA'], borderColor: ['#fff','#fff'], borderWidth: 3 }] },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  cutout: '60%',
                  layout: {
                    padding: 15
                  },
                  plugins: {
                    legend: { display: false },
                    tooltip: {
                      backgroundColor: 'rgba(0, 0, 0, 0.8)',
                      padding: 12,
                      cornerRadius: 8
                    },
                    datalabels: {
                      display: false  // Desactivar etiquetas en gráfica de donut
                    }
                  }
                },
                plugins: [{
                  id: 'shadow3D',
                  beforeDraw: (chart) => {
                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 5;
                    ctx.shadowOffsetY = 5;
                  },
                  afterDraw: (chart) => {
                    chart.ctx.restore();
                  }
                }]
              });
              // Labels are rendered inside the canvas by the datalabels plugin now.
            }catch(e){ console.warn('renderPorcentajeForTeam error', e); }
          }

          // --- helper: render all teams as slices in a single donut ---
          function renderPorcentajeAllTeams(rowsArr){
            try{
              if (!Array.isArray(rowsArr) || rowsArr.length === 0) return;
              const labels = rowsArr.map(r => String(r.name));
              // Usar el Total de ventas para el tamaño de las porciones del gráfico
              // El porcentaje de activación se mostrará en las etiquetas
              const dataToUse = rowsArr.map(r => Number(r.Total || 0));
              const totalTotal = dataToUse.reduce((s,n)=>s+Number(n||0),0);
              
              // If after choosing the data the sum is zero, there's nothing to draw
              if (totalTotal === 0) {
                try { if (window.porcentajeActivacionChart) { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } } catch(_){ }
                try { const ctx = canvas.getContext && canvas.getContext('2d'); if (ctx) ctx.clearRect(0,0,canvas.width || canvas.clientWidth, canvas.height || canvas.clientHeight); try { canvas.style.display = 'none'; } catch(_){} } catch(_){ }
                return;
              }
              if (window.porcentajeActivacionChart) try { cleanupPorcLabels(window.porcentajeActivacionChart); window.porcentajeActivacionChart.destroy(); window.porcentajeActivacionChart = null; } catch(_){ }
              const ctx = canvas.getContext('2d');
              // generate colors
              // Paleta provista por el usuario (imagen)
              const palette = ['#588A87', '#B6C6BE', '#DFD9CA', '#EFCABF', '#EEA995'];
              const background = labels.map((_,i)=> palette[i % palette.length]);
              
              // Solo incluir plugin de sombras 3D
              const chartPlugins = [{
                id: 'shadow3D',
                beforeDraw: (chart) => {
                  const ctx = chart.ctx;
                  ctx.save();
                  ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                  ctx.shadowBlur = 15;
                  ctx.shadowOffsetX = 5;
                  ctx.shadowOffsetY = 5;
                },
                afterDraw: (chart) => {
                  chart.ctx.restore();
                }
              }];
              
              window.porcentajeActivacionChart = new Chart(ctx, {
                type: 'doughnut',
                data: { labels: labels, datasets: [{ data: dataToUse, backgroundColor: background, borderColor: '#fff', borderWidth: 3 }] },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  cutout: '60%',
                  // Efecto 3D con sombras
                  layout: {
                    padding: 15
                  },
                  plugins: {
                    legend: { display: false },
                    tooltip: { 
                      intersect: false, 
                      position: 'nearest',
                      backgroundColor: 'rgba(0, 0, 0, 0.8)',
                      padding: 12,
                      cornerRadius: 8,
                      displayColors: true,
                      callbacks: { 
                        label: function(ctx){ 
                          const idx = ctx.dataIndex;
                          const team = rowsArr[idx];
                          const totalVentas = Number(team.Total || 0);
                          const totalActivas = Number(team.ACTIVAS || 0);
                          const porcentaje = totalVentas > 0 ? (totalActivas / totalVentas) * 100 : 0;
                          return `${ctx.label}: ${totalActivas}/${totalVentas} (${porcentaje.toFixed(1)}% activación)`;
                        } 
                      } 
                    },
                    datalabels: {
                      display: false  // Desactivar etiquetas en gráfica de donut
                    }
                  }
                },
                plugins: chartPlugins
              });

              // Populate the compact left-side list (`#porc-team-list`) with the
              // rows for quick reference. Make it absolute-left inside the chart
              // wrapper so it doesn't push content and avoid repopulating when
              // identical (use dataset.porcKey as a guard).
              try {
                const listRootLocal = document.getElementById('porc-team-list');
                if (listRootLocal) {
                  // Colores del gráfico (misma paleta)
                  const palette = ['#588A87', '#B6C6BE', '#DFD9CA', '#EFCABF', '#EEA995'];
                  const itemsHtml = rowsArr.map((team, index) => {
                    const name = String(team.name || 'Sin equipo');
                    const total = Number(team.Total || 0);
                    const activas = Number(team.ACTIVAS || 0);
                    const porcentaje = total > 0 ? ((activas / total) * 100).toFixed(2) : '0.00';
                    const color = palette[index % palette.length];
                    return `
                      <div style="display:grid;grid-template-columns:auto 1fr auto;column-gap:6px;align-items:center;padding:3px 2px;border-bottom:1px solid rgba(0,0,0,0.04);">
                        <div style="width:10px;height:10px;border-radius:50%;background-color:${color};flex-shrink:0;"></div>
                        <div style="font-weight:700;color:#0f172a;font-size:0.8rem;">${name}</div>
                        <div style="text-align:right;color:#6b7280;font-size:0.72rem;line-height:1.0;">Total: <span style='font-weight:700;color:#111;'>${total}</span><br>Activas: <span style='font-weight:700;color:#111;'>${activas}</span><br><span style='color:#059669;font-weight:700;'>${porcentaje}%</span></div>
                      </div>`;
                  }).join('');

                  const key = rowsArr.map(r => String(r.name || '') + '::' + Number(r.Total || 0) + '::' + Number((r.ACTIVAS !== undefined && r.ACTIVAS !== null) ? r.ACTIVAS : r.ICON || 0)).join('|');
                  if (listRootLocal.dataset.porcKey !== key) {
                    listRootLocal.innerHTML = `<div style="display:block;">${itemsHtml}</div>`;
                    listRootLocal.dataset.porcKey = key;
                  }

                  // style it like the compact list (absolute left)
                  try {
                    listRootLocal.style.display = 'block';
                    listRootLocal.style.position = 'absolute';
                    listRootLocal.style.left = '12px';
                    listRootLocal.style.top = '50%';
                    listRootLocal.style.transform = 'translateY(-50%)';
                    listRootLocal.style.width = '180px';
                    listRootLocal.style.maxHeight = 'none';
                    listRootLocal.style.overflow = 'visible';
                    listRootLocal.style.padding = '2px 4px';
                    listRootLocal.style.boxSizing = 'border-box';
                    listRootLocal.style.background = 'transparent';
                    listRootLocal.style.fontSize = '0.8rem';
                    listRootLocal.style.color = '#0f172a';
                    listRootLocal.style.zIndex = '6';
                  } catch(_){}
                }

                // ensure the chart wrapper has space on the left so the list doesn't overlap the donut
                try {
                  const wrapper = canvas && canvas.parentElement;
                  if (wrapper) {
                    if (getComputedStyle(wrapper).position === 'static') wrapper.style.position = 'relative';
                    wrapper.style.paddingLeft = '200px';
                    wrapper.style.overflow = 'visible';
                    try { if (wrapper.parentElement) wrapper.parentElement.style.overflow = 'visible'; } catch(_){ }
                  }
                } catch(_){ }
              } catch(e){ console.warn('populate left porc-team-list error', e); }
            }catch(e){ console.warn('renderPorcentajeAllTeams error', e); }
          }

        }catch(e){ console.warn('renderPorcentajeTeams error', e); }
      }

    /* Day flip: make the back face an absolute overlay so the day chart never pushes or
       overlaps the table in a way that changes layout flow. This keeps the front table
       visible unless explicitly hidden and prevents reflow of the lower panels. */
    (function ensureDayFlipOverlayStyles(){
      if (document.getElementById('day-flip-overlay-styles')) return;
      const css = `
        /* Positioning context */
        #day-flip-local { position: relative; }

        /* Put the back face (chart) out of flow and hidden by default */
        #day-flip-local .flip-face.back {
          position: absolute;
          inset: 0;
          display: none;
          z-index: 6;
          box-sizing: border-box;
          padding: 8px;
          background: rgba(255,255,255,0.98);
          pointer-events: auto;
        }

        /* When the container is marked as flipped, show the back overlay without reflow */
        #day-flip-local.is-flipped .flip-face.back,
        #day-flip-local.show-chart-day .flip-face.back { display: block; }

        /* Keep front in normal flow so tables retain dimensions */
        #day-flip-local .flip-face.front { position: relative; z-index: 2; }

        /* Make sure any canvases fill the overlay area */
        #day-flip-local .flip-face.back .chart-wrapper,
        #day-flip-local .flip-face.back canvas { width: 100% !important; height: 100% !important; }
      `;
      const s = document.createElement('style'); s.id = 'day-flip-overlay-styles'; s.textContent = css; document.head.appendChild(s);
    })();

    // Safe delegated click handler for the day flip button: call existing toggle if present
    (function attachDayFlipDelegated(){
      document.addEventListener('click', function onDocClick(e){
        try {
          const t = e.target;
          if (!t) return;
          // Common IDs used by the app for the monthly/day flip buttons: try to catch the day one
          if (t.id === 'btn-flip-day' || t.dataset && t.dataset.flip === 'day') {
            e.preventDefault();
            if (typeof window.__toggleDayFlip === 'function') {
              try { window.__toggleDayFlip(); } catch(err){ console.warn('error calling __toggleDayFlip', err); }
            } else if (typeof window.__toggleMonthlyFlip === 'function') {
              // fallback: reuse monthly helper if day toggle isn't present
              try { window.__toggleMonthlyFlip(); } catch(_){}
            } else {
              // Last resort: toggle a show class on #day-flip-local so CSS overlay shows
              const container = document.getElementById('day-flip-local');
              if (container) container.classList.toggle('show-chart-day');
            }
          }
        } catch(_){}
      }, false);
    })();

    // Ensure monthly flip preserves layout height to avoid shifting the lower chart
    // This helper locks the flip viewport (or card) to the front face height while the
    // flip transition runs, then releases it and triggers a chart resize.
    (function ensureMonthlyFlipHeightLock(){
      if (window.__toggleMonthlyFlip) return; // don't overwrite if already defined
      window.__toggleMonthlyFlip = function(){
        try {
          // Prefer the conversion-card that contains the monthly flip
          const card = document.querySelector('.conversion-card');
          const flipViewport = (card && card.querySelector('#month-flip-local')) || document.getElementById('month-flip-local');
          const front = flipViewport ? flipViewport.querySelector('.flip-face.front') : null;
          const lockTarget = flipViewport || card || document.body;

          // Measure and lock height so the layout below doesn't reflow mid-transition
          const height = (front && front.offsetHeight) ? front.offsetHeight : (lockTarget && lockTarget.offsetHeight) || 0;
          if (height) {
            // Use minHeight so content can still grow if needed but won't shrink during flip
            lockTarget.style.minHeight = height + 'px';
          }

          // Toggle the visual state (same class the rest of the code expects)
          if (card) card.classList.toggle('show-chart');

          // After the flip animation settles, release the lock and refresh charts
          const RELEASE_MS = 700; // slightly longer than the CSS transition to be safe
          setTimeout(() => {
            try { if (height) lockTarget.style.minHeight = ''; } catch(_){}
            try { if (window.__monthlyChart && typeof window.__monthlyChart.resize === 'function') window.__monthlyChart.resize(); } catch(_){}
            try { if (window.ventasPorEquipoChart && typeof window.ventasPorEquipoChart.resize === 'function') window.ventasPorEquipoChart.resize(); } catch(_){}
          }, RELEASE_MS);
        } catch(e){
          console.warn('toggleMonthlyFlip error', e);
        }
      };
    })();

    // Contenedor del modal
    (function ensureModalContainer(){
      let overlay = document.getElementById('day-detail-modal');
      if (!overlay){
        overlay = document.createElement('div');
        overlay.id = 'day-detail-modal';
        overlay.className = 'modal-overlay';
        overlay.innerHTML = `
          <div class="modal" role="dialog" aria-modal="true" aria-labelledby="dayDetailTitle">
            <div class="modal-header">
              <div id="dayDetailTitle">Detalle de Ventas del Día</div>
              <button class="close-btn" id="day-detail-close">Cerrar</button>
            </div>
            <div class="modal-body">
              <div class="toolbar">
                <label for="filter-team-select" >Equipo:</label>
                <select id="filter-team-select"></select>
                <span id="day-detail-subtitle" ></span>
              </div>
              <div >
                <table class="table-compact" id="day-detail-table">
                  <thead>
                    <tr>
                      <th>Equipo</th>
                      <th>Agente</th>
                      <th>Servicio</th>
                      <th>Mercado</th>
                      <th>Puntaje</th>
                      <th>Fecha</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
          </div>`;
        document.body.appendChild(overlay);
      }
      // Conectar listeners (siempre)
      overlay.addEventListener('click', (e)=>{ if(e.target===overlay) hideDayDetailModal(); });
      const closeBtn = document.getElementById('day-detail-close');
      if (closeBtn) closeBtn.onclick = hideDayDetailModal;
      // Cerrar con ESC
      document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideDayDetailModal(); });
    })();

    function hideDayDetailModal(){
      const el = document.getElementById('day-detail-modal');
      if (el) el.style.display = 'none';
    }

    // Aplica visibilidad a la tabla del Día y persiste selección
    window.applyDayTeamVisibility = function(teams){
      try {
        const STORAGE_KEY = 'stats_day_visible_teams';
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(teams)); } catch(_) {}
        const ORDER_ALL = ['Pleitez','Roberto','Marisol','Johana','Irania'];
        const base = Array.isArray(window.DayRowsOriginal) ? window.DayRowsOriginal : [];
        const rows = (teams && teams.length ? ORDER_ALL.filter(n=>teams.includes(n)) : ORDER_ALL).map(n => {
          const found = (base||[]).find(r=>String(r.name)===n);
          return found || { name:n, ICON:0, BAMO:0, Total:0, Puntaje:0 };
        });
        const card = document.querySelector('#ventas-dia-card .sales-table');
        if (!card) return;
        const tbody = card.querySelector('tbody');
        if (!tbody) return;
        const bodyRows = rows.map(team => `
          <tr>
            <td>${team.name}</td>
            <td>${team.ICON || 0}</td>
            <td>${team.BAMO || 0}</td>
            <td>${team.Total || 0}</td>
            <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
          </tr>
        `).join('');
        const totalHTML = `
          <tr class="total-row">
            <td>TOTAL</td>
            <td>${rows.reduce((s,t)=>s+(t.ICON||0),0)}</td>
            <td>${rows.reduce((s,t)=>s+(t.BAMO||0),0)}</td>
            <td>${rows.reduce((s,t)=>s+(t.Total||0),0)}</td>
            <td>${rows.reduce((s,t)=>s+parseFloat(t.Puntaje||0),0).toFixed(2)}</td>
          </tr>`;
        tbody.innerHTML = bodyRows + totalHTML;
      } catch(e){ console.warn('applyDayTeamVisibility error', e); }
    };

    // ====== DETALLE MENSUAL ======

    (function ensureMonthModal(){
      if (!document.getElementById('month-detail-modal')){
        const overlay = document.createElement('div');
        overlay.id = 'month-detail-modal';
        overlay.className = 'modal-overlay';
        overlay.innerHTML = `
          <div class="modal" role="dialog" aria-modal="true" aria-labelledby="monthDetailTitle">
            <div class="modal-header">
              <div id="monthDetailTitle">Detalle Mensual</div>
              <button class="close-btn" id="month-detail-close">Cerrar</button>
            </div>
            <div class="modal-body">
              <div class="toolbar">
                <label for="month-filter-team" >Equipo:</label>
                <select id="month-filter-team" style="min-width:200px"></select>
                <label for="month-filter-agent" style="font-weight:600; margin-left:8px;">Agente:</label>
                <select id="month-filter-agent" style="min-width:220px"></select>
                <span id="month-detail-subtitle" ></span>
              </div>
              <div >
                <table class="table-compact" id="month-detail-table">
                  <thead>
                    <tr>
                      <th>Equipo</th>
                      <th>Agente</th>
                      <th>Servicio</th>
                      <th>Mercado</th>
                      <th>Puntaje</th>
                      <th>Fecha</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
          </div>`;
        document.body.appendChild(overlay);
        overlay.addEventListener('click', (e)=>{ if(e.target===overlay) hideMonthDetailModal(); });
        document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideMonthDetailModal(); });
        const closeBtn = overlay.querySelector('#month-detail-close');
        if (closeBtn) closeBtn.addEventListener('click', hideMonthDetailModal);
      }
    })();

    async function prepareMonthDetails(){
        // Intentar SIEMPRE el agregado del DÍA con forceAll=1 (todos los equipos)
        // Ensure start/end Date objects are defined (use window.__monthlyRange if available)
        let start, end;
        try {
          const r = (window && window.__monthlyRange) ? window.__monthlyRange : null;
          if (r && r.start) {
            // r.start/r.end may be strings like 'YYYY-MM-DD'
            start = (r.start instanceof Date) ? r.start : new Date(String(r.start) + 'T00:00:00');
            // make end exclusive (next day after r.end)
            const last = (r.end instanceof Date) ? r.end : new Date(String(r.end) + 'T00:00:00');
            end = new Date(last.getFullYear(), last.getMonth(), last.getDate() + 1, 0, 0, 0);
          } else {
            const now = new Date();
            start = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0);
            end = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0);
          }
        } catch(_) {
          start = new Date(); end = new Date(start.getFullYear(), start.getMonth() + 1, 1);
        }
        let leads = [];
        let usedEquiposAggreg = false;
        try {
          let u = `/api/equipos/estadisticas?${qs}&forceAll=1`;
          const resp = await fetchWithAuth(u);
          if (resp && resp.ok) {
            const dj = await resp.json();
            if (dj && dj.success && Array.isArray(dj.data) && dj.data.length) {
              dayData = dj.data.map(equipo => ({
                name: equipo.TEAM || equipo.team || 'Sin equipo',
                ICON: parseFloat(equipo.ICON || 0),
                ACTIVAS: parseFloat(equipo.ACTIVAS || 0),
                BAMO: parseFloat(equipo.BAMO || 0),
                Total: parseFloat(equipo.Total || 0),
                Puntaje: parseFloat(equipo.Puntaje || 0)
              }));
              usedEquiposAggreg = true;
            }
          }
        } catch(_){ /* ignorar y caer al fallback por leads */ }
        if (!usedEquiposAggreg) {
          // Construir desde /api/leads para el rango mensual calculado arriba
          try {
            const sd = start; const ed = new Date(end.getTime() - 24*60*60*1000); // end es exclusivo -> restar 1 día
            const sStr = `${sd.getFullYear()}-${String(sd.getMonth()+1).padStart(2,'0')}-${String(sd.getDate()).padStart(2,'0')}`;
            const eStr = `${ed.getFullYear()}-${String(ed.getMonth()+1).padStart(2,'0')}-${String(ed.getDate()).padStart(2,'0')}`;
            const leadsResp = await fetchWithAuth(`/api/leads?fechaInicio=${sStr}&fechaFin=${eStr}`);
            if (!leadsResp) return;
            const leadsJson = await leadsResp.json();
            leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
          } catch(e) { console.warn('prepareMonthDetails leads fallback error', e); return; }
        }
        const getByPath = (obj, path) => { try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch(_) { return undefined; } };
        const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
        const tryDateFrom = (val) => { if (!val) return null; if (typeof val === 'string') { const s = val.trim(); if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [yy,mm,dd] = s.split('-').map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) { const [dd,mm,yy] = s.split(/[\/\-]/).map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } } const dt = new Date(val); return isNaN(dt) ? null : dt; };
        const createdPaths = ['dia_venta','diaVenta','fecha_contratacion','creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha'];
        const normalizeServicio = (lead) => {
          const raw = findFirst(lead, ['servicios_texto','servicios','producto','servicio','tipoProducto','producto.nombre']);
          if (Array.isArray(raw)) return raw.map(s=>String(s).trim()).filter(Boolean).join(', ');
          return (raw ? String(raw) : '').trim();
        };

        // Watcher: if the day front table exists in DOM but remains hidden, attempt automatic recovery
        window.__startDayTableVisibilityWatcher = function(timeoutMs = 8000){
          try {
            if (window.__dayTableWatcherTimer) return;
            // ensure paused flag exists
            if (typeof window.__dayWatcherPaused === 'undefined') window.__dayWatcherPaused = false;
            const start = Date.now();
            window.__dayTableWatcherTimer = setInterval(() => {
              try {
                // if paused (we're in the middle of a flip/cleanup) avoid fighting with flip code
                if (window.__dayWatcherPaused) return;
                const vp = document.getElementById('day-flip-local');
                if (!vp) return;
                const front = vp.querySelector('.flip-face.front');
                const table = front && front.querySelector ? front.querySelector('table.sales-table') : null;
                if (!table) return;
                const cs = window.getComputedStyle(table);
                const hidden = (!cs || cs.display === 'none' || cs.visibility === 'hidden' || Number(cs.opacity) === 0 || cs.pointerEvents === 'none');
                if (hidden) {
                  try { console.log('[VIS-WATCHER] Table hidden detected, attempting restore'); } catch(_){}
                  try { if (typeof window.__ensureDayFrontVisible === 'function') window.__ensureDayFrontVisible(); } catch(_){}
                  try { front && front.classList.add('force-visible'); } catch(_){}
                  setTimeout(() => { try { front && front.classList.remove('force-visible'); } catch(_){} }, 500);
                } else {
                  // visible -> stop watcher
                  clearInterval(window.__dayTableWatcherTimer); window.__dayTableWatcherTimer = null;
                }
                if ((Date.now() - start) > timeoutMs) { clearInterval(window.__dayTableWatcherTimer); window.__dayTableWatcherTimer = null; }
              } catch(e){ try{ console.warn('[VIS-WATCHER] error', e); }catch(_){} }
            }, 300);
          } catch(e){ try{ console.warn('startDayTableVisibilityWatcher error', e); }catch(_){} }
        };

        // Kick the watcher when the script initializes so it can auto-heal intermittent cases
        try { setTimeout(() => { try { window.__startDayTableVisibilityWatcher(10000); } catch(_){} }, 800); } catch(_){}
        const normalizeAgente = (lead) => {
          const raw = findFirst(lead, ['agenteNombre','agente','createdBy','registeredBy','usuario','vendedor']);
          const val = (raw ? String(raw) : '').trim();
          return agentCanonical(val);
        };
        const inMonth = leads.filter(l => { const v = findFirst(l, createdPaths); const dt = tryDateFrom(v); return dt && dt >= start && dt < end; });
        const rows = inMonth.map(l => ({
          team: (findFirst(l, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team'])||'').toString().trim(),
          agente: normalizeAgente(l),
          servicio: normalizeServicio(l),
          mercado: (findFirst(l, ['mercado','market','producto','servicio','tipoProducto','producto.nombre'])||'').toString().toUpperCase(),
          puntaje: Number((() => { const p = findFirst(l, ['puntaje','score','puntos']); return typeof p==='number'?p:parseFloat(p)||0; })()),
          fecha: findFirst(l, createdPaths)
        }));
        window.MonthDetailRows = {
          rango: `${String(start.getDate()).padStart(2,'0')}/${String(start.getMonth()+1).padStart(2,'0')}/${start.getFullYear()} - ${String(new Date(end-1).getDate()).padStart(2,'0')}/${String(start.getMonth()+1).padStart(2,'0')}/${start.getFullYear()}`,
          rows
        };
    }

    function hideMonthDetailModal(){ const el = document.getElementById('month-detail-modal'); if (el) el.style.display = 'none'; }
    function normStr(s){
      return (s||'').toString().normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().replace(/\s+/g,'').replace(/\./g,'');
    }
    function agentCanonical(name){
      const n = normStr(name);
      const aliases = {
        // Eduardo Rivas
        'eduardor': 'Eduardo Rivas',
        'eduardorivas': 'Eduardo Rivas',
        'eduardor.': 'Eduardo Rivas',
        'eduardorrivas': 'Eduardo Rivas'
      };
      return aliases[n] || (name || '');
    }

    function showMonthDetailModal(){
      try{
        console.log('[MODAL] showMonthDetailModal invoked', { MonthDetailRows: !!window.MonthDetailRows });
        const store = window.MonthDetailRows || { rango:'', rows:[] };
        const rows = Array.isArray(store.rows) ? store.rows : [];
        const overlay = document.getElementById('month-detail-modal'); if (!overlay) return;
        const tbody = overlay.querySelector('#month-detail-table tbody');
        const selTeam = overlay.querySelector('#month-filter-team');
        const selAgent = overlay.querySelector('#month-filter-agent');
        const subtitle = overlay.querySelector('#month-detail-subtitle');
        subtitle.textContent = `Rango: ${store.rango}`;
        const teams = Array.from(new Set(rows.map(r => (r.team||'').toString().trim()).filter(Boolean))).sort();
        selTeam.innerHTML = `<option value="">Todos</option>` + teams.map(t=>`<option value="${t}">${t}</option>`).join('');
        function refreshAgents(){
          const team = selTeam.value;
          const agents = Array.from(new Set(rows
            .filter(r => !team || r.team === team)
            .map(r => (r.agente||'').toString().trim())
            .filter(Boolean)))
            .sort();
          selAgent.innerHTML = `<option value="">Todos</option>` + agents.map(a=>`<option value="${a}">${a}</option>`).join('');
        }
        function render(){
          const team = selTeam.value; const agent = selAgent.value;
          const agentNorm = normStr(agent);
          const data = rows.filter(r => {
            const okTeam = (!team || r.team === team);
            if (!okTeam) return false;
            if (!agent) return true;
            return normStr(r.agente) === agentNorm;
          });
          tbody.innerHTML = data.map(r => `
            <tr>
              <td>${r.team || ''}</td>
              <td>${r.agente || ''}</td>
              <td>${r.servicio || ''}</td>
              <td>${r.mercado || ''}</td>
              <td>${Number(r.puntaje||0).toFixed(2)}</td>
              <td>${typeof r.fecha==='string' ? r.fecha : (r.fecha instanceof Date ? r.fecha.toISOString() : (r.fecha||''))}</td>
            </tr>
          `).join('');
        }
        refreshAgents();
        render();
        selTeam.onchange = () => { refreshAgents(); render(); };
        selAgent.onchange = () => { render(); };
        overlay.style.display = 'flex';
      } catch(e){ console.error('Error abriendo detalle mensual', e); }
    }

    // Inserta el botón dentro de la tarjeta mensual cuando exista en el DOM
    function injectMonthlyDetailButton(attempt = 0){
      const root = document.getElementById('conversion-table');
      const card = root ? root.querySelector('.conversion-card') : null;
      if (!card) {
        if (attempt < 20) return setTimeout(() => injectMonthlyDetailButton(attempt + 1), 300);
        return;
      }
      if (card.querySelector('#btn-detalle-mensual')) return;
      const toolbar = document.createElement('div');
      toolbar.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin:8px 0 6px;';
      const navDiv = document.createElement('div');
      navDiv.style.cssText = 'display:flex; gap:6px;';
      const btnPrev = document.createElement('button');
      btnPrev.id = 'month-prev';
      btnPrev.className = 'filter-button';
      btnPrev.style.cssText = 'height:28px;width:32px;';
      btnPrev.title = 'Mes anterior';
      btnPrev.textContent = '◀';
      const btnNext = document.createElement('button');
      btnNext.id = 'month-next';
      btnNext.className = 'filter-button';
      btnNext.style.cssText = 'height:28px;width:32px;';
      btnNext.title = 'Mes siguiente';
      btnNext.textContent = '▶';
      navDiv.appendChild(btnPrev);
      navDiv.appendChild(btnNext);
      const actionsDiv = document.createElement('div');
      actionsDiv.style.cssText = 'display:flex; gap:8px;';
      // Botón Flip ↻
      const btnFlip = document.createElement('button');
      btnFlip.id = 'btn-flip-monthly';
      btnFlip.className = 'filter-button';
      btnFlip.title = 'Ver gráfica';
      btnFlip.textContent = '↻';
      btnFlip.style.cssText = 'height:28px;width:32px;font-weight:700;';
      const btn = document.createElement('button');
      btn.id = 'btn-detalle-mensual';
      btn.className = 'filter-button';
      btn.style.height = '28px';
      btn.textContent = 'Ver detalle mensual';
      btn.addEventListener('click', () => { try { showMonthDetailModal(); } catch(e){ console.error(e); } });
      actionsDiv.appendChild(btn);
      actionsDiv.appendChild(btnFlip);
      toolbar.appendChild(navDiv);
      toolbar.appendChild(actionsDiv);
      // Hook flechas navegación mes
      const urlParams = new URLSearchParams(location.search);
      const mParam = urlParams.get('m');
      let base;
      if (mParam && /^\d{4}-\d{2}$/.test(mParam)) {
        const [y,m] = mParam.split('-').map(Number);
        base = new Date(y, m-1, 15);
      } else {
        base = new Date();
      }
      btnPrev.onclick = () => {
        const next = (window.__tablaMesFecha instanceof Date && !Number.isNaN(window.__tablaMesFecha.getTime()))
          ? new Date(window.__tablaMesFecha)
          : new Date(base);
        next.setMonth(next.getMonth() - 1);
        loadConversionTableForMonth(next);
      };
      btnNext.onclick = () => {
        const next = (window.__tablaMesFecha instanceof Date && !Number.isNaN(window.__tablaMesFecha.getTime()))
          ? new Date(window.__tablaMesFecha)
          : new Date(base);
        next.setMonth(next.getMonth() + 1);
        loadConversionTableForMonth(next);
      };
      const convTwoCol = card.querySelector('.conv-two-col');
      if (convTwoCol) card.insertBefore(toolbar, convTwoCol); else card.appendChild(toolbar);
    }

    // Función para cargar y renderizar la tabla del Día con el mismo diseño que la del Mes
    async function loadDayData(targetDate = null, options = {}) {
      console.log('Cargando datos del día...', targetDate);
      const container = document.getElementById('ventas-dia-card');
      if (!container) {
        console.error('No se encontró el contenedor #ventas-dia-card');
        return;
      }

      const { skipHistory = false } = options || {};
      const cutoffHour = 9;
      const cutoffMinute = 30;

      const getBusinessToday = () => {
        const snapshot = getBusinessSnapshot(new Date());
        if (!snapshot) return new Date();
        const cutoffMinutesTotal = cutoffHour * 60 + cutoffMinute;
        const minutesNow = snapshot.hours * 60 + snapshot.minutes;
        const anchor = new Date(snapshot.year, snapshot.month, snapshot.day, 12, 0, 0);
        if (minutesNow < cutoffMinutesTotal) anchor.setDate(anchor.getDate() - 1);
        return anchor;
      };

      const computeDefaultDate = () => {
        const businessToday = getBusinessToday();
        debugBusinessDate('businessToday', businessToday);
        const params = new URLSearchParams(location.search);
        const dParam = params.get('d');
        if (dParam && /^\d{4}-\d{2}-\d{2}$/.test(dParam)) {
          const [y, m, d] = dParam.split('-').map(Number);
          const candidate = new Date(y, (m || 1) - 1, d || 1, 12, 0, 0);
          debugBusinessDate('candidateFromURL', candidate);
          if (!Number.isNaN(candidate.getTime()) && candidate.getTime() <= businessToday.getTime()) {
            return candidate;
          }
          return new Date(businessToday.getTime());
        }
        return new Date(businessToday.getTime());
      };

      const normalizeTarget = (value) => {
        if (!value) return null;
        if (value instanceof Date) {
          return new Date(value.getFullYear(), value.getMonth(), value.getDate(), 12, 0, 0);
        }
        if (typeof value === 'string') {
          if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
            const [y, m, d] = value.split('-').map(Number);
            return new Date(y, m - 1, d, 12, 0, 0);
          }
          const parsed = new Date(value);
          if (!isNaN(parsed)) {
            return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate(), 12, 0, 0);
          }
        }
        const parsed = new Date(value);
        if (!isNaN(parsed)) {
          return new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate(), 12, 0, 0);
        }
        return null;
      };

      let effective = normalizeTarget(targetDate);
      const businessToday = getBusinessToday();
      if (effective && !Number.isNaN(effective.getTime()) && effective.getTime() > businessToday.getTime()) {
        try {
          console.warn('[ESTADISTICAS][DIA] Fecha solicitada futura detectada, ajustando al día vigente', { requested: effective, businessToday });
        } catch (_) {}
        effective = new Date(businessToday.getTime());
      }
      if (!effective || Number.isNaN(effective.getTime())) {
        effective = computeDefaultDate();
      }
      debugBusinessDate('effectiveAfterNormalize', effective);
      if (!effective || Number.isNaN(effective.getTime())) {
        effective = computeDefaultDate();
        debugBusinessDate('effectiveFallback', effective);
      }

      window.__currentDayDate = new Date(effective.getTime());
      const formattedParam = `${effective.getFullYear()}-${String(effective.getMonth()+1).padStart(2,'0')}-${String(effective.getDate()).padStart(2,'0')}`;
      try {
        const url = new URL(window.location.href);
        if (url.searchParams.get('d') !== formattedParam) {
          url.searchParams.set('d', formattedParam);
          if (!skipHistory) {
            window.history.replaceState({}, '', url);
          }
        }
      } catch (navErr) {
        console.warn('No se pudo actualizar la URL para el día seleccionado:', navErr);
      }

      const diaTexto = `${String(effective.getDate()).padStart(2,'0')}/${String(effective.getMonth()+1).padStart(2,'0')}/${effective.getFullYear()}`;

      // Placeholder de carga
      container.innerHTML = `
        <div class="text-center" style="padding: 12px; color:#666;">Cargando datos del día...</div>
      `;

      try {
        // 1) Construir SIEMPRE desde /api/leads (global, sin filtrar por agente)
        const y = effective.getFullYear();
        const m = String(effective.getMonth()+1).padStart(2,'0');
        const d = String(effective.getDate()).padStart(2,'0');
        const qs = `fechaInicio=${y}-${m}-${d}&fechaFin=${y}-${m}-${d}&scope=day`;
        let dayData = [];
        const startLocal = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate(), 0, 0, 0, 0);
        // Si navegamos con ?d=, capturar TODO el día (00:00 a 23:59:59)
        const urlParams = new URLSearchParams(location.search);
        const isNavigating = urlParams.has('d');
        const endExclusive = isNavigating 
          ? new Date(effective.getFullYear(), effective.getMonth(), effective.getDate() + 1, 0, 0, 0, 0)
          : new Date(effective.getFullYear(), effective.getMonth(), effective.getDate() + 1, cutoffHour, cutoffMinute, 0, 0);
        const leadsResp = await fetchWithAuth(`/api/leads?fechaInicio=${y}-${m}-${d}&fechaFin=${y}-${m}-${d}&skipDate=1&t=${Date.now()}`);
        if (!leadsResp) return;
        const leadsJson = await leadsResp.json();
        const leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
        const getByPath = (obj, path) => { try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch (_) { return undefined; } };
        const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
        const tryDateFrom = (val) => { if (!val) return null; if (typeof val === 'string') { const s = val.trim(); if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [yy,mm,dd] = s.split('-').map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) { const [dd,mm,yy] = s.split(/[\/\-]/).map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } } const dt = new Date(val); return isNaN(dt) ? null : dt; };
        const createdPaths = ['dia_venta','diaVenta','fecha_contratacion','creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha'];
        // Funciones de ayuda para comparar el mismo día, soportando múltiples formatos
        const pad2 = (n)=> String(n).padStart(2,'0');
        const ymd = `${y}-${m}-${d}`; // YYYY-MM-DD del día efectivo
        const dmyNoPad = `${Number(d)}/${Number(m)}/${y}`; // D/M/YYYY
        const dmyPad = `${d}/${m}/${y}`; // DD/MM/YYYY
        const engMonth = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][effective.getMonth()];
        const engRegex = new RegExp(`\\b${engMonth}\\b\\s+${Number(d)}\\s+${y}`, 'i');
        const sameLocalDay = (dt) => dt && dt >= startLocal && dt < endExclusive;
        const isSameDayAny = (val) => {
          if (!val && val !== 0) return false;
          if (val instanceof Date) return sameLocalDay(val);
          if (typeof val === 'number') return sameLocalDay(new Date(val < 1e12 ? val*1000 : val));
          const s = String(val).trim();
          if (!s) return false;
          if (s === ymd || s === dmyNoPad || s === dmyPad) return true;
          if (engRegex.test(s)) return true;
          const dt = tryDateFrom(s);
          return sameLocalDay(dt);
        };
        const inDay = leads.filter(l => {
          const v = findFirst(l, createdPaths);
          return isSameDayAny(v);
        });
        // Construir filas de detalle (agente, servicio, etc.) y exponerlas globalmente
        const normalizeServicio = (lead) => {
          const raw = findFirst(lead, ['servicios_texto','servicios','producto','servicio','tipoProducto','producto.nombre']);
          if (Array.isArray(raw)) return raw.map(s=>String(s).trim()).filter(Boolean).join(', ');
          return (raw ? String(raw) : '').trim();
        };
        const normalizeAgente = (lead) => {
          const raw = findFirst(lead, ['agenteNombre','agente','createdBy','registeredBy','usuario','vendedor']);
          return (raw ? String(raw) : '').trim();
        };
        const teamNameOf = (lead) => {
          const t = findFirst(lead, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']);
          const s = (t || '').toString().trim(); return s || 'Sin equipo';
        };
        const mercadoOf = (lead) => (String(findFirst(lead, ['mercado','market','producto','servicio','tipoProducto','producto.nombre'])||'').toUpperCase());
        const puntajeOf = (lead) => { const p = findFirst(lead, ['puntaje','score','puntos']); const n = typeof p === 'number' ? p : parseFloat(p); return isNaN(n) ? 0 : n; };
        const sanitize = (value) => (value || '').toString().trim().toUpperCase();
        const onlyDigits = (value) => (value || '').toString().replace(/\D+/g, '');
        const dedupeKeyOf = (lead) => {
          const numeroCuenta = sanitize(findFirst(lead, ['numero_cuenta','numeroCuenta','accountNumber']));
          const telefono = onlyDigits(findFirst(lead, ['telefono_principal','telefonoPrincipal','telefono']));
          const diaVenta = sanitize(findFirst(lead, ['dia_venta','diaVenta','fecha_contratacion','fecha','createdAt','created_at']));
          const servicio = sanitize(findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']));
          const parts = [numeroCuenta, telefono, diaVenta, servicio].filter(Boolean);
          if (parts.length) return parts.join('|');
          const fallbackId = sanitize(findFirst(lead, ['_id','id','uid']));
          return fallbackId || JSON.stringify(lead);
        };

        const dedupedDay = [];
        // Use Map to prefer lead with higher puntaje, then newer fecha_creacion when duplicates found
        const dedupeMap = new Map();
        for (const lead of inDay) {
          const key = dedupeKeyOf(lead);
          if (!key) { dedupedDay.push(lead); continue; }
          const current = dedupeMap.get(key);
          if (!current) { dedupeMap.set(key, lead); continue; }
          try {
            const scoreA = Number(current.puntaje || current.score || 0);
            const scoreB = Number(lead.puntaje || lead.score || 0);
            if (scoreB > scoreA) { dedupeMap.set(key, lead); continue; }
            if (scoreB < scoreA) { continue; }
            const dateA = new Date(current.fecha_creacion || current.creadoEn || current.createdAt || current.creado || 0).getTime() || 0;
            const dateB = new Date(lead.fecha_creacion || lead.creadoEn || lead.createdAt || lead.creado || 0).getTime() || 0;
            if (dateB >= dateA) { dedupeMap.set(key, lead); }
          } catch (_) { /* ignore errors and keep current */ }
        }
        for (const v of dedupeMap.values()) dedupedDay.push(v);

        try {
          const sampleDates = dedupedDay.slice(0, 10).map((lead, idx) => ({
            idx,
            cuenta: sanitize(findFirst(lead, ['numero_cuenta','numeroCuenta','accountNumber'])),
            diaVenta: findFirst(lead, ['dia_venta','diaVenta','fecha_contratacion','fecha']),
            creadoEn: findFirst(lead, ['createdAt','created_at','creadoEn','fechaCreacion','fecha_creacion'])
          }));
          console.log('[ESTADISTICAS][DIA] Muestra de fechas procesadas para el día:', sampleDates);
        } catch (sampleErr) {
          console.warn('[ESTADISTICAS][DIA] No se pudo generar muestra de fechas', sampleErr);
        }

        const detailRows = dedupedDay.map(l => {
          const team = (findFirst(l, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']) || '').toString().trim();
          const servicio = normalizeServicio(l);
          const mercado = (findFirst(l, ['mercado','market','producto','servicio','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
          const pRaw = findFirst(l, ['puntaje','score','puntos']);
          const puntaje = typeof pRaw === 'number' ? pRaw : parseFloat(pRaw) || 0;
          const agente = normalizeAgente(l);
          const fechaFuente = findFirst(l, createdPaths);
          return { team, agente, servicio, mercado, puntaje: Number(puntaje || 0), fecha: fechaFuente };
        });
        try {
          console.table(detailRows.map(r => ({ team: r.team, puntaje: r.puntaje, fecha: r.fecha })).slice(0, 10));
        } catch (_) {}
        window.DayDetailRows = { fecha: `${String(effective.getDate()).padStart(2,'0')}/${String(effective.getMonth()+1).padStart(2,'0')}/${effective.getFullYear()}`, rows: detailRows };

        const aggregatedFromLeads = (() => {
          const map = new Map();
          dedupedDay.forEach(l => {
            const name = teamNameOf(l);
            if (!map.has(name)) map.set(name, { name, ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });
            const agg = map.get(name);
            agg.Total += 1;
            const mk = mercadoOf(l);
            if (mk.includes('ICON')) agg.ICON += 1;
            else if (mk.includes('BAMO')) agg.BAMO += 1;
            agg.Puntaje += puntajeOf(l);
          });
          return Array.from(map.values());
        })();

        const norm = (value) => String(value || '').normalize('NFD').replace(/\p{Diacritic}+/gu, '').trim();
        const canonicalTeam = (rawName) => {
          const n = norm(rawName).toLowerCase().replace(/^team\s+/, '');
          if (!n) return 'Sin equipo';
          if (n.includes('pleitez')) return 'Pleitez';
          if (n.includes('roberto')) return 'Roberto';
          if (n.includes('marisol')) return 'Marisol';
          if (n.includes('johana') || n.includes('johanna')) return 'Johana';
          if (n.includes('irania')) return 'Irania';
          return norm(rawName) || 'Sin equipo';
        };
        const mapLineasRecord = (entry = {}) => {
          const rawName = entry.name || entry.TEAM || entry.team || entry.supervisor || entry.Supervisor || 'Sin nombre';
          const displayName = canonicalTeam(rawName);
          const icon = Number(entry.ICON ?? entry.icon ?? 0) || 0;
          const bamo = Number(entry.BAMO ?? entry.bamo ?? 0) || 0;
          let total = Number(entry.Total ?? entry.total ?? entry.ICON ?? entry.icon ?? 0);
          if (!Number.isFinite(total) || total === 0) total = icon + bamo;
          let activas = Number(entry.ACTIVAS ?? entry.activas ?? entry.Activas ?? entry.activasTotales ?? 0);
          if (!Number.isFinite(activas) || activas === 0) activas = total;
          const puntajeRaw = entry.Puntaje ?? entry.puntaje ?? entry.score;
          const puntaje = Number.isFinite(Number(puntajeRaw)) ? Number(puntajeRaw) : 0;
          return {
            name: displayName,
            ACTIVAS: activas,
            ICON: icon,
            BAMO: bamo,
            Total: total,
            Puntaje: puntaje
          };
        };

        const KNOWN_LINEAS_PATTERNS = ['linea','línea','teamlineas','team lineas','team linea','lineas','jonathan','luis g','luisg','jonathanf','jonathan f','supervisor team lineas'];
        const normalizeForMatch = (value) => {
          if (value == null) return '';
          return value.toString().toLowerCase().normalize('NFD').replace(/\p{Diacritic}+/gu, '');
        };
        const isTeamLineasCandidate = (value) => {
          const normalized = normalizeForMatch(value);
          if (!normalized) return false;
          return KNOWN_LINEAS_PATTERNS.some(pattern => normalized.includes(pattern));
        };
        const isTeamLineasLead = (lead) => {
          const candidates = [
            teamNameOf(lead),
            findFirst(lead, ['lineaSupervisor','lineasSupervisor','supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']),
            findFirst(lead, ['agenteNombre','agente','createdBy','usuario','owner','ownerName','username'])
          ];
          return candidates.some(isTeamLineasCandidate);
        };
        const aggregatedLineasFromLeads = (() => {
          const map = new Map();
          dedupedDay.forEach(lead => {
            if (!isTeamLineasLead(lead)) return;
            const supervisorRaw = findFirst(lead, ['lineaSupervisor','lineasSupervisor','supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']);
            const key = canonicalTeam(supervisorRaw || teamNameOf(lead));
            if (!map.has(key)) {
              map.set(key, { name: key, ICON: 0, BAMO: 0, Total: 0, Puntaje: 0, ACTIVAS: 0 });
            }
            const agg = map.get(key);
            agg.Total += 1;
            agg.ACTIVAS += 1;
            const mk = mercadoOf(lead);
            if (mk.includes('ICON')) agg.ICON += 1;
            else if (mk.includes('BAMO')) agg.BAMO += 1;
            agg.Puntaje += puntajeOf(lead);
          });
          return Array.from(map.values()).map(mapLineasRecord);
        })();

        // Intentar agregado del día desde backend (global)
        let preTeamData = null;
        let lineasDataFromBackend = [];
        try {
          const dayUrl = `/api/equipos/estadisticas?${qs}&scope=day&forceAll=1`;
          console.log('[DÍA] Solicitando datos a:', dayUrl);
          const aggResp = await fetchWithAuth(dayUrl);
          if (aggResp && aggResp.ok) {
            const dj = await aggResp.json();
            console.log('[DÍA] Respuesta del backend:', dj);
            if (dj && dj.success) {
              // Procesar datos principales
              if (Array.isArray(dj.data) && dj.data.length) {
                preTeamData = dj.data.map(equipo => ({
                  name: equipo.TEAM || equipo.team || 'Sin equipo',
                  ICON: parseFloat(equipo.ICON || 0),
                  ACTIVAS: parseFloat(equipo.ACTIVAS || 0),
                  BAMO: parseFloat(equipo.BAMO || 0),
                  Total: parseFloat(equipo.Total || 0),
                  Puntaje: parseFloat(equipo.Puntaje || 0)
                }));
                console.log('[DÍA] Datos procesados:', preTeamData);
              }
              // Procesar datos de TEAM LINEAS (supervisores)
              if (Array.isArray(dj.lineas) && dj.lineas.length) {
                lineasDataFromBackend = dj.lineas.map(mapLineasRecord);
                console.log('[DÍA] Datos LINEAS procesados:', lineasDataFromBackend);
              }
            }
          }
        } catch(err) { console.error('[DÍA] Error en fetch principal:', err); }
        // Fallback: si no retornó datos o todo es cero y estamos viendo HOY, consulta sin fechas (scope=day)
        try {
          const sum = (arr)=> (arr||[]).reduce((a,r)=>a+(r.Total||0),0);
          const isTodayView = !new URLSearchParams(location.search).has('d');
          if ((!preTeamData || sum(preTeamData)===0) && isTodayView) {
            console.log('[DÍA] Usando fallback para HOY (sin fechas específicas)');
            const alt = await fetchWithAuth(`/api/equipos/estadisticas?scope=day&forceAll=1`);
            if (alt && alt.ok) {
              const dj2 = await alt.json();
              if (dj2 && dj2.success && Array.isArray(dj2.data) && dj2.data.length) {
                preTeamData = dj2.data.map(equipo => ({
                  name: equipo.TEAM || equipo.team || 'Sin equipo',
                  ICON: parseFloat(((equipo.ACTIVAS !== undefined) ? equipo.ACTIVAS : equipo.ICON) || 0),
                  BAMO: parseFloat(equipo.BAMO || 0),
                  Total: parseFloat(equipo.Total || 0),
                  Puntaje: parseFloat(equipo.Puntaje || 0)
                }));
              }
            }
          }
        } catch(_) {}

        const sumTotals = (arr) => (arr || []).reduce((acc, r) => acc + (Number(r.Total) || 0), 0);
        if (preTeamData) {
          const backendTotal = sumTotals(preTeamData);
          const leadTotal = sumTotals(aggregatedFromLeads);
          if (leadTotal && Math.abs(leadTotal - backendTotal) >= 1) {
            console.warn('[ESTADISTICAS][DIA] Desajuste entre backend y leads deduplicados. Usando agregados locales.', {
              backendTotal,
              leadTotal
            });
            dayData = aggregatedFromLeads;
          } else {
            dayData = preTeamData;
          }
        } else {
          dayData = aggregatedFromLeads;
        }

        // Usar datos de LINEAS del backend si están disponibles, de lo contrario, construirlos desde los leads del día
        let lineasData = lineasDataFromBackend.length > 0 ? lineasDataFromBackend : aggregatedLineasFromLeads;

        const lineasTotals = { ACTIVAS: 0, ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 };
        (lineasData || []).forEach(r => {
          lineasTotals.ACTIVAS += Number(r.ACTIVAS) || 0;
          lineasTotals.ICON += Number(r.ICON) || 0;
          lineasTotals.BAMO += Number(r.BAMO) || 0;
          lineasTotals.Total += Number(r.Total) || 0;
          lineasTotals.Puntaje += Number(r.Puntaje) || 0;
        });

        // Filtrar datos principales: excluir los nombres que están en lineasData
        const lineasNames = new Set(lineasData.map(l => canonicalTeam(l.name).toLowerCase()));
        const ORDER_ALL = ['Pleitez','Roberto','Marisol','Johana','Irania'];
        const orderKeys = new Set(ORDER_ALL.map(name => name.toLowerCase()));
        const teamMap = new Map();
        const extraTeams = [];

        (dayData || []).forEach(team => {
          const key = canonicalTeam(team.name);
          if (lineasNames.has(key.toLowerCase())) return;
          const record = {
            ...team,
            name: key,
            ICON: Number(team.ICON) || 0,
            BAMO: Number(team.BAMO) || 0,
            Total: Number(team.Total) || 0,
            Puntaje: Number(team.Puntaje) || 0
          };
          if (orderKeys.has(key.toLowerCase())) {
            teamMap.set(key.toLowerCase(), record);
          } else {
            extraTeams.push(record);
          }
        });

        let mainData = ORDER_ALL.map(name => {
          const entry = teamMap.get(name.toLowerCase());
          return entry || { name, ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 };
        });
        if (extraTeams.length) {
          mainData = mainData.concat(extraTeams);
        }

        try {
          // Persist rows so other widgets (detalle/modal/LINEAS) reuse the deduplicated data without refetching
          window.dayData = Array.isArray(mainData) ? mainData.slice() : [];
          window.DayDisplayRows = window.dayData.slice();
          window.DayRowsOriginal = window.dayData.slice();
          window.DayLineasData = Array.isArray(lineasData) ? lineasData.slice() : [];
        } catch(_) { /* ignore storage errors */ }

        // (removed duplicate ensureDayRows + porcentaje helper block) - functionality
        // moved to top-level to avoid nested IIFE interference and syntax issues.

          // Helper to force the day card back to its front (table) view and clean up daily chart
          window.__ensureDayFrontVisible = function(){
            try {
              const vp = document.getElementById('day-flip-local');
              if (!vp) return;
              if (!vp.classList.contains('is-flipped')) return;
              const scene = vp.querySelector('.flip-scene');
              const frontFace = vp.querySelector('.flip-face.front');
              // Temporarily disable transition to avoid any transitionend handlers re-hiding the front
              let prevTrans = '';
              try { prevTrans = scene && scene.style ? scene.style.transition || '' : ''; if (scene && scene.style) scene.style.transition = 'none'; } catch(_){}
              // remove flipped state so front becomes visible immediately
              vp.classList.remove('is-flipped');
              try { if (frontFace) { frontFace.classList.remove('flip-front-hidden'); frontFace.classList.add('force-visible'); } } catch(_){ }
              // restore any hidden sticky elements stored earlier
              try {
                const hidden = vp && vp.__hiddenSticky;
                if (hidden && Array.isArray(hidden)) {
                  hidden.forEach(item => { try{ item.el.style.visibility = item.vis || ''; } catch(_){} });
                  vp.__hiddenSticky = null;
                }
              } catch(_){ }
              try { if (window.__dailyChart) { window.__dailyChart.destroy(); window.__dailyChart = null; } } catch(_){ }
              const wrap = vp.querySelector('.chart-wrapper');
              if (wrap) { try { wrap.style.height = ''; wrap.style.maxHeight = ''; wrap.style.overflow = ''; wrap.style.paddingBottom = ''; } catch(_){} }
              // Forcefully restore any table elements inside the front face (in case they were hidden)
              try {
                const tables = (frontFace && frontFace.querySelectorAll) ? Array.from(frontFace.querySelectorAll('table')) : [];
                tables.forEach(tbl => {
                  try {
                    tbl.style.display = '';
                    tbl.style.visibility = 'visible';
                    tbl.style.opacity = '1';
                    tbl.style.pointerEvents = '';
                    try { tbl.style.setProperty('visibility','visible','important'); tbl.style.setProperty('display','table','important'); tbl.style.setProperty('opacity','1','important'); } catch(_){}
                  } catch(_){}
                });
              } catch(_){}
              // Also force the front face visible with !important to override any lingering CSS rules
              try { if (frontFace) { frontFace.style.setProperty('visibility','visible','important'); frontFace.style.setProperty('display','block','important'); frontFace.style.setProperty('opacity','1','important'); } } catch(_){}
              // force reflow then restore transition
              try { void vp.offsetHeight; if (scene && scene.style) scene.style.transition = prevTrans || 'transform 360ms cubic-bezier(.2,.8,.2,1)'; } catch(_){}
              setTimeout(() => { try { vp.style.height = ''; vp.style.minHeight = ''; if (scene) { scene.style.minHeight = ''; scene.style.height = ''; } } catch(_){} }, 200);
              window.__dayFlipAnimating = false;
            } catch(e){ console.warn('ensureDayFrontVisible error', e); }
          };

        // Utility: aggressively clear any inline visibility/display styles that may hide the day front/table
        window.__clearDayHiddenStyles = function(){
          try {
            console.log('[__clearDayHiddenStyles] running');
            const root = document.getElementById('ventas-dia-card');
            if (!root) { console.log('[__clearDayHiddenStyles] no root found'); return; }
            // Clear inline visibility:hidden on the front face and any tables inside
            const vp = root.querySelector('#day-flip-local') || root.querySelector('.conversion-card');
            if (!vp) { console.log('[__clearDayHiddenStyles] no vp found'); return; }
            const fronts = vp.querySelectorAll ? vp.querySelectorAll('.flip-face.front, .conversion-card, .conv-left, .conv-two-col') : [];
            Array.from(fronts).forEach(el => {
              try {
                // remove specific inline properties that may force hidden state
                if (el.style) {
                  if (el.style.visibility && el.style.visibility.indexOf('hidden') !== -1) el.style.visibility = '';
                  if (el.style.display && el.style.display.indexOf('none') !== -1) el.style.display = '';
                  el.style.opacity = el.style.opacity === '0' ? '' : el.style.opacity;
                  el.style.pointerEvents = el.style.pointerEvents === 'none' ? '' : el.style.pointerEvents;
                  el.style.transform = el.style.transform === 'none' ? '' : el.style.transform;
                }
              } catch(_){}
            });
            // Also clear any tables specifically
            const tables = vp.querySelectorAll ? vp.querySelectorAll('table') : [];
            Array.from(tables).forEach(tbl => {
              try {
                if (tbl.style) {
                  if (tbl.style.visibility && tbl.style.visibility.indexOf('hidden') !== -1) tbl.style.visibility = '';
                  if (tbl.style.display && tbl.style.display.indexOf('none') !== -1) tbl.style.display = '';
                  if (tbl.style.opacity === '0') tbl.style.opacity = '';
                  tbl.style.pointerEvents = '';
                }
              } catch(_){}
            });
            // Finally, ensure the root container isn't hidden
            try { if (root.style && root.style.visibility && root.style.visibility.indexOf('hidden') !== -1) root.style.visibility = ''; } catch(_){ }
            try { console.log('[__clearDayHiddenStyles] cleared, tables:', (tables && tables.length) || 0); } catch(_){ }
          } catch(e){ try{ console.warn('__clearDayHiddenStyles error', e); }catch(_){} }
        };

        // Install a MutationObserver to auto-clear any inline visibility:hidden on the day front/table
        window.__installDayVisibilityObserver = function(){
          try {
            if (window.__dayVisibilityObserver) return;
            const root = document.getElementById('ventas-dia-card');
            try { console.log('[VIS-OBSERVER] installing for #ventas-dia-card', !!root); } catch(_){ }
            if (!root) return;
            const obs = new MutationObserver((mutations) => {
              try {
                for (const m of mutations) {
                  if (m.type === 'attributes' && (m.attributeName === 'style' || m.attributeName === 'class')) {
                    const el = m.target;
                    try {
                      const cs = window.getComputedStyle(el);
                      if (cs && cs.visibility === 'hidden' && cs.display !== 'none') {
                        try { console.log('[VIS-OBSERVER] clearing hidden style on', el); } catch(_){}
                        el.style.visibility = '';
                        el.style.display = '';
                        el.style.opacity = '';
                        el.style.pointerEvents = '';
                        el.style.transform = '';
                      }
                    } catch(_){}
                  }
                  if (m.addedNodes && m.addedNodes.length) {
                    Array.from(m.addedNodes).forEach(n => {
                      if (n.nodeType !== 1) return;
                      try {
                        const targets = n.querySelectorAll ? n.querySelectorAll('.flip-face.front, table') : [];
                        Array.from(targets).forEach(el => {
                          try {
                            const cs = window.getComputedStyle(el);
                            if (cs && cs.visibility === 'hidden' && cs.display !== 'none') {
                              try { console.log('[VIS-OBSERVER] clearing hidden on added node', el); } catch(_){}
                              el.style.visibility = '';
                              el.style.display = '';
                              el.style.opacity = '';
                              el.style.pointerEvents = '';
                              el.style.transform = '';
                            }
                          } catch(_){}
                        });
                      } catch(_){}
                    });
                  }
                }
              } catch(e){ try{ console.warn('[VIS-OBSERVER] error', e); }catch(_){} }
            });
            obs.observe(root, { attributes: true, childList: true, subtree: true, attributeFilter: ['style','class'] });
            window.__dayVisibilityObserver = obs;
            try { console.log('[VIS-OBSERVER] installed'); } catch(_){ }
          } catch(e){ try{ console.warn('installDayVisibilityObserver error', e); }catch(_){} }
        };

        // Construir bloque del DÍA (título, flechas y panel derecho) SIN el contenedor externo
        const tablaHtml = `
          <div class="conversion-card">
            <div class="conversion-title-wrapper">
              <button id="day-prev-alt" class="filter-button day-nav-btn" title="Día anterior">◀</button>
              <div class="conversion-title">VENTAS DEL DÍA (${diaTexto})</div>
              <button id="day-next-alt" class="filter-button day-nav-btn" title="Día siguiente">▶</button>
            </div>
            <div style="display:flex; justify-content:flex-end; margin:8px 0 6px; gap:8px;">
              <button id="btn-detalle-dia" class="filter-button">Ver detalle</button>
            </div>
            <div class="conv-two-col slide-container">
              <div class="conv-left">
                <table class="sales-table" style="width:100%">
                <thead>
                  <tr>
                    <th>EQUIPO</th>
                    <th>ICON</th>
                    <th>BAMO</th>
                    <th>TOTAL</th>
                    <th>PUNTAJE</th>
                  </tr>
                </thead>
                <tbody>
                  ${mainData.map(team => `
                    <tr>
                      <td>${team.name}</td>
                      <td>${team.ICON || 0}</td>
                      <td>${team.BAMO || 0}</td>
                      <td>${team.Total || 0}</td>
                      <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                    </tr>
                  `).join('')}
                  <tr class="total-row">
                    <td>TOTAL</td>
                    <td>${mainData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                    <td>${mainData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                    <td>${mainData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                    <td>${mainData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(2)}</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="conv-right">
              <div class="mini-card">
                <table class="mini-table">
                  <thead>
                    <tr>
                      <th>SUPERVISOR</th>
                      <th>ICON</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${(lineasData && lineasData.length) ? lineasData.map(r => `
                      <tr>
                        <td>${r.name}</td>
                        <td>${Number(r.ICON || 0)}</td>
                      </tr>
                    `).join('') : `
                      <tr>
                        <td colspan="2" class="empty-row">Sin datos de TEAM LINEAS para este día</td>
                      </tr>
                    `}
                    ${(lineasData && lineasData.length) ? `
                      <tr class="total">
                        <td>TOTAL</td>
                        <td class="total-icon">${lineasTotals.ICON}</td>
                      </tr>
                    ` : ''}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          </div>
        `;

  container.innerHTML = tablaHtml;
  try {
    const currentTitle = container.querySelector('.conversion-title');
    console.log('[ESTADISTICAS][DIA] Título tras renderizar tabla:', diaTexto, currentTitle ? currentTitle.textContent : null);
  } catch (e) {
    console.warn('[ESTADISTICAS][DIA] No se pudo inspeccionar el título renderizado', e);
  }
  // Clear any stray inline hidden styles that some browsers may have left behind
  try { if (typeof window.__clearDayHiddenStyles === 'function') window.__clearDayHiddenStyles(); } catch(_){ }
  // Ensure the flip button is injected after we render the day card
  try { if (typeof window.injectDayFlipButton === 'function') window.injectDayFlipButton(); } catch(_){ }
        // Hook botón detalle (con fallback y delegación)
        try {
          const openDetail = () => {
            try { if (typeof ensureDayDetailModal === 'function') ensureDayDetailModal(); } catch(_){}
            try { showDayDetailModal(); }
            catch(e){
              console.warn('Fallback abrir detalle del día', e);
              const overlay = document.getElementById('day-detail-modal');
              if (overlay) overlay.style.display = 'flex';
            }
          };
          const btnDet = document.getElementById('btn-detalle-dia');
          if (btnDet) btnDet.addEventListener('click', openDetail);
          // Delegación por si el botón se re-renderiza
          container.addEventListener('click', (ev)=>{
            const t = ev.target;
            if (t && t.id === 'btn-detalle-dia') { ev.preventDefault(); openDetail(); }
          });
        } catch(_) {}
        // Safety enforcement: on Sundays, force display order to GROUP B in the DOM
        try {
          const dowToday = (new Date()).getDay(); // 0=Sun
          if (dowToday === 0) {
            const ORDER_B = ['Pleitez','Roberto','Marisol'];
            const card = container.querySelector('.conversion-card');
            const tbody = card && card.querySelector('.sales-table tbody');
            if (tbody) {
              const totalRow = tbody.querySelector('.total-row');
              const totalHTML = totalRow ? totalRow.outerHTML : '';
              const buildRow = (name)=>`<tr><td>${name}</td><td>0</td><td>0</td><td>0</td><td class="score-col">0.00</td></tr>`;
              tbody.innerHTML = ORDER_B.map(buildRow).join('') + totalHTML;
              console.log('[ESTADISTICAS][DAY][DOM] Enforced Sunday GROUP B');
            }
            // Also set a MutationObserver to re-apply if the section re-renders later
            if (!window.__statsDayObserverB) {
              const apply = () => {
                const c = document.querySelector('#ventas-dia-card .conversion-card');
                const tb = c && c.querySelector('.sales-table tbody');
                if (!tb) return false;
                const totalRow = tb.querySelector('.total-row');
                const totalHTML = totalRow ? totalRow.outerHTML : '';
                const buildRow = (name)=>`<tr><td>${name}</td><td>0</td><td>0</td><td>0</td><td class="score-col">0.00</td></tr>`;
                tb.innerHTML = ORDER_B.map(buildRow).join('') + totalHTML;
                console.log('[ESTADISTICAS][DAY][DOM] Observer re-applied GROUP B');
                return true;
              };
              // Try now; if not, observe until it appears or timeout
              if (!apply()) {
                const mo = new MutationObserver(() => { if (apply()) { try { mo.disconnect(); } catch(_) {} window.__statsDayObserverB = null; } });
                mo.observe(document.body, { childList: true, subtree: true });
                window.__statsDayObserverB = mo;
                setTimeout(() => { try { mo.disconnect(); } catch(_) {} window.__statsDayObserverB = null; }, 15000);
              }
            }
          }
        } catch(_) {}
        // Hook botón detalle
        const btnDet = document.getElementById('btn-detalle-dia');
        if (btnDet) {
          btnDet.addEventListener('click', () => {
            try { showDayDetailModal(); } catch (e) { console.error('No se pudo abrir detalle del día', e); }
          });
        }
        // Hook flechas navegación día
        try {
          const btnPrev = document.getElementById('day-prev-alt');
          const btnNext = document.getElementById('day-next-alt');
          const navigateDay = async (delta) => {
            try {
              if (window.__dayNavInFlight) return;
              window.__dayNavInFlight = true;
              const base = window.__currentDayDate ? new Date(window.__currentDayDate) : new Date(effective);
              base.setDate(base.getDate() + delta);
              await loadDayData(base, { skipHistory: false });
            } catch (navErr) {
              console.warn('No se pudo navegar al día solicitado:', navErr);
            } finally {
              window.__dayNavInFlight = false;
            }
          };

          if (btnPrev) {
            btnPrev.addEventListener('click', (e) => {
              try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
              navigateDay(-1);
            });
            console.log('[DÍA] Botón anterior conectado');
          } else {
            console.warn('[DÍA] Botón anterior NO encontrado');
          }
          if (btnNext) {
            btnNext.addEventListener('click', (e) => {
              try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
              navigateDay(1);
            });
            console.log('[DÍA] Botón siguiente conectado');
          } else {
            console.warn('[DÍA] Botón siguiente NO encontrado');
          }

          if (!window.__dayKeyboardBound) {
            try {
              document.addEventListener('keydown', (event) => {
                if (event.key === 'ArrowLeft') {
                  event.preventDefault();
                  navigateDay(-1);
                } else if (event.key === 'ArrowRight') {
                  event.preventDefault();
                  navigateDay(1);
                }
              });
              window.__dayKeyboardBound = true;
            } catch(_) {}
          }
        } catch(err) {
          console.error('[DÍA] Error al conectar flechas:', err);
        }
        // Tabs inline en tarjeta del Día
        try {
          const pad2 = (n)=> String(n).padStart(2,'0');
          const formatDMY = (d)=> `${pad2(d.getDate())}/${pad2(d.getMonth()+1)}/${d.getFullYear()}`;
          const formatMY = (d)=> `${pad2(d.getMonth()+1)}/${d.getFullYear()}`;
          const resolveCurrentDate = () => {
            try {
              if (window.__currentDayDate) {
                return new Date(window.__currentDayDate);
              }
            } catch(_){ }
            return new Date(effective);
          };
          const today = resolveCurrentDate();
          const title = container.querySelector('.conversion-title');
          const table = container.querySelector('.sales-table');
          const btnDay = container.querySelector('#tab-dia-day');
          const btnMonth = container.querySelector('#tab-dia-month');
          const setActive = (which)=>{
            if (!btnDay || !btnMonth) return;
            btnDay.style.background = which==='day' ? '#22b3ec' : '';
            btnDay.style.color = which==='day' ? '#fff' : '';
            btnMonth.style.background = which==='month' ? '#22b3ec' : '';
            btnMonth.style.color = which==='month' ? '#fff' : '';
          };
          const renderTable = (rows)=>{
            const tbody = table?.querySelector('tbody');
            if (!tbody) return;
            const body = (rows||[]).map(r=>`<tr><td>${r.name}</td><td>${r.ICON||0}</td><td>${r.BAMO||0}</td><td>${r.Total||0}</td><td class="score-col">${parseFloat(r.Puntaje||0).toFixed(2)}</td></tr>`).join('');
            const totals = (rows||[]).reduce((a,r)=>({ICON:a.ICON+(r.ICON||0),BAMO:a.BAMO+(r.BAMO||0),Total:a.Total+(r.Total||0),Puntaje:a.Puntaje+parseFloat(r.Puntaje||0)}),{ICON:0,BAMO:0,Total:0,Puntaje:0});
            const total = `<tr class="total-row"><td>TOTAL</td><td>${totals.ICON}</td><td>${totals.BAMO}</td><td>${totals.Total}</td><td>${totals.Puntaje.toFixed(2)}</td></tr>`;
            tbody.innerHTML = body + total;
          };
          const showDay = ()=>{ 
            try { if (typeof window.__ensureDayFrontVisible === 'function') window.__ensureDayFrontVisible(); } catch(_){}
            // As a robust fallback, temporarily force the front face visible
            try {
              const vp = document.getElementById('day-flip-local');
              const front = vp && vp.querySelector ? vp.querySelector('.flip-face.front') : null;
              if (front) {
                front.classList.add('force-visible');
                setTimeout(() => { try { front.classList.remove('force-visible'); } catch(_){} }, 500);
              }
            } catch(_){}
            const current = resolveCurrentDate();
            setActive('day'); if (title) title.textContent = `VENTAS DEL DÍA (${formatDMY(current)})`; renderTable(window.DayRowsOriginal||[]); };
          try {
            console.log('[ESTADISTICAS][DIA] showDay() aplicado', {
              resolved: resolveCurrentDate(),
              title: title ? title.textContent : null
            });
          } catch (_) {}
          const showMonth = ()=>{ 
            try { if (typeof window.__ensureDayFrontVisible === 'function') window.__ensureDayFrontVisible(); } catch(_){}
            try {
              const vp = document.getElementById('day-flip-local');
              const front = vp && vp.querySelector ? vp.querySelector('.flip-face.front') : null;
              if (front) {
                front.classList.add('force-visible');
                setTimeout(() => { try { front.classList.remove('force-visible'); } catch(_){} }, 500);
              }
            } catch(_){}
            const current = resolveCurrentDate();
            setActive('month'); if (title) title.textContent = `VENTAS POR MERCADO Y PUNTAJE DEL MES (${formatMY(current)})`; renderTable(window.MonthDisplayRows||[]); };
          if (btnDay) btnDay.onclick = showDay;
          if (btnMonth) btnMonth.onclick = showMonth;
          // Selección por defecto: Día
          showDay();
        } catch(_) {}
        // Control de equipos se mueve al modal "Ver detalle"
      } catch (e) {
        console.error('Error cargando datos del día:', e);
        container.innerHTML = `
          <div class="conversion-card">
            <div class="conversion-title">VENTAS DEL DÍA (${diaTexto})</div>
            <div class="conv-two-col">
              <div class="conv-left">
                <table class="sales-table">
                  <thead>
                    <tr>
                      <th>EQUIPO</th>
                      <th>ICON</th>
                      <th>BAMO</th>
                      <th>TOTAL</th>
                      <th>PUNTAJE</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td colspan="5" style="text-align:center; padding:16px; color:#666; font-style:italic;">Error de conexión</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        `;
      }
    }

    // ====== MODAL DETALLE DÍA ======
    // Estilos básicos del modal (inline para no depender de CSS externo)
    (function ensureModalStyles(){
      const css = `
      .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
      .modal{background:#fff;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.2);max-width:960px;width:92%;max-height:80vh;overflow:auto}
      .modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e2e8f0;font-weight:800}
      .close-btn{border:none;background:#e11d48;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
      .table-compact{width:100%;border-collapse:collapse;font-size:.9rem}
      .table-compact th,.table-compact td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left}
      .table-compact th{background:#1f3b63;color:#fff}
      .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
      `;
      const s = document.createElement('style'); s.textContent = css; document.head.appendChild(s);
    })();

    // (El contenedor de modal del día se define estático en el HTML; no recrear dinámicamente)

    function hideDayDetailModal(){
      const el = document.getElementById('day-detail-modal');
      if (el) el.style.display = 'none';
    }

    function showDayDetailModal(){
      try{
        console.log('[MODAL] showDayDetailModal invoked', { DayDetailRows: !!window.DayDetailRows });
        const store = window.DayDetailRows || { fecha:'', rows:[] };
        const rows = Array.isArray(store.rows) ? store.rows : [];
        const overlay = document.getElementById('day-detail-modal');
        if (!overlay) return;
        const tbody = overlay.querySelector('#day-detail-table tbody');
        const sel = overlay.querySelector('#filter-team-select');
        const subtitle = overlay.querySelector('#day-detail-subtitle');

        subtitle.textContent = `Fecha: ${store.fecha}`;

        // Poblar select de equipos
        const teams = Array.from(new Set(rows.map(r => (r.team||'').toString().trim()).filter(Boolean))).sort();
        sel.innerHTML = `<option value="">Todos</option>` + teams.map(t=>`<option value="${t}">${t}</option>`).join('');

        function render(filterTeam){
          const data = rows.filter(r => !filterTeam || String(r.team).trim() === filterTeam);
          tbody.innerHTML = data.map(r => `
            <tr>
              <td>${r.team || ''}</td>
              <td>${r.agente || ''}</td>
              <td>${r.servicio || ''}</td>
              <td>${r.mercado || ''}</td>
              <td>${Number(r.puntaje||0).toFixed(2)}</td>
              <td>${typeof r.fecha==='string' ? r.fecha : (r.fecha instanceof Date ? r.fecha.toISOString() : (r.fecha||''))}</td>
            </tr>
          `).join('');
        }

        render('');
        sel.onchange = () => render(sel.value);

        overlay.style.display = 'flex';
      } catch(e){ console.error('Error abriendo detalle del día', e); }
    }

    // FunciÃ³n para inicializar la tabla de conversiÃ³n
    function initConversionTable() {
      console.log('Inicializando tabla de conversiÃ³n...');
      const convRoot = document.getElementById('conversion-table');
      if (convRoot) {
        console.log('Elemento conversion-table encontrado, renderizando...');
        loadConversionTableForMonth(window.__tablaMesFecha, { updateUrl: false });
      } else {
        console.error('No se encontrÃ³ el elemento con ID conversion-table');
      }
    }

    // ===== FUNCIONES DE LA GRÁFICA DE VENTAS Y PUNTAJE =====
    
    // Variables globales para la nueva gráfica
    let ventasPuntajeChart = null;
    
    // Datos de prueba para la gráfica
    const datosPrueba = [
      { fecha: '2025-08-06', ventas: 12, puntaje: 85 },
      { fecha: '2025-08-07', ventas: 8, puntaje: 70 },
      { fecha: '2025-08-08', ventas: 15, puntaje: 95 },
      { fecha: '2025-08-09', ventas: 10, puntaje: 80 },
      { fecha: '2025-08-10', ventas: 20, puntaje: 100 },
      { fecha: '2025-08-11', ventas: 14, puntaje: 88 },
      { fecha: '2025-08-12', ventas: 18, puntaje: 90 }
    ];

    // Función para inicializar la gráfica de ventas y puntaje
    function inicializarGraficaVentasPuntaje() {
      try {
        const canvas = document.getElementById('ventasPuntajeChart');
        if (!canvas) {
          console.error('No se encontró el elemento canvas para la gráfica de ventas y puntaje');
          return null;
        }
        
        if (ventasPuntajeChart) {
          console.log('Destruyendo instancia anterior del gráfico...');
          ventasPuntajeChart.destroy();
          ventasPuntajeChart = null;
        }
        
        const ctx = canvas.getContext('2d');
        const container = canvas.parentElement;
        container.style.width = '100%';
        container.style.height = '400px';
        
        const extraPlugins = [];
        try {
          const candidate = window.__chartDataLabelsPlugin
            || (typeof ChartDataLabels !== 'undefined' && (ChartDataLabels.default || ChartDataLabels));

          if (candidate && window.__chartDataLabelsRegistered !== true) {
            extraPlugins.push(candidate);
          } else if (!candidate) {
            console.warn('[VENTAS 7D] ChartDataLabels no está disponible para la gráfica (candidate null)');
          }
        } catch(regErr) {
          console.warn('[VENTAS 7D] No se pudo determinar ChartDataLabels:', regErr);
        }

        return new Chart(ctx, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Ventas',
                type: 'bar',
                backgroundColor: 'rgba(54, 162, 235, 0.5)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                yAxisID: 'y',
                datalabels: {
                  align: 'end',
                  anchor: 'end',
                  offset: 8,
                  backgroundColor: 'rgba(37, 99, 235, 0.92)',
                  borderRadius: 8,
                  color: '#ffffff',
                  font: { weight: '700', size: 11 },
                  padding: { top: 3, bottom: 3, left: 6, right: 6 },
                  display: (context) => {
                    const raw = context?.dataset?.data?.[context.dataIndex];
                    if (raw == null) return false;
                    const n = Number(raw);
                    return !Number.isNaN(n) && n !== 0;
                  },
                  formatter: (value) => {
                    const n = Number(value);
                    if (Number.isNaN(n) || n === 0) return '';
                    return Math.round(n).toString();
                  }
                }
              },
              {
                label: 'Puntaje',
                type: 'bar',
                backgroundColor: 'rgba(255, 99, 132, 0.7)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                borderRadius: 4,
                yAxisID: 'y1',
                datalabels: {
                  align: 'end',
                  anchor: 'end',
                  offset: 8,
                  backgroundColor: 'rgba(244, 63, 94, 0.92)',
                  borderRadius: 8,
                  color: '#ffffff',
                  font: { weight: '700', size: 11 },
                  padding: { top: 3, bottom: 3, left: 6, right: 6 },
                  display: (context) => {
                    const raw = context?.dataset?.data?.[context.dataIndex];
                    if (raw == null) return false;
                    const n = Number(raw);
                    return !Number.isNaN(n) && n !== 0;
                  },
                  formatter: (value) => {
                    const n = Number(value);
                    if (Number.isNaN(n) || n === 0) return '';
                    return n.toFixed(2).replace(/\.00$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
                  }
                }
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { bottom: 40 } },
            plugins: {
              legend: {
                position: 'right'
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed !== null) {
                      label += context.parsed;
                    }
                    return label;
                  }
                }
              },
              datalabels: {
                clamp: false,
                clip: false
              }
            },
            scales: {
              y: {
                type: 'linear',
                display: true,
                position: 'left',
                title: { display: false, text: 'Ventas' },
                grid: { display: false, drawTicks: false },
                border: { display: false },
                ticks: { display: false, callback: () => '' }
              },
              y1: {
                type: 'linear',
                display: true,
                position: 'right',
                grid: { display: false, drawOnChartArea: false, drawTicks: false },
                border: { display: false },
                title: { display: false, text: 'Puntaje' },
                ticks: { display: false, callback: () => '' },
                min: 0,
                max: 100
              },
              x: {
                display: true,
                grid: { display: false },
                ticks: { display: false, callback: () => '' },
                title: { display: false, text: '' }
              }
            },
            elements: {
              point: { radius: 0, hoverRadius: 0 }
            }
          },
          plugins: extraPlugins
        });
      } catch (error) {
        console.error('Error al inicializar la gráfica de ventas y puntaje:', error);
        return null;
      }
    }

    // Función para mostrar notificaciones
    function mostrarNotificacion(mensaje, tipo = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${tipo}`;
      notification.innerHTML = `
        <i class="fas ${tipo === 'success' ? 'fa-check-circle' : 'fa-exclamation-triangle'}"></i>
        ${mensaje}
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.classList.add('show');
      }, 100);
      
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    // Función para mostrar mensajes de error
    function mostrarMensajeError(mensaje) {
      mostrarNotificacion(mensaje, 'error');
    }

    // Función auxiliar para actualizar la gráfica con rango de fechas específico
    async function actualizarGraficaVentasPuntajePorFecha(fechaInicio, fechaFin) {
      try {
        console.log('=== ACTUALIZANDO GRÁFICA CON FECHAS ===', { fechaInicio, fechaFin });
        
        const userData = JSON.parse(localStorage.getItem('user') || sessionStorage.getItem('user') || '{}');
        const roleLower = ((userData && userData.role) || '').toString().toLowerCase();
        const team = ((userData && userData.team) || '').toString().toLowerCase();
        const isTeamLineas = /lineas/.test(team) || /lineas/.test(roleLower) || roleLower.includes('supervisor');
        
        let url = '/api/leads';
        const params = new URLSearchParams();
        
        // Añadir parámetros de fecha
        if (fechaInicio) params.set('fechaInicio', fechaInicio);
        if (fechaFin) params.set('fechaFin', fechaFin);
        
        // Filtro por agente si es necesario
        if (!isTeamLineas && roleLower === 'agent') {
          const agenteNombre = userData.username || userData.name || '';
          if (agenteNombre) params.set('agente', agenteNombre);
        }
        
        const queryString = params.toString();
        url = queryString ? `${url}?${queryString}` : url;
        
        console.log('Solicitando datos a:', url);
        
        const tokenForGet = localStorage.getItem('token') || sessionStorage.getItem('token');
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Authorization': tokenForGet ? `Bearer ${tokenForGet}` : '',
            'Cache-Control': 'no-cache'
          },
          credentials: 'same-origin'
        });
        
        if (!response.ok) {
          console.error(`Error en la respuesta: ${response.status}`);
          return await procesarDatosGraficaEstadisticas(datosPrueba);
        }
        
        const responseData = await response.json();
        console.log('Datos recibidos:', responseData);
        
        // Extraer array de datos
        let costumers = [];
        if (Array.isArray(responseData)) {
          costumers = responseData;
        } else if (Array.isArray(responseData.data)) {
          costumers = responseData.data;
        } else if (Array.isArray(responseData.leads)) {
          costumers = responseData.leads;
        }
        
        console.log(`Total de registros recibidos: ${costumers.length}`);
        
        if (costumers.length === 0) {
          console.warn('No hay datos para el rango de fechas seleccionado');
          mostrarNotificacion('No hay datos para la fecha seleccionada', 'warning');
          return await procesarDatosGraficaEstadisticas([]);
        }
        
        // Procesar datos directamente pasándolos como parámetro
        return await actualizarGraficaVentasPuntaje(costumers);
        
      } catch (error) {
        console.error('Error al actualizar gráfica por fecha:', error);
        return await procesarDatosGraficaEstadisticas(datosPrueba);
      }
    }

    // Función para actualizar la gráfica de ventas y puntaje con datos de la API
    async function actualizarGraficaVentasPuntaje(datos = null) {
      try {
        console.log('=== INICIANDO ACTUALIZACIÓN DE GRÁFICA DE VENTAS ===');

        const BUSINESS_TZ_OFFSET_MIN = -6 * 60; // UTC-6 fijo para todas las transformaciones
        const isoLocalFromDate = (date) => {
          if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
          return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        };
        const isoToLocalMidday = (iso) => {
          if (typeof iso !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) return null;
          const [y, m, d] = iso.split('-').map(Number);
          if (!y || !m || !d) return null;
          return new Date(y, m - 1, d, 12, 0, 0, 0);
        };
        const todayLocal = new Date();
        todayLocal.setHours(12, 0, 0, 0);
        const hoyISO = isoLocalFromDate(todayLocal);
        
        // Si se proporcionan datos directamente, úsalos y omite la llamada al backend
        if (Array.isArray(datos) && datos.length) {
          console.log('Usando datos proporcionados para la gráfica');
          return await procesarDatosGraficaEstadisticas(datos);
        }
        
        // Obtener el nombre del agente del localStorage o del DOM
        const userData = JSON.parse(localStorage.getItem('user') || sessionStorage.getItem('user') || '{}');
        const nombreAgente = userData.name || 'Usuario';
        
        // Determinar si el usuario es de Team Lineas
        const roleLower = ((userData && userData.role) || '').toString().toLowerCase();
        const team = ((userData && userData.team) || '').toString().toLowerCase();
        const isTeamLineas = /lineas/.test(team) || /lineas/.test(roleLower) || roleLower.includes('supervisor');
        
        // Usar siempre /api/leads ya que ahora consulta ambas bases de datos
        // para supervisores de Team Lineas
        let url = '/api/leads';
        
        try {
          const userStr = localStorage.getItem('user') || sessionStorage.getItem('user') || '{}';
          const user = JSON.parse(userStr);
          const agenteNombreQuery = (user && (user.username || user.name)) || nombreAgente || '';
          const u = new URL(url, location.origin);
          const params = new URLSearchParams(u.search);
          
          // Para Team Lineas, el endpoint ya maneja la lógica de supervisor vs agente
          // Para otros equipos, solo los agentes se filtran por su propio nombre
          if (!isTeamLineas && roleLower === 'agent' && agenteNombreQuery) {
            params.set('agente', agenteNombreQuery);
            console.info('[Filtro agente] (rol agent) Enviado en query a /api/leads:', agenteNombreQuery);
          } else {
            console.info('[Filtro agente] Rol privilegiado o Team Lineas detectado (', roleLower, team, '): endpoint maneja la lógica');
          }
          if (hoyISO) {
            const fechaFinQuery = hoyISO;
            const fechaInicioDate = new Date(todayLocal);
            fechaInicioDate.setDate(fechaInicioDate.getDate() - 6);
            const fechaInicioQuery = isoLocalFromDate(fechaInicioDate);
            if (fechaInicioQuery) params.set('fechaInicio', fechaInicioQuery);
            params.set('fechaFin', fechaFinQuery);
            console.info('[Filtro fecha] Últimos 7 días enviados a /api/leads:', fechaInicioQuery, '→', fechaFinQuery);
          }
          // Aumentar el límite para asegurar que traemos todos los datos para las gráficas
          params.set('limit', '5000');
          
          const qs = params.toString();
          url = qs ? `${u.pathname}?${qs}` : `${u.pathname}`;
        } catch (e) {
          console.warn('No se pudo construir la URL con filtro por agente:', e?.message);
        }
        console.log('Solicitando datos a:', url);
        
        // Realizar la petición a la API
        const tokenForGet = localStorage.getItem('token') || sessionStorage.getItem('token');
        const baseHeaders = {
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        };
        if (tokenForGet) baseHeaders['Authorization'] = `Bearer ${tokenForGet}`;
        
        const response = await fetch(url, {
          method: 'GET',
          headers: baseHeaders,
          credentials: 'same-origin'
        });
        
        // Verificar si la respuesta es exitosa; si no, usar datos de prueba
        if (!response.ok) {
          let bodyText = '';
          try { bodyText = await response.text(); } catch (_) {}
          console.warn(`Respuesta no OK (${response.status}). Cuerpo:`, bodyText);
          return await procesarDatosGraficaEstadisticas(datosPrueba);
        }
        
        // Obtener los datos de la respuesta
        const responseData = await response.json();
        console.log('Datos recibidos de la API:', responseData);
        
        // Extraer el array de clientes de la respuesta de forma robusta
        const safeData = responseData || {};
        let costumers = [];
        if (Array.isArray(safeData)) {
          costumers = safeData;
        } else if (Array.isArray(safeData.data)) {
          costumers = safeData.data;
        } else if (Array.isArray(safeData.leads)) {
          costumers = safeData.leads;
        } else if (Array.isArray(safeData.customers)) {
          costumers = safeData.customers;
        }

        console.log(`Datos extraídos: ${costumers.length} registros`);

        // Si no hay datos, usar datos de prueba
        if (!Array.isArray(costumers) || costumers.length === 0) {
          console.warn('No se encontraron datos en la respuesta. Usando datos de prueba.');
          return await procesarDatosGraficaEstadisticas(datosPrueba);
        }

        // Procesar datos para agrupar por día
        const ventanaDias = [];
        const ventasPorDia = {};

        // Helpers para obtener fechas de los registros
        const getByPath = (obj, path) => {
          try {
            return path.split('.').reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : undefined), obj);
          } catch (_) {
            return undefined;
          }
        };

        const findFirst = (obj, paths) => {
          for (const p of paths) {
            const v = getByPath(obj, p);
            if (v !== undefined && v !== null && v !== '') return v;
          }
          return undefined;
        };

        const tryDateFrom = (val) => {
          if (!val) return null;
          if (typeof val === 'string') {
            const s = val.trim();
            if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
              const [y,m,d] = s.split('-').map(Number);
              return new Date(Date.UTC(y, m-1, d, 12, 0, 0));
            }
            const isoDateTimeMatch = s.match(/^(\d{4}-\d{2}-\d{2})([T\s].*)$/);
            if (isoDateTimeMatch) {
              const dt = new Date(s);
              if (!Number.isNaN(dt.getTime())) {
                const utcMs = dt.getTime() + dt.getTimezoneOffset() * 60000;
                const businessMs = utcMs + BUSINESS_TZ_OFFSET_MIN * 60000;
                const businessDate = new Date(businessMs);
                return new Date(businessDate.getFullYear(), businessDate.getMonth(), businessDate.getDate(), 12, 0, 0, 0);
              }
              const [y, m, d] = isoDateTimeMatch[1].split('-').map(Number);
              return new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
            }
            if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) {
              const parts = s.split(/[\/\-]/).map(Number);
              const [d,m,y] = parts;
              if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 1900) {
                return new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
              }
            }
          }
          if (typeof val === 'number') return new Date(val < 1e12 ? val*1000 : val);
          const dt = new Date(val); return isNaN(dt) ? null : dt;
        };

        // Deduplicar registros siguiendo la llave usada en las tablas (cuenta|teléfono|día|servicio)
        const sanitize = (value) => (value || '').toString().trim().toUpperCase();
        const onlyDigits = (value) => (value || '').toString().replace(/\D+/g, '');
        const dedupeKeyOf = (lead) => {
          const numeroCuenta = sanitize(findFirst(lead, ['numero_cuenta','numeroCuenta','accountNumber']));
          const telefono = onlyDigits(findFirst(lead, ['telefono_principal','telefonoPrincipal','telefono']));
          const diaVenta = sanitize(findFirst(lead, ['dia_venta','diaVenta','fecha_contratacion','fecha','createdAt','created_at']));
          const servicio = sanitize(findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']));
          const parts = [numeroCuenta, telefono, diaVenta, servicio].filter(Boolean);
          if (parts.length) return parts.join('|');
          const fallbackId = sanitize(findFirst(lead, ['_id','id','uid']));
          return fallbackId || JSON.stringify(lead);
        };

        const dedupedCostumers = [];
        const seenKeys = new Set();
        for (const lead of costumers || []) {
          const key = dedupeKeyOf(lead);
          if (key && seenKeys.has(key)) continue;
          if (key) seenKeys.add(key);
          dedupedCostumers.push(lead);
        }
        if ((costumers || []).length !== dedupedCostumers.length) {
          console.log(`[ESTADISTICAS][7D] Eliminados ${(costumers || []).length - dedupedCostumers.length} duplicados antes de agregar.`);
        }

        costumers = dedupedCostumers;

        const createdPaths = [
          'creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha',
          'fecha_contratacion','fechaContratacion','fecha_contrato','fechaContrato','fecha_captura','fechaCaptura',
          'fecha_venta','fechaVenta','fecha_activacion','fechaActivacion','assignedAt','asignadoEn','asignadoEn.fecha',
          '_raw.creadoEn','_raw.fecha_creacion','_raw.fechaCreacion','_raw.createdAt','_raw.created_at','_raw.fecha',
          '_raw.fecha_contratacion','_raw.fechaContratacion','_raw.fecha_venta','_raw.fechaVenta',
          'metadata.createdAt','metadata.fecha_contratacion','audit.createdAt','timestamps.createdAt'
        ];
        const diaVentaPaths = ['dia_venta','diaVenta','diaVentaISO','fechaVentaDia'];

        const processedEntries = [];
        let maxFechaISOFromData = null;

        (costumers || []).forEach(costumer => {
          try {
            const diaVentaVal = findFirst(costumer, diaVentaPaths);
            let fecha = tryDateFrom(typeof diaVentaVal === 'string' ? diaVentaVal.trim() : diaVentaVal);
            if (!fecha) {
              const fechaCreacionVal = findFirst(costumer, createdPaths);
              fecha = tryDateFrom(fechaCreacionVal);
            }
            if (!fecha || isNaN(fecha.getTime())) {
              console.warn('[ESTADISTICAS][7D] Registro sin fecha válida omitido:', costumer && costumer._id);
              return;
            }
            const fechaStr = isoLocalFromDate(fecha);
            if (!fechaStr) return;
            if (!maxFechaISOFromData || fechaStr > maxFechaISOFromData) {
              maxFechaISOFromData = fechaStr;
            }
            let puntaje = 0;
            if (typeof costumer.puntaje === 'number') {
              puntaje = costumer.puntaje;
            } else if (typeof costumer.puntaje === 'string') {
              puntaje = parseFloat(costumer.puntaje) || 0;
            } else if (costumer.score) {
              puntaje = parseFloat(costumer.score) || 0;
            }
            processedEntries.push({ fechaStr, puntaje });
          } catch (e) {
            console.warn('[ESTADISTICAS][7D] Error procesando registro para la gráfica:', e);
          }
        });

        const anchorISO = maxFechaISOFromData || hoyISO;
        const fallbackToday = new Date();
        fallbackToday.setHours(12, 0, 0, 0);
        const anchorDate = isoToLocalMidday(anchorISO) || isoToLocalMidday(hoyISO) || fallbackToday;
        for (let offset = 6; offset >= 0; offset--) {
          const dia = new Date(anchorDate);
          dia.setDate(anchorDate.getDate() - offset);
          const clave = isoLocalFromDate(dia);
          if (!clave) continue;
          ventanaDias.push(clave);
          ventasPorDia[clave] = { ventas: 0, puntaje: 0 };
        }

        processedEntries.forEach(({ fechaStr, puntaje }) => {
          const fechaLocal = isoToLocalMidday(fechaStr);
          if (!fechaLocal) return;
          const clave = isoLocalFromDate(fechaLocal);
          if (!clave || !(clave in ventasPorDia)) return;
          const bucket = ventasPorDia[clave] || (ventasPorDia[clave] = { ventas: 0, puntaje: 0 });
          bucket.ventas += 1;
          bucket.puntaje += puntaje;
        });

        try {
          window.__ventasUltimos7 = {
            fechasVentana: ventanaDias.slice(),
            registrosProcesados: processedEntries.length,
            maxFechaISOFromData,
            procesadosPreview: processedEntries.slice(-20),
            datosPrevios: processedEntries.length ? processedEntries.map(e => e.fechaStr).slice(-20) : []
          };
        } catch (_) {}
        
        const datosFinales = ventanaDias.map(fechaISO => ({
          fecha: fechaISO,
          ventas: ventasPorDia[fechaISO]?.ventas || 0,
          puntaje: ventasPorDia[fechaISO]?.puntaje || 0
        }));
        try {
          window.__ventasUltimos7 = Object.assign({}, window.__ventasUltimos7, {
            datosFinales
          });
        } catch (_) {}
        
        console.log('Datos procesados para la gráfica:', datosFinales);
        
        // Procesar los datos y actualizar la gráfica
        try {
          const resultado = await procesarDatosGraficaEstadisticas(datosFinales);
          console.log('Gráfica de ventas y puntaje actualizada correctamente');
          return resultado;
        } catch (error) {
          console.error('Error al procesar datos para la gráfica:', error);
          mostrarMensajeError('Error al procesar los datos de la gráfica');
          return false;
        }
        
      } catch (error) {
        console.error('Error al actualizar la gráfica de ventas y puntaje:', error);
        // Fallback: mostrar gráfica con datos de prueba
        try {
          return await procesarDatosGraficaEstadisticas(datosPrueba);
        } catch (e) {
          mostrarMensajeError('Error al actualizar la gráfica de ventas');
          return false;
        }
      }
    }

    // Función para inicializar la nueva gráfica
    function initVentasPuntajeChart() {
      console.log('Inicializando gráfica de ventas y puntaje...');
      
      try {
        ventasPuntajeChart = inicializarGraficaVentasPuntaje();
        if (ventasPuntajeChart) {
          // Cargar datos reales de la API
          actualizarGraficaVentasPuntaje().catch(() => {
            // Fallback a datos de prueba si falla la API
            procesarDatosGraficaEstadisticas(datosPrueba);
          });
          console.log('Gráfica de ventas y puntaje inicializada correctamente');
          
          // Configurar filtros de fecha
          setupDateFilters();
        }
      } catch (error) {
        console.error('Error al inicializar la gráfica de ventas y puntaje:', error);
      }
    }

    // Función para configurar los filtros de fecha
    function setupDateFilters() {
      // Llenar el select de días
      const daySelect = document.getElementById('day-select');
      const monthSelect = document.getElementById('month-select');
      const yearSelect = document.getElementById('year-select');
      
      if (!daySelect || !monthSelect || !yearSelect) return;

      // Función para llenar los días según el mes y año seleccionado
      function fillDays() {
        const month = parseInt(monthSelect.value);
        const year = parseInt(yearSelect.value);
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        daySelect.innerHTML = '';
        for (let i = 1; i <= daysInMonth; i++) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = i;
          daySelect.appendChild(option);
        }
      }

      // Configurar fecha actual
      const today = new Date();
      monthSelect.value = today.getMonth();
      yearSelect.value = today.getFullYear();
      fillDays();
      daySelect.value = today.getDate();

      // Event listeners para actualizar días cuando cambie mes o año
      monthSelect.addEventListener('change', fillDays);
      yearSelect.addEventListener('change', fillDays);

      // Event listener para aplicar filtro
      const applyFilterBtn = document.getElementById('apply-filter');
      if (applyFilterBtn) {
        applyFilterBtn.addEventListener('click', () => {
          console.log('Aplicando filtro de fecha...');
          
          // Obtener valores de los selectores
          const year = document.getElementById('year-select').value;
          const month = String(parseInt(document.getElementById('month-select').value) + 1).padStart(2, '0');
          const day = String(document.getElementById('day-select').value).padStart(2, '0');
          
          // Construir fechas para filtrar por el día seleccionado
          const fechaSeleccionada = `${year}-${month}-${day}`;
          console.log('Filtrando por fecha:', fechaSeleccionada);
          
          // Actualizar gráfica con datos reales de la API usando el rango de fecha
          actualizarGraficaVentasPuntajePorFecha(fechaSeleccionada, fechaSeleccionada).catch(() => {
            console.warn('Error al cargar datos de la API, usando datos de prueba');
            procesarDatosGraficaEstadisticas(datosPrueba);
          });
          mostrarNotificacion('Filtro aplicado correctamente');
        });
      }

      // Event listener para resetear a hoy
      const resetFilterBtn = document.getElementById('reset-filter');
      if (resetFilterBtn) {
        resetFilterBtn.addEventListener('click', () => {
          const today = new Date();
          monthSelect.value = today.getMonth();
          yearSelect.value = today.getFullYear();
          fillDays();
          daySelect.value = today.getDate();
          
          console.log('Reseteando filtro a fecha actual...');
          // Actualizar gráfica con datos reales de la API
          actualizarGraficaVentasPuntaje().catch(() => {
            console.warn('Error al cargar datos de la API, usando datos de prueba');
            procesarDatosGraficaEstadisticas(datosPrueba);
          });
          mostrarNotificacion('Filtro reseteado a fecha actual');
        });
      }
    }

    // Función simplificada para procesar datos en Estadísticas
    function procesarDatosGraficaEstadisticas(datos) {
      try {
        if (!Array.isArray(datos) || datos.length === 0) {
          console.warn('No hay datos disponibles para mostrar en la gráfica');
          return false;
        }

        // Generar etiquetas y datasets para los últimos 7 días
        const labels = [];
        const ventasData = [];
        const puntajesData = [];
        
        // Procesar datos ordenados por fecha
        const datosOrdenados = [...datos].sort((a, b) => new Date(a.fecha) - new Date(b.fecha));
        
        datosOrdenados.forEach(item => {
          // Parsear 'YYYY-MM-DD' como fecha LOCAL para evitar desfase de un día
          let y, m, d;
          if (typeof item.fecha === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(item.fecha)) {
            [y, m, d] = item.fecha.split('-').map(Number);
          } else {
            const tmp = new Date(item.fecha);
            y = tmp.getFullYear(); m = tmp.getMonth() + 1; d = tmp.getDate();
          }
          const fecha = new Date(y, (m || 1) - 1, d || 1, 12, 0, 0); // medio día local
          const dia = fecha.getDate();
          const diasSemana = ['dom', 'lun', 'mar', 'mié', 'jue', 'vie', 'sáb'];
          const diaSemana = diasSemana[fecha.getDay()];
          const etiqueta = `${diaSemana} ${dia}`;
          
          labels.push(etiqueta);
          ventasData.push(Number(item.ventas) || 0);
          puntajesData.push(Number(item.puntaje) || 0);
        });

        // Calcular máximos para escalar ejes
        const maxVentas = Math.max(...ventasData);
        const maxPuntaje = Math.max(...puntajesData);
        const maxBoth = Math.max(maxVentas, maxPuntaje);

        // Configuración de la gráfica
        const pluginList = [];
        const pluginCandidate = window.__chartDataLabelsPlugin
          || (typeof ChartDataLabels !== 'undefined' && (ChartDataLabels.default || ChartDataLabels));
        if (pluginCandidate && window.__chartDataLabelsRegistered !== true) {
          pluginList.push(pluginCandidate);
        } else if (!pluginCandidate) {
          console.warn('[VENTAS 7D] ChartDataLabels no está disponible al reconstruir la gráfica');
        }

        const config = {
          type: 'bar',
          data: {
            labels,
            datasets: [
              {
                label: 'Ventas',
                data: ventasData,
                backgroundColor: 'rgba(54, 162, 235, 0.7)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                borderRadius: 4,
                yAxisID: 'y',
                categoryPercentage: 0.6,
                barPercentage: 0.9,
                datalabels: {
                  align: 'end',
                  anchor: 'end',
                  offset: 8,
                  backgroundColor: 'rgba(37, 99, 235, 0.92)',
                  borderRadius: 8,
                  color: '#ffffff',
                  font: { weight: '700', size: 11 },
                  padding: { top: 3, bottom: 3, left: 6, right: 6 },
                  display: (context) => {
                    const raw = context?.dataset?.data?.[context.dataIndex];
                    if (raw == null) return false;
                    const n = Number(raw);
                    return !Number.isNaN(n) && n !== 0;
                  },
                  formatter: (v) => {
                    const n = Number(v);
                    if (Number.isNaN(n) || n === 0) return '';
                    return Math.round(n).toString();
                  }
                }
              },
              {
                label: 'Puntaje',
                data: puntajesData,
                type: 'bar',
                backgroundColor: 'rgba(255, 99, 132, 0.7)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                borderRadius: 4,
                yAxisID: 'y1',
                categoryPercentage: 0.6,
                barPercentage: 0.9,
                datalabels: {
                  align: 'end',
                  anchor: 'end',
                  offset: 8,
                  backgroundColor: 'rgba(244, 63, 94, 0.92)',
                  borderRadius: 8,
                  color: '#ffffff',
                  font: { weight: '700', size: 11 },
                  padding: { top: 3, bottom: 3, left: 6, right: 6 },
                  display: (context) => {
                    const raw = context?.dataset?.data?.[context.dataIndex];
                    if (raw == null) return false;
                    const n = Number(raw);
                    return !Number.isNaN(n) && n !== 0;
                  },
                  formatter: (v) => {
                    const n = Number(v);
                    if (Number.isNaN(n) || n === 0) return '';
                    return n.toFixed(2).replace(/\.00$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
                  }
                }
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { bottom: 40 } },
            scales: {
              x: {
                display: true,
                grid: { display: false },
                ticks: {
                  display: true,
                  color: '#4a4a4a',
                  autoSkip: false,
                  maxRotation: 0,
                  minRotation: 0,
                  padding: 8,
                  font: { size: 12 }
                },
                title: { display: true, text: 'Días' }
              },
              y: {
                type: 'linear',
                display: true,
                position: 'left',
                title: { display: false, text: 'N° de Ventas' },
                beginAtZero: true,
                grid: { display: false },
                border: { display: false },
                ticks: { display: false },
                max: Math.max(5, Math.ceil(maxBoth * 1.2))
              },
              y1: {
                type: 'linear',
                display: true,
                position: 'right',
                grid: { display: false, drawOnChartArea: false },
                border: { display: false },
                title: { display: false, text: 'Puntaje' },
                beginAtZero: true,
                min: 0,
                max: Math.max(5, Math.ceil(maxBoth * 1.2)),
                ticks: { display: false }
              }
            },
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) { label += ': '; }
                    if (context.parsed.y !== null) { label += context.parsed.y; }
                    return label;
                  }
                }
              },
              legend: {
                position: 'top',
                labels: { usePointStyle: true, pointStyle: 'circle', padding: 20 }
              },
              datalabels: {
                display: true,
                clamp: false,
                clip: false
              }
            }
          },
          plugins: pluginList
        };

        const canvasEl = document.getElementById('ventasPuntajeChart');
        if (!canvasEl) {
          window.__ventasUltimos7 = Object.assign({}, window.__ventasUltimos7, {
            canvasMissing: true,
            lastRenderError: 'Canvas ventasPuntajeChart no encontrado'
          });
          throw new Error('Canvas ventasPuntajeChart no encontrado');
        }
        const ctx = canvasEl.getContext('2d');
        if (ventasPuntajeChart) {
          try { ventasPuntajeChart.destroy(); } catch (_) {}
          ventasPuntajeChart = null;
        }
        ventasPuntajeChart = new Chart(ctx, config);

        console.log('Gráfica de ventas y puntaje actualizada correctamente');
        return true;
      } catch (error) {
        console.error('Error al procesar datos de la gráfica:', error);
        try {
          window.__ventasUltimos7 = Object.assign({}, window.__ventasUltimos7, {
            lastRenderError: error && error.message ? error.message : String(error)
          });
        } catch (_) {}
        mostrarMensajeError('Error al procesar los datos de la gráfica');
        return false;
      }
    }

    // Esperar a que todo el DOM y recursos estÃ©n cargados
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initializeApp();
        initConversionTable();
        // Inicializar la nueva gráfica
        setTimeout(() => {
          initVentasPuntajeChart();
        }, 500);
      });
    } else {
      initializeApp();
      initConversionTable();
      // Inicializar la nueva gráfica
      setTimeout(() => {
        initVentasPuntajeChart();
      }, 500);
    }
  </script>
  <script>
    // Delegate clicks for "Ver detalle" buttons (robust against re-renders)
    (function attachDetailDelegation(){
      try {
        document.addEventListener('click', function(ev){
          try {
            const t = ev.target;
            if (!t) return;
            if (t.id === 'btn-detalle-dia' || (t.dataset && t.dataset.detail === 'day')) {
              ev.preventDefault();
              console.log('[DELEGATE] btn-detalle-dia click');
              try { if (typeof showDayDetailModal === 'function') showDayDetailModal(); else console.warn('showDayDetailModal not defined'); } catch(err){ console.warn('delegated showDayDetailModal error', err); }
              return;
            }
            if (t.id === 'btn-detalle-mensual' || (t.dataset && t.dataset.detail === 'month')) {
              ev.preventDefault();
              console.log('[DELEGATE] btn-detalle-mensual click');
              try { if (typeof showMonthDetailModal === 'function') showMonthDetailModal(); else console.warn('showMonthDetailModal not defined'); } catch(err){ console.warn('delegated showMonthDetailModal error', err); }
              return;
            }
          } catch(_){}
        }, true);
      } catch(e){ console.warn('attachDetailDelegation error', e); }
    })();
    // Utility: ensure canvas is rendered crisply on high-DPI (retina) displays
    window.__ensureHiDPICanvas = function(canvas, minH){
      try {
        if (!canvas) return;
        const dpr = window.devicePixelRatio || 1;
        // get css size
        const rect = canvas.getBoundingClientRect();
        const cssW = rect && rect.width ? rect.width : (canvas.clientWidth || 300);
        const cssH = rect && rect.height ? rect.height : (minH || Math.max(220, Math.round(cssW * 0.33)));
        // set actual pixel size
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        const ctx = canvas.getContext('2d');
        if (ctx && typeof ctx.setTransform === 'function') ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      } catch (e) { /* silent */ }
    };

    // Central helper: animate a 3D flip of the monthly card and create/destroy the monthly chart
    window.__toggleMonthlyFlip = function(){
      try {
        const root = document.getElementById('conversion-table');
        if (!root) return;
        const card = root.querySelector('.conversion-card');
        if (!card) return;

        // Inject flip CSS once
        if (!document.getElementById('month-flip-styles')){
          const css = `
            /* Monthly flip styles (adjusted) */
            #month-flip-local { perspective: 1200px; width:100%; display:block; position:relative; }
            #month-flip-local .flip-scene { position:relative; width:100%; transform-style:preserve-3d; transition: transform 360ms cubic-bezier(.2,.8,.2,1); will-change: transform; }
            /* Faces - front is normal flow, back is absolute full-cover */
            #month-flip-local .flip-face { backface-visibility: hidden; -webkit-backface-visibility:hidden; transition: opacity 260ms ease-in-out; overflow: hidden; }
            #month-flip-local .flip-face.front { position:relative; width:100%; z-index:2; }
            #month-flip-local .flip-face.back { position:absolute !important; top:0; left:0; right:0; bottom:0; transform: rotateY(180deg); display:flex; align-items:stretch; opacity:0; z-index:1; }
            /* When flipped, ensure back is on top and front doesn't receive events */
            #month-flip-local.is-flipped .flip-scene { transform: rotateY(180deg); }
            /* back hidden by default, made visible when flipped. keep faces in flow to allow 3D transform animation */
            #month-flip-local .flip-face.back { opacity: 0; visibility: hidden; }
            #month-flip-local.is-flipped .flip-face.back { opacity:1; visibility: visible; z-index:9999; pointer-events: auto; }
        /* Keep the front face occupying layout while fading it out during the 3D rotate.
          We'll only set visibility:hidden after the transition ends via JS to avoid layout jumps. */
        #month-flip-local.is-flipped .flip-face.front { opacity:0; pointer-events: none; visibility: visible; }
        /* Helper classes for JS toggles */
        #month-flip-local .flip-face.front.flip-front-hidden { visibility: hidden !important; pointer-events: none !important; }
        .force-visible { visibility: visible !important; }
            #month-flip-local .chart-wrapper{ width:100%; height:100%; box-sizing:border-box; padding:6px; min-height:320px; }
            /* Ensure canvas fills the back face */
            #month-flip-local canvas { width:100% !important; height:100% !important; display:block; }
          `;
          const s = document.createElement('style'); s.id = 'month-flip-styles'; s.textContent = css; document.head.appendChild(s);
        }

        // Ensure flip viewport and faces exist (reuse if present)
        let vp = card.querySelector('#month-flip-local');
        let frontFace, backFace, scene;
        if (!vp){
          const twoCol = card.querySelector('.conv-two-col');
          if (!twoCol) return;

          // Create structure: vp > scene > front + back
          vp = document.createElement('div'); vp.id = 'month-flip-local'; vp.className = 'month-flip-viewport';
          scene = document.createElement('div'); scene.className = 'flip-scene';
          frontFace = document.createElement('div'); frontFace.className = 'flip-face front';
          backFace = document.createElement('div'); backFace.className = 'flip-face back';

          // Move existing twoCol into frontFace
          frontFace.appendChild(twoCol);

          // Build back face with canvas (reuse existing canvas if any)
          const backWrap = document.createElement('div'); backWrap.className = 'chart-wrapper';
          let canvas = document.getElementById('monthly-team-chart');
          if (!canvas) {
            canvas = document.createElement('canvas'); canvas.id = 'monthly-team-chart';
          } else {
            // if canvas existed elsewhere, remove it from previous parent to avoid duplicates
            try { canvas.parentElement &&   canvas.parentElement.removeChild(canvas); } catch(_){}
          }
          backWrap.appendChild(canvas);
          backFace.appendChild(backWrap);

          scene.appendChild(frontFace);
          scene.appendChild(backFace);
          vp.appendChild(scene);

          // Immediately fix the viewport height to the front face size to avoid layout jumps
          try {
            const initialH = (frontFace && frontFace.getBoundingClientRect && frontFace.getBoundingClientRect().height) || frontFace.offsetHeight || 220;
            vp.style.height = initialH + 'px';
            vp.style.minHeight = initialH + 'px';
            vp.style.overflow = 'hidden';
            // also keep scene min-height so faces don't push
            scene.style.minHeight = initialH + 'px';
          } catch(_) {}

          // Replace the original twoCol in the card with the flip viewport
          // twoCol was moved into frontFace, so find its former container and replace child
          const holder = card.querySelector('.conv-two-col')?.parentElement || card;
          // Try to find the element that previously contained twoCol (we moved it), so replace the empty spot
          // As a safe fallback, append vp to card
          try {
            // If holder still has a reference to the old twoCol (now absent), replace the placeholder
            const possible = Array.from(holder.children).find(ch => ch.classList && ch.classList.contains('conv-two-col'));
            if (possible) holder.replaceChild(vp, possible);
            else card.appendChild(vp);
          } catch(_) { card.appendChild(vp); }
        } else {
          scene = vp.querySelector('.flip-scene');
          frontFace = vp.querySelector('.flip-face.front');
          backFace = vp.querySelector('.flip-face.back');
        }

  // Prevent rapid toggles while animating
  if (window.__monthlyFlipAnimating) return;
  // maintain container height to avoid layout jumps (use bounding rect for more accurate value)
  try {
    const frontEl = frontFace || vp.querySelector('.flip-face.front');
    if (frontEl) {
      const h = (frontEl.getBoundingClientRect && frontEl.getBoundingClientRect().height) || frontEl.offsetHeight || 220;
      vp.style.height = h + 'px';
      vp.style.minHeight = h + 'px';
      vp.style.overflow = 'hidden';
      // also set scene min-height to stabilize 3D transform
      const sc = vp.querySelector('.flip-scene'); if (sc) sc.style.minHeight = h + 'px';
    }
  } catch(_){ }
  const willShowBack = !vp.classList.contains('is-flipped');
  window.__monthlyFlipAnimating = true;

        // Helper to build chart after flip completes
            const buildChart = () => {
          try {
            if (typeof Chart === 'undefined') return;
            const rows = Array.isArray(window.MonthDisplayRows) && window.MonthDisplayRows.length ? window.MonthDisplayRows : (Array.isArray(window.__monthlyTeamData) ? window.__monthlyTeamData : []);
            // build multiline labels (Chart.js supports array-of-strings per label for multiline)
            // Get name from row data
            const labels = rows.map(r => String(r.name || ''));
            try{ console.log('DEBUG: buildChart MONTH start', {labels, rowsLength: rows.length}); } catch(_){}
            const ventas = rows.map(r => Number(r.Total || 0));
            const puntos = rows.map(r => Number(r.Puntaje || 0));
            const canvas = document.getElementById('monthly-team-chart');
            if (!canvas) return;
            // Ensure canvas parent has explicit height so Chart can size properly
            const wrap = canvas.parentElement;
            try {
              const vpH = (vp && vp.getBoundingClientRect && vp.getBoundingClientRect().height) || vp.clientHeight || 320;
              const minH = 320; // ensure chart has a minimum visual height so bars aren't tiny
              const finalH = Math.max(vpH, minH);
              if (wrap) {
                wrap.style.height = finalH + 'px';
                wrap.style.maxHeight = finalH + 'px';
                wrap.style.overflow = 'visible';
                // add bottom padding so x-axis labels and datalabels have room
                wrap.style.paddingBottom = '28px';
              }
            } catch(_){ }
              try { if (window.__monthlyChart) { window.__monthlyChart.destroy(); } } catch(_){ }
              try { if (typeof window.__ensureHiDPICanvas === 'function') window.__ensureHiDPICanvas(canvas, finalH); } catch(_){}
              const ctx = canvas.getContext('2d');
            window.__monthlyChart = new Chart(ctx, {
              type: 'bar',
              data: { labels, datasets: [
                  { label: 'Ventas', data: ventas, backgroundColor: 'rgba(37,99,235,0.85)' },
                  { label: 'Puntaje', data: puntos, backgroundColor: 'rgba(239,68,68,0.85)' }
              ] },
                options: {
                responsive: true,
                maintainAspectRatio: false,
                // give extra bottom padding so x-axis labels and datalabels have room
                layout: { padding: { top: 12, bottom: 60 } },
                plugins: {
                  legend: { display: true, position: 'top' },
                  datalabels: {
                    anchor: 'end',
                    align: 'end',
                    offset: -6,
                    clamp: false,
                    color: '#0b1220',
                    font: { weight: '600', size: 11 },
                    display: (context) => {
                      const raw = context?.dataset?.data?.[context.dataIndex];
                      const n = Number(raw);
                      return !Number.isNaN(n) && n !== 0;
                    },
                    formatter: (value) => formatMetricValue(value)
                  }
                },
                scales: {
                  x: {
                    grid: { display: false },
                    ticks: {
                      display: true,
                      color: '#1e293b',
                      autoSkip: false,
                      maxRotation: 0,
                      minRotation: 0,
                      padding: 12,
                      font: { 
                        size: 12,
                        weight: '500'
                      },
                      textStrokeWidth: 0.5
                    }
                  },
                  y: { beginAtZero: true, grid: { display: false }, ticks: { display: false } }
                }
              },
              plugins: (Chart && Chart.registry && Chart.registry.getPlugin) ? [] : []
            });
          } catch (e) { console.warn('monthly chart build error', e); }
        };

        // Handler for end of transition
        const onTransit = (ev) => {
          if (ev && ev.propertyName && ev.propertyName.indexOf('transform') === -1) return;
          try {
            if (willShowBack) {
              // Now the back face is visible: build the chart
              buildChart();
              // hide the front face from rendering/assistive UI after the back is visible
              try { if (frontFace) { frontFace.classList.add('flip-front-hidden'); } } catch(_){ }
            } else {
              // We're back to front: make sure front face is visible again and destroy chart to free memory
              try { if (frontFace) { frontFace.classList.remove('flip-front-hidden'); frontFace.classList.add('force-visible'); } } catch(_){ }
              try { if (window.__monthlyChart) { window.__monthlyChart.destroy(); window.__monthlyChart = null; } } catch(_){ }
              // Aggressive cleanup: clear inline hidden/display/opacity styles inside the front face
              try {
                if (frontFace && frontFace.querySelectorAll) {
                  Array.from(frontFace.querySelectorAll('*')).forEach(el => {
                    try {
                      if (!el || !el.style) return;
                      if (el.style.visibility && el.style.visibility.indexOf('hidden') !== -1) el.style.visibility = '';
                      if (el.style.display && el.style.display.indexOf('none') !== -1) el.style.display = '';
                      if (el.style.opacity === '0') el.style.opacity = '';
                      if (el.style.pointerEvents === 'none') el.style.pointerEvents = '';
                      if (el.style.transform && el.style.transform.indexOf('rotateY') !== -1) el.style.transform = '';
                    } catch(_){ }
                  });
                }
              } catch(_){ }
              // Also run a delayed, forceful cleanup to counter racey mutations from Chart.js
              try {
                setTimeout(() => {
                  try {
                    if (frontFace) {
                      try { frontFace.classList.remove('flip-front-hidden'); frontFace.classList.remove('force-visible'); } catch(_){}
                      try { frontFace.classList.remove('force-visible'); } catch(_){}
                    }
                    try { if (typeof window.__clearDayHiddenStyles === 'function') window.__clearDayHiddenStyles(); } catch(_){}
                  } catch(_){}
                }, 240);
              } catch(_){}
            }

            // restore any hidden sticky elements
            try {
              const hidden = vp && vp.__hiddenSticky;
              if (hidden && Array.isArray(hidden)) {
                hidden.forEach(item => { try{ item.el.style.visibility = item.vis || ''; } catch(_){} });
                vp.__hiddenSticky = null;
              }
            } catch(_){ }

            // restore table display (in case)
            try { const tbl = vp.querySelector('table'); if (tbl) tbl.style.display = ''; } catch(_){ }
          } finally {
            try {
              // if we flipped back to front, remove any inline sizing after a short delay so layout can resume
              if (!willShowBack) {
                const wrapEl = vp && vp.querySelector && vp.querySelector('.chart-wrapper');
                if (wrapEl) { wrapEl.style.height = ''; wrapEl.style.maxHeight = ''; wrapEl.style.overflow = ''; }
                setTimeout(() => { try { vp.style.height = ''; vp.style.minHeight = ''; if (scene) scene.style.minHeight = ''; } catch(_){} }, 200);
              }
            } catch(_){ }
            // cleanup
            if (scene) scene.removeEventListener('transitionend', onTransit);
            window.__monthlyFlipAnimating = false;
          }
        };

        // Attach transitionend and toggle class to start animation
        if (scene) {
          scene.addEventListener('transitionend', onTransit);
        }
        // Before starting the flip, hide any sticky elements inside the front face so they don't overlap during the 3D rotate
        try {
          if (willShowBack && frontFace) {
            const hidden = [];
            Array.from(frontFace.querySelectorAll('*')).forEach(el => {
              try {
                const cs = window.getComputedStyle(el);
                if (cs && (cs.position === 'sticky' || cs.position === 'fixed')) {
                  hidden.push({el, vis: el.style.visibility});
                  el.style.visibility = 'hidden';
                }
              } catch(_) {}
            });
            // store to restore later
            vp.__hiddenSticky = hidden;
          }
        } catch(_) {}
  // Force reflow then toggle. Ensure frontFace remains occupying layout during the animation.
  try { if (frontFace) frontFace.style.visibility = 'visible'; } catch(_){}
  try { if (scene) { scene.style.height = vp.style.height || (vp.getBoundingClientRect && vp.getBoundingClientRect().height + 'px'); scene.style.boxSizing = 'border-box'; } } catch(_){}
  void vp.offsetHeight;
  if (willShowBack) vp.classList.add('is-flipped'); else vp.classList.remove('is-flipped');

        // Safety: if transitionend doesn't fire (old browsers), fallback after timeout
        setTimeout(() => {
          if (window.__monthlyFlipAnimating) {
            try { onTransit(); } catch(_) { window.__monthlyFlipAnimating = false; }
          }
  }, 500);

      } catch (e) { console.warn('toggleMonthlyFlip error', e); }
    };

    // Fallback global: asegurar flip local y gráfica al pulsar ↻ aunque el HTML varié
    (function(){
      function ensureFlipAndToggle(){
        try{
          if (typeof window.__toggleMonthlyFlip === 'function') {
            window.__toggleMonthlyFlip();
          }
        }catch(e){ console.warn('ensureFlipAndToggle error', e); }
      }
      document.addEventListener('click', function(ev){
        const t = ev.target;
        if (t && t.id === 'btn-flip-monthly'){
          ev.preventDefault();
          ensureFlipAndToggle();
        }
      }, true);
    })();
    
    // Inject helper and fallback for DAY flip (same behavior as monthly)
    (function(){
      // Inject a small toolbar flip button into the day card when it appears
      window.injectDayFlipButton = function(attempt = 0){
        const root = document.getElementById('ventas-dia-card');
        const card = root ? root.querySelector('.conversion-card') : null;
        if (!card) {
          if (attempt < 20) return setTimeout(() => window.injectDayFlipButton(attempt + 1), 300);
          return;
        }
        if (card.querySelector('#btn-flip-day')) return;
        // Find the area where buttons are placed (a small container with Ver detalle)
        const toolbarWrap = card.querySelector('div[style*="justify-content:flex-end"]') || card;
        const btnFlip = document.createElement('button');
        btnFlip.id = 'btn-flip-day';
        btnFlip.className = 'filter-button';
        btnFlip.title = 'Ver gráfica';
        btnFlip.textContent = '↻';
        btnFlip.style.cssText = 'height:28px;width:32px;font-weight:700;margin-left:8px;';
        // Append next to existing detalle button if present
        const detalle = card.querySelector('#btn-detalle-dia');
        if (detalle && detalle.parentElement) detalle.parentElement.appendChild(btnFlip);
        else toolbarWrap.appendChild(btnFlip);
      };

      // Core toggle for day card
      window.__toggleDayFlip = function(){
        try {
          const root = document.getElementById('ventas-dia-card');
          if (!root) return;
          const card = root.querySelector('.conversion-card');
          if (!card) return;

          // Reuse monthly styles if available, otherwise inject day-specific styles
          if (!document.getElementById('day-flip-styles') && document.getElementById('month-flip-styles')){
            // reuse month styles, add a marker
            const s = document.createElement('style'); s.id = 'day-flip-styles'; s.textContent = ''; document.head.appendChild(s);
          } else if (!document.getElementById('day-flip-styles')){
              const css = `
                  /* Day flip styles (adjusted to match monthly) */
                  #day-flip-local { perspective: 1200px; width:100%; display:block; }
                    #day-flip-local .flip-scene { position:relative; width:100%; transform-style:preserve-3d; transition: transform 360ms cubic-bezier(.2,.8,.2,1); will-change: transform; }
                  /* Faces */
                  #day-flip-local .flip-face { backface-visibility: hidden; -webkit-backface-visibility:hidden; position:relative; width:100%; transition: opacity 260ms ease-in-out; overflow:hidden; }
                  #day-flip-local .flip-face.front { z-index:2; }
                  #day-flip-local .flip-face.back { position:absolute; inset:0; transform: rotateY(180deg); display:flex; align-items:stretch; opacity:0; z-index:1; }
                  /* When flipped, ensure back is on top and front doesn't receive events */
                  #day-flip-local.is-flipped .flip-scene { transform: rotateY(180deg); }
                  /* back hidden by default, made visible when flipped. keep faces in flow to allow 3D transform animation */
                  #day-flip-local .flip-face.back { opacity: 0; visibility: hidden; }
                  #day-flip-local.is-flipped .flip-face.back { opacity:1; visibility: visible; z-index:3; pointer-events:auto; }
            /* Keep front face visible (but transparent) during animation to preserve layout.
              Visibility will be toggled in JS when the transition finishes. */
            #day-flip-local.is-flipped .flip-face.front { opacity:0; pointer-events:none; visibility: visible; }
            /* Helper classes for JS toggles */
            #day-flip-local .flip-face.front.flip-front-hidden { visibility: hidden !important; pointer-events: none !important; }
            .force-visible { visibility: visible !important; }
                  #day-flip-local .chart-wrapper{ width:100%; height:100%; box-sizing:border-box; padding:6px; min-height:320px; }
                  #day-flip-local canvas { width:100% !important; height:100% !important; display:block; }
                `;
            const s = document.createElement('style'); s.id = 'day-flip-styles'; s.textContent = css; document.head.appendChild(s);
          }

          // Build the flip viewport if absent
          let vp = card.querySelector('#day-flip-local');
          let scene, frontFace, backFace;
          if (!vp){
            const twoCol = card.querySelector('.conv-two-col');
            if (!twoCol) return;
            vp = document.createElement('div'); vp.id = 'day-flip-local'; vp.className = 'day-flip-viewport';
            scene = document.createElement('div'); scene.className = 'flip-scene';
            frontFace = document.createElement('div'); frontFace.className = 'flip-face front';
            backFace = document.createElement('div'); backFace.className = 'flip-face back';
            frontFace.appendChild(twoCol);
            const backWrap = document.createElement('div'); backWrap.className = 'chart-wrapper';
            let canvas = document.getElementById('daily-team-chart');
            if (!canvas){ canvas = document.createElement('canvas'); canvas.id = 'daily-team-chart'; }
            else { try{ canvas.parentElement && canvas.parentElement.removeChild(canvas); } catch(_){} }
            backWrap.appendChild(canvas); backFace.appendChild(backWrap);
            scene.appendChild(frontFace); scene.appendChild(backFace); vp.appendChild(scene);
            try { const holder = card.querySelector('.conv-two-col')?.parentElement || card; const possible = Array.from(holder.children).find(ch => ch.classList && ch.classList.contains('conv-two-col')); if (possible) holder.replaceChild(vp, possible); else card.appendChild(vp); } catch(_) { card.appendChild(vp); }
          } else { scene = vp.querySelector('.flip-scene'); }

          // Ensure we have a visibility observer installed to auto-recover stray style changes
          try { if (typeof window.__installDayVisibilityObserver === 'function') window.__installDayVisibilityObserver(); } catch(_){}

          if (window.__dayFlipAnimating) return;
          // keep height stable during flip (use bounding rect precision)
          try {
            const frontEl = frontFace || vp.querySelector('.flip-face.front');
            if (frontEl) {
              const h = (frontEl.getBoundingClientRect && frontEl.getBoundingClientRect().height) || frontEl.offsetHeight || 220;
              vp.style.height = h + 'px';
              vp.style.minHeight = h + 'px';
              vp.style.overflow = 'hidden';
              const sc = vp.querySelector('.flip-scene'); if (sc) sc.style.minHeight = h + 'px';
            }
          } catch(_){ }
          const willShowBack = !vp.classList.contains('is-flipped');
          window.__dayFlipAnimating = true;

                  const buildChart = () => {
            try {
              if (typeof Chart === 'undefined') return;
              const rows = Array.isArray(window.DayDisplayRows) && window.DayDisplayRows.length ? window.DayDisplayRows : (Array.isArray(window.dayData) ? window.dayData : []);
              // Get name from row data
              const labels = rows.map(r => String(r.name || ''));
              try{ console.log('DEBUG: buildChart DAY start', {labels, rowsLength: rows.length}); } catch(_){ }
              const ventas = rows.map(r=>Number(r.Total||0));
              const puntos = rows.map(r=>Number(r.Puntaje||0));
              const canvas = document.getElementById('daily-team-chart'); if (!canvas) return;
              const wrap = canvas.parentElement;
              try {
                const vpH = (vp && vp.getBoundingClientRect && vp.getBoundingClientRect().height) || vp.clientHeight || 320;
                const minH = 320;
                const finalH = Math.max(vpH, minH);
                if (wrap) {
                  wrap.style.height = finalH + 'px';
                  wrap.style.maxHeight = finalH + 'px';
                  wrap.style.overflow = 'visible';
                  wrap.style.paddingBottom = '28px';
                }
              } catch(_){ }
                try{ if (window.__dailyChart) { window.__dailyChart.destroy(); } } catch(_){ }
                try { if (typeof window.__ensureHiDPICanvas === 'function') window.__ensureHiDPICanvas(canvas, finalH); } catch(_){}
                const ctx = canvas.getContext('2d');
              window.__dailyChart = new Chart(ctx, {
                type: 'bar',
                data: { labels, datasets: [
                  { label: 'Ventas', data: ventas, backgroundColor: 'rgba(37,99,235,0.85)' },
                  { label: 'Puntaje', data: puntos, backgroundColor: 'rgba(239,68,68,0.85)' }
                ] },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  // give extra bottom padding so x-axis labels and datalabels have room
                  layout: { padding: { top: 12, bottom: 60 } },
                  plugins: {
                    legend: { display: true, position: 'top' },
                    datalabels: {
                      // place labels above the bar (outside the bar area)
                      anchor: 'end',
                      align: 'end',
                      offset: -6,
                      clamp: false,
                      clip: false,
                      color: '#0b1220',
                      font: { weight: '600', size: 12 },
                      display: (context) => {
                        const raw = context?.dataset?.data?.[context.dataIndex];
                        const n = Number(raw);
                        return !Number.isNaN(n) && n !== 0;
                      },
                      formatter: (value) => formatMetricValue(value)
                    }
                  },
                  scales: {
                    x: {
                      grid: { display: false },
                      ticks: {
                        display: true,
                        color: '#1e293b',
                        autoSkip: false,
                        maxRotation: 0,
                        minRotation: 0,
                        padding: 12,
                        font: { 
                          size: 13,
                          weight: '500'
                        },
                        textStrokeWidth: 0.5
                      }
                    },
                    y: { beginAtZero: true, grid: { display: false }, ticks: { display: false } }
                  }
                }
              });
            } catch(e){ console.warn('daily chart build error', e); }
          };

          const onTransit = (ev) => {
            if (ev && ev.propertyName && ev.propertyName.indexOf('transform') === -1) return;
            try {
                  // Pause visibility watcher while we perform flip/cleanup to avoid fight conditions
                  try { window.__dayWatcherPaused = true; } catch(_){}
                  try { console.log('[DAY onTransit] willShowBack=', willShowBack, 'property=', ev && ev.propertyName); } catch(_){ }
                  if (willShowBack) {
                    try { console.log('[DAY onTransit] showing back -> buildChart'); } catch(_){ }
                    buildChart();
                    try { if (frontFace) { frontFace.classList.add('flip-front-hidden'); } } catch(_){ }
                  } else {
              try { console.log('[DAY onTransit] showing front -> cleaning and destroying chart'); } catch(_){ }
              try { if (frontFace) { frontFace.classList.remove('flip-front-hidden'); frontFace.classList.add('force-visible');
                  // Destroy chart first to avoid Chart.js or related code re-applying styles while we restore the front face
                  try{ if (window.__dailyChart) { window.__dailyChart.destroy(); window.__dailyChart = null; } } catch(_){ }
                  // After the chart is destroyed, restore visibility on the front face. Use a tiny delay to let any
                  // layout/paint triggered by chart destruction settle before removing the hiding class.
                  try {
                    if (frontFace) {
                      // remove the hidden class after a short tick
                      setTimeout(() => {
                        try { frontFace.classList.remove('flip-front-hidden'); } catch(_){}
                        try { frontFace.classList.add('force-visible'); } catch(_){}
                        try { frontFace.style.setProperty('visibility','visible','important'); frontFace.style.setProperty('opacity','1','important'); } catch(_){ }
                      }, 30);
                    }
                  } catch(_){ }
              } } catch(_){ }
              // Aggressively clear inline styles that could keep the front/table hidden
                    try {
                      if (frontFace && frontFace.querySelectorAll) {
                        Array.from(frontFace.querySelectorAll('*')).forEach(el => {
                          try {
                            if (!el || !el.style) return;
                            if (el.style.visibility && el.style.visibility.indexOf('hidden') !== -1) el.style.visibility = '';
                            if (el.style.display && el.style.display.indexOf('none') !== -1) el.style.display = '';
                            if (el.style.opacity === '0') el.style.opacity = '';
                            if (el.style.pointerEvents === 'none') el.style.pointerEvents = '';
                            if (el.style.transform && el.style.transform.indexOf('rotateY') !== -1) el.style.transform = '';
                          } catch(_){ }
                        });
                      }
                      try { if (typeof window.__clearDayHiddenStyles === 'function') window.__clearDayHiddenStyles(); } catch(_){ }
                      // As an extra last-resort override, set important visibility on any tables in the front face
                      try {
                        const tbls = frontFace && frontFace.querySelectorAll ? Array.from(frontFace.querySelectorAll('table')) : [];
                        tbls.forEach(t => { try { t.style.setProperty('visibility','visible','important'); t.style.setProperty('display','table','important'); t.style.setProperty('opacity','1','important'); } catch(_){} });
                      } catch(_){ }
                    } catch(_){ }
                    }
              // restore any hidden sticky elements
              try {
                const hidden = vp && vp.__hiddenSticky;
                if (hidden && Array.isArray(hidden)) {
                  hidden.forEach(item => { try{ item.el.style.visibility = item.vis || ''; } catch(_){} });
                  vp.__hiddenSticky = null;
                }
              } catch(_){}
            } finally {
              try {
                if (!willShowBack) {
                  const wrapEl = vp && vp.querySelector && vp.querySelector('.chart-wrapper');
                  if (wrapEl) { wrapEl.style.height = ''; wrapEl.style.maxHeight = ''; wrapEl.style.overflow = ''; wrapEl.style.paddingBottom = ''; }
                  setTimeout(() => { try { vp.style.height = ''; vp.style.minHeight = ''; if (scene) { scene.style.minHeight = ''; scene.style.height = ''; } } catch(_){} }, 200);
                }
              } catch(_){}
              if (scene) scene.removeEventListener('transitionend', onTransit);

              // Robust cleanup: retry-check computed styles and clear inline hiding up to a few times.
              (function ensureFrontVisibleRetry(attempt){
                try {
                  if (!frontFace) return;
                  // remove transient force-visible immediately
                  try { frontFace.classList.remove('force-visible'); } catch(_){ }
                  // run global helper to clear suspicious inline styles
                  try { if (typeof window.__clearDayHiddenStyles === 'function') window.__clearDayHiddenStyles(); } catch(_){ }

                  // Check computed style of the front face and any contained tables
                  const cs = window.getComputedStyle(frontFace);
                  try { console.log('[ensureFrontVisibleRetry] attempt=', attempt, 'front computed=', cs ? {visibility: cs.visibility, display: cs.display, opacity: cs.opacity} : null); } catch(_){ }
                  let stillHidden = false;
                  if (cs) {
                    if (cs.visibility === 'hidden' || cs.display === 'none' || Number((cs.opacity || '1')) === 0) stillHidden = true;
                  }
                  if (!stillHidden) {
                    // Also verify tables inside
                    const tbls = frontFace.querySelectorAll ? Array.from(frontFace.querySelectorAll('table')) : [];
                    for (const t of tbls) {
                      try {
                        const cst = window.getComputedStyle(t);
                        if (cst && (cst.visibility === 'hidden' || cst.display === 'none' || Number((cst.opacity||'1')) === 0)) { stillHidden = true; break; }
                      } catch(_){ }
                    }
                  }

                  if (stillHidden) {
                    // collect problematic elements for logging
                    try {
                      const problems = [];
                      const all = frontFace.querySelectorAll ? Array.from(frontFace.querySelectorAll('*')) : [];
                      all.forEach(el => {
                        try {
                          const s = window.getComputedStyle(el);
                          if (s && (s.visibility === 'hidden' || s.display === 'none' || Number((s.opacity||'1')) === 0)) {
                            problems.push({ tag: el.tagName, id: el.id || null, cls: el.className || null, vis: s.visibility, display: s.display, opacity: s.opacity });
                          }
                        } catch(_){}
                      });
                      try { console.log('[ensureFrontVisibleRetry] attempt=', attempt, 'stillHidden=true problems=', problems.slice(0,20)); } catch(_){ }
                    } catch(_){}
                  } else {
                    try { console.log('[ensureFrontVisibleRetry] attempt=', attempt, 'front appears visible'); } catch(_){ }
                  }

                  if (stillHidden && attempt < 3) {
                    // Forcefully clear inline styles on front and tables
                    try {
                      if (frontFace && frontFace.querySelectorAll) {
                        Array.from(frontFace.querySelectorAll('*')).forEach(el => {
                          try {
                            if (!el || !el.style) return;
                            if (el.style.visibility && el.style.visibility.indexOf('hidden') !== -1) el.style.visibility = '';
                            if (el.style.display && el.style.display.indexOf('none') !== -1) el.style.display = '';
                            if (el.style.opacity === '0') el.style.opacity = '';
                            if (el.style.pointerEvents === 'none') el.style.pointerEvents = '';
                            if (el.style.transform && el.style.transform.indexOf('rotateY') !== -1) el.style.transform = '';
                          } catch(_){ }
                        });
                      }
                    } catch(_){ }
                    // schedule another check with exponential backoff
                    setTimeout(() => ensureFrontVisibleRetry(attempt + 1), 80 * Math.pow(2, attempt));
                  }
                } catch(e){ try{ console.warn('ensureFrontVisibleRetry error', e); }catch(_){} }
              })(0);

              // give a little extra time before re-enabling the watcher so any late DOM changes settle
              try { setTimeout(() => { try { window.__dayWatcherPaused = false; } catch(_){} }, 900); } catch(_){ }

              window.__dayFlipAnimating = false;
            }
          };

          if (scene) scene.addEventListener('transitionend', onTransit);
          // Before starting the flip, hide any sticky elements inside the front face so they don't overlap during the 3D rotate
          try {
            if (willShowBack && frontFace) {
              const hidden = [];
              Array.from(frontFace.querySelectorAll('*')).forEach(el => {
                try {
                  const cs = window.getComputedStyle(el);
                  if (cs && (cs.position === 'sticky' || cs.position === 'fixed')) {
                    hidden.push({el, vis: el.style.visibility});
                    el.style.visibility = 'hidden';
                  }
                } catch(_) {}
              });
              // store to restore later
              vp.__hiddenSticky = hidden;
            }
          } catch(_) {}
          try { if (frontFace) frontFace.style.visibility = 'visible'; } catch(_){}
          void vp.offsetHeight;
          if (willShowBack) vp.classList.add('is-flipped'); else vp.classList.remove('is-flipped');
          setTimeout(() => { if (window.__dayFlipAnimating) { try { onTransit(); } catch(_) { window.__dayFlipAnimating = false; } } }, 500);

        } catch(e){ console.warn('toggleDayFlip error', e); }
      };

      // Fallback click listener for day flip
      document.addEventListener('click', function(ev){
        const t = ev.target;
        if (t && t.id === 'btn-flip-day'){
          ev.preventDefault();
          try{ if (typeof window.__toggleDayFlip === 'function') window.__toggleDayFlip(); } catch(e){ console.warn(e); }
        }
      }, true);
    })();
  </script>
</body>
</html>