<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard - EstadÃ­sticas</title>

  <!-- Estilos base y sidebar -->
  <link rel="stylesheet" href="css/theme.css">
  <link rel="stylesheet" href="css/sidebar-shared.css">

  <!-- LibrerÃ­as -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

  <!-- Scripts de app -->
  <!-- Cargar primero las dependencias -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
  <!-- Eliminado kit de Font Awesome (403). Se usa el CSS 5.15.4 ya cargado arriba. -->
  
  <!-- Luego cargar los scripts de la aplicaciÃ³n -->
  <script src="/js/logout-handler.js"></script>
  <script src="/js/user-info.js"></script>
  <script src="/utils/teams.js"></script>
  <script src="js/sidebar-loader.js"></script>
  
  <!-- Script de inicializaciÃ³n de grÃ¡ficos -->
  <script>
    // Verificar que Chart.js estÃ© disponible
    if (typeof Chart === 'undefined') {
      console.error('Error: No se pudo cargar Chart.js');
    } else {
      console.log('Chart.js cargado correctamente');
      // Registrar el plugin de etiquetas si estÃ¡ disponible
      if (typeof ChartDataLabels !== 'undefined') {
        Chart.register(ChartDataLabels);
        console.log('Plugin de etiquetas registrado');
      }
    }
  </script>

  <style>
    /* Layout general consistente con otras pÃ¡ginas */
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f7fa; color: #1e293b; }

    .layout { display: flex; min-height: 100vh; }

    .main-content {
      flex: 1;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }
    .page-title { font-size: 1.8rem; font-weight: 800; margin: 0; }
    .page-actions { display: flex; gap: 8px; }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 24px;
      max-width: 95%;
      margin: 0 auto;
      padding: 0 20px;
      width: 100%;
      box-sizing: border-box;
    }

    .card {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      padding: 24px;
      box-sizing: border-box;
      width: 100%;
      margin: 0;
    }

    .chart-card { grid-column: span 12; }
    @media (min-width: 900px) {
      .chart-card.half { grid-column: span 6; }
    }

    .card h3 { margin: 0 0 12px 0; font-size: 1.05rem; color: #1e293b; }
    
    /* Estilos para la tabla de calificaciones */
    .ventas-diarias-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      margin-top: 10px;
      width: 100%;
    }
    
    .ventas-diarias-card {
      background: white;
      border-radius: 4px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      width: 100%;
    }
    
    .ventas-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 0 auto;
    }
    
    .ventas-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem;
      table-layout: fixed;
    }
    
    .ventas-table th,
    .ventas-table td {
      padding: 14px 20px;
      text-align: left;
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
      line-height: 1.5;
    }
    
    .ventas-table th {
      background: #1f3b63;
      color: #fff;
      font-weight: 700;
      text-transform: uppercase;
      text-align: center;
      padding: 16px 20px;
      font-size: 0.9rem;
      letter-spacing: 0.5px;
    }
    
    .ventas-table td:first-child {
      width: 65%;
      padding-left: 16px;
    }
    
    .ventas-table td:last-child {
      width: 35%;
      text-align: center;
      font-weight: bold;
      padding-right: 16px;
    }
    .chart-wrapper { position: relative; height: 320px; }

    /* Responsive para mÃ³vil: sidebar superior */
    @media (max-width: 768px) {
      .main-content { margin-left: 0; width: 100%; padding: 15px; margin-top: 70px; }
    }
    /* Tabla de conversiÃ³n por equipo */
    .conversion-grid { 
      display: grid; 
      grid-template-columns: 2fr 1fr; 
      gap: 8px; 
      font-family: Arial, sans-serif;
    }
    .conversion-card { 
      background: #fff; 
      border-radius: 8px; 
      box-shadow: 0 2px 6px rgba(0,0,0,0.1); 
      padding: 12px; 
      border: 1px solid #dee2e6;
    }
    .conversion-title { 
      font-weight: 800; 
      margin: 0 0 8px 0; 
      color: #000; 
      font-size: 1rem;
      text-align: center;
      background: #fff9c2;
      padding: 6px 4px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .conversion-subtitle { 
      display: none; 
    }
    .sales-table { 
      width: 100%; 
      border-collapse: collapse; 
      font-size: 0.85rem;
      margin-bottom: 0;
    }
    .sales-table th, 
    .sales-table td { 
      padding: 4px 6px; 
      text-align: center; 
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
      height: 28px;
    }
    .sales-table th { 
      background: #1f3b63; 
      color: #fff; 
      font-weight: 700; 
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 6px 4px;
    }
    .sales-table td:first-child, 
    .sales-table th:first-child { 
      text-align: left; 
      padding-left: 8px;
      width: 40%;
    }
    .sales-table .total-row { 
      background: #0b5ed7; 
      color: #fff; 
      font-weight: 800; 
      font-size: 0.9rem;
    }
    .sales-table .score-col { 
      background: #ffeb7a; 
      font-weight: 800; 
      color: #000;
    }
    /* Layout mejorado para conversiÃ³n: tabla + panel LINEAS */
    .conv-two-col { display: flex; gap: 28px; align-items: flex-start; width: 100%; }
    .conv-left { flex: 1 1 0; min-width: 0; max-height: 520px; overflow-y: auto; overflow-x: hidden; padding-right: 4px; }
    .conv-right { flex: 0 0 320px; align-self: stretch; }
    .mini-card { background: #fff; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 8px; }
    .mini-card .mini-table { width: 100%; }
    .mini-card .mini-table th { padding: 12px; font-size: 0.9rem; }
    .mini-card .mini-table td { padding: 10px 12px; font-size: 1rem; text-align: center; }
    @media (max-width: 900px) { .conv-two-col { flex-direction: column; } .conv-left { min-width: 0; } .conv-right { order: -1; width: 100%; min-width: 0; } }
    .mini-table { 
      width: 100%; 
      border-collapse: collapse; 
      font-size: 0.85rem;
      margin-top: 15px;
    }
    .mini-table th, 
    .mini-table td { 
      padding: 4px 6px; 
      text-align: center; 
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
      height: 28px;
    }
    .mini-table th { 
      background: #1f3b63; 
      color: #fff; 
      font-weight: 700;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 6px 4px;
    }
    .mini-table .total { 
      background: #0b5ed7; 
      color: #fff; 
      font-weight: 800;
      font-size: 0.9rem;
    }
    @media (max-width: 900px) { 
      .conversion-grid { 
        grid-template-columns: 1fr; 
      }
      .ventas-diarias-grid { 
        grid-template-columns: 1fr; 
      }
    }
    
    /* Estilos para la secciÃ³n de Ventas Diarias */
    .ventas-diarias-grid {
      display: grid;
      gap: 16px;
      margin-top: 10px;
    }
    
    .ventas-diarias-card {
      background: white;
      border-radius: 4px;
      padding: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .ventas-title {
      font-weight: 800;
      margin: 0 0 10px 0;
      color: #000;
      font-size: 1rem;
      text-align: center;
      background: #fff9c2;
      padding: 6px 4px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .ventas-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      margin-bottom: 15px;
    }
    
    .ventas-table th,
    .ventas-table td {
      padding: 6px 8px;
      text-align: center;
      border: 1px solid #dee2e6;
      font-family: Arial, sans-serif;
    }
    
    .ventas-table th {
      background: #1f3b63;
      color: #fff;
      font-weight: 700;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 8px 4px;
    }
    
    .ventas-table td:first-child {
      text-align: left;
      padding-left: 10px;
    }
    
    .ventas-table .total-row {
      background: #0b5ed7;
      color: #fff;
      font-weight: 800;
      font-size: 0.9rem;
    }
    
    .ventas-table .score-col {
      background: #ffeb7a;
      font-weight: 800;
      color: #000;
    }
    
    /* Estilos para grÃ¡ficos */
    .chart-card {
      grid-column: 1 / -1;
      margin-bottom: 20px;
    }
    
    .chart-wrapper {
      position: relative;
      height: 400px;
      width: 100%;
      min-height: 300px;
    }
    
    .chart-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      padding: 20px;
      text-align: center;
      color: #666;
    }
    
    .chart-loading .spinner-border {
      width: 3rem;
      height: 3rem;
    }
    
    .alert {
      padding: 15px;
      margin-bottom: 20px;
      border: 1px solid transparent;
      border-radius: 4px;
    }
    
    .alert-danger {
      color: #721c24;
      background-color: #f8d7da;
      border-color: #f5c6cb;
    }

    /* Estilos para la nueva gráfica de ventas y puntaje */
    .date-filter-container {
      width: fit-content;
      margin-bottom: 15px;
      background: #f8fafc;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }
    
    .date-filter {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
    }
    
    .date-filter label {
      color: #475569;
      font-weight: 500;
      margin-right: 2px;
      font-size: 12px;
      white-space: nowrap;
    }
    
    .date-select {
      padding: 2px 6px;
      border: 1px solid #cbd5e1;
      border-radius: 4px;
      background-color: white;
      font-size: 12px;
      width: 70px;
      height: 26px;
    }
    
    .filter-button {
      padding: 2px 8px;
      background-color: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      font-size: 11px;
      height: 26px;
      white-space: nowrap;
      transition: background-color 0.2s;
    }
    
    .filter-button:hover {
      background-color: #2563eb;
    }
    
    #reset-filter {
      background-color: #64748b;
      padding: 2px 6px;
    }
    
    #reset-filter:hover {
      background-color: #475569;
    }

    .graph-container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
      width: 100%;
      height: 460px;
      max-height: 460px;
      position: relative;
    }
    
    .graph-canvas {
      width: 100% !important;
      height: 100% !important;
      min-height: 420px;
    }

    /* Estilos para notificaciones */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 25px;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      display: flex;
      align-items: center;
      transform: translateX(120%);
      transition: transform 0.3s ease-in-out;
      max-width: 350px;
    }

    .notification.show {
      transform: translateX(0);
    }

    .notification.success {
      background-color: #10b981;
      border-left: 4px solid #059669;
    }

    .notification.error {
      background-color: #ef4444;
      border-left: 4px solid #dc2626;
    }

    .notification i {
      margin-right: 10px;
      font-size: 20px;
    }
    
    /* Estilos para el modal de detalle del día */
    .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
    .modal{background:#fff;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.2);max-width:960px;width:92%;max-height:80vh;overflow:auto}
    .modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e2e8f0;font-weight:800}
    .modal-body{padding:12px 16px}
    .close-btn{border:none;background:#e11d48;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
    .table-compact{width:100%;border-collapse:collapse;font-size:.9rem}
    .table-compact th,.table-compact td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left}
    .table-compact th{background:#1f3b63;color:#fff}
    .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  </style>
</head>
<body>
  <div class="layout">
    <!-- SIDEBAR (cargado dinÃ¡micamente) -->
    <nav class="sidebar sidebar-inicio" data-active="estadisticas"></nav>

    <main class="main-content">
      <header class="page-header">
        <h1 class="page-title"><i class="fas fa-chart-line" style="color:#22b3ec; margin-right:8px;"></i> Estadísticas</h1>
        <div class="page-actions">
          <button id="btn-refresh" class="btn-refresh" style="background:#22b3ec;color:#fff;border:none;border-radius:8px;padding:8px 12px;font-weight:600;cursor:pointer;">Actualizar</button>
        </div>
      </header>

      <section class="stats-grid">
        <div class="card chart-card">
          <h3>Ventas por equipo</h3>
          <div class="chart-wrapper">
            <canvas id="chart-ventas-dia"></canvas>
          </div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; grid-column: 1 / -1; width: 100%; margin: 0; padding: 0;">
          <div class="card">
            <h3></h3>
            <div id="conversion-table" class="conversion-grid"></div>
          </div>

          <div class="card">
            <div class="ventas-diarias-grid">
              <div id="ventas-dia-card" class="ventas-diarias-card"><!-- Renderizado por JS --></div>
            </div>
          </div>
        </div>

        <!-- Nueva Sección: Gráfica de Ventas y Puntaje (Últimos 7 días) -->
        <div class="card chart-card">
          <h3><i class="fas fa-chart-bar" style="color:#22b3ec; margin-right:8px;"></i> Ventas y Puntaje - Últimos 7 días</h3>
          
          <!-- Filtro de Fecha -->
          <div class="date-filter-container" style="margin-bottom: 20px;">
            <div class="date-filter">
              <label for="month-select">Mes:</label>
              <select id="month-select" class="date-select">
                <option value="0">Enero</option>
                <option value="1">Febrero</option>
                <option value="2">Marzo</option>
                <option value="3">Abril</option>
                <option value="4">Mayo</option>
                <option value="5">Junio</option>
                <option value="6">Julio</option>
                <option value="7">Agosto</option>
                <option value="8">Septiembre</option>
                <option value="9">Octubre</option>
                <option value="10">Noviembre</option>
                <option value="11">Diciembre</option>
              </select>
              
              <label for="day-select">Día:</label>
              <select id="day-select" class="date-select">
                <!-- Los días se llenarán dinámicamente -->
              </select>
              
              <label for="year-select">Año:</label>
              <select id="year-select" class="date-select">
                <option value="2023">2023</option>
                <option value="2024">2024</option>
                <option value="2025" selected>2025</option>
                <option value="2026">2026</option>
              </select>
              
              <button id="apply-filter" class="filter-button">Aplicar Filtro</button>
              <button id="reset-filter" class="filter-button">Hoy</button>
            </div>
          </div>

          <!-- Gráfica de Ventas y Puntaje -->
          <div class="graph-container">
            <canvas id="ventasPuntajeChart" class="graph-canvas"></canvas>
          </div>
        </div>
      </div>
      </section>
    </main>
  </div>

  <!-- Modal de detalle del día -->
  <div id="day-detail-modal" class="modal-overlay">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="dayDetailTitle">
      <div class="modal-header">
        <div id="dayDetailTitle">Detalle de Ventas del Día</div>
        <button class="close-btn" id="day-detail-close">Cerrar</button>
      </div>
      <div class="modal-body">
        <div class="toolbar">
          <label for="filter-team-select" style="font-weight:600">Equipo:</label>
          <select id="filter-team-select"></select>
          <span id="day-detail-subtitle" style="margin-left:auto;color:#475569"></span>
        </div>
        <div style="overflow:auto">
          <table class="table-compact" id="day-detail-table">
            <thead>
              <tr>
                <th>Equipo</th>
                <th>Agente</th>
                <th>Servicio</th>
                <th>Mercado</th>
                <th>Puntaje</th>
                <th>Fecha</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Datos de ejemplo para visualizaciÃ³n inicial (puedes reemplazar por datos reales)
    function rand(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }

    async function renderConversionTable(root) {
      try {
        console.log('Iniciando renderConversionTable con root:', root);
        if (!root) {
          console.error('Error: No se proporcionÃ³ un elemento raÃ­z vÃ¡lido');
          return;
        }
        
        // Verificar autenticaciÃ³n
        if (!checkAuth()) return;
        
        // Mostrar indicador de carga
        root.innerHTML = '<div class="text-center py-4"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Cargando...</span></div><p class="mt-2">Cargando datos de equipos...</p></div>';
        
        // Rango del MES COMPLETO (desde día 1 hasta hoy)
        let fechaInicio = '';
        let fechaFin = '';
        {
          const hoy = new Date();
          const primerDiaMes = new Date(hoy.getFullYear(), hoy.getMonth(), 1);
          const fmt = (d)=>`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
          fechaInicio = fmt(primerDiaMes);  // Primer día del mes
          fechaFin = fmt(hoy);               // Día actual
          console.log('[ESTADISTICAS] Rango mes completo:', { fechaInicio, fechaFin });
        }
        
        // Construir URL con parámetros
        let url = '/api/equipos/estadisticas';
        const params = new URLSearchParams();
        
        if (fechaInicio) params.append('fechaInicio', fechaInicio);
        if (fechaFin) params.append('fechaFin', fechaFin);
        // Si el rol es agente, forzar que el backend devuelva TODOS los equipos
        try {
          const u = JSON.parse(sessionStorage.getItem('user') || localStorage.getItem('user') || 'null');
          const role = (u?.role || '').toString().trim().toLowerCase();
          if (role === 'agent' || role === 'agente') params.append('forceAll', '1');
        } catch(_){ }
        if (params.toString()) url += `?${params.toString()}`;
        
        console.log('Solicitando datos a:', url);
        
        // Realizar petición a la API usando la función fetchWithAuth
        console.log('Realizando petición a la API...');
        const response = await fetchWithAuth(url);
        console.log('Respuesta recibida:', response);
        
        if (!response) {
          console.error('No se recibiÃ³ respuesta de la API (posible error de autenticaciÃ³n)');
          return; // Error de autenticaciÃ³n ya manejado
        }
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Error en la respuesta:', {
            status: response.status,
            statusText: response.statusText,
            error: errorText
          });
          throw new Error(`Error HTTP: ${response.status} - ${errorText}`);
        }
        
        let data = await response.json();
        let usedAllFallback = false;
        console.log('Datos recibidos de la API (MES):', {
          success: data.success,
          message: data.message,
          total: data.total,
          data: data.data ? `Array de ${data.data.length} elementos` : 'No hay datos'
        });
        
        // Eliminado fallback all=1 para mostrar solo datos del MES ACTUAL
        
        if (!data.success) {
          console.error('Formato de respuesta invÃ¡lido:', data);
          throw new Error('Formato de respuesta invÃ¡lido');
        }

        
        // Si no hay datos (o según rol), podremos forzar fallback con /api/leads
        let teamData = [];
        // Determinar si el payload está vacío o si trae solo equipos en cero
        const payloadEmpty = !data.data || data.data.length === 0;
        const payloadZero = Array.isArray(data.data) && data.data.length > 0 && data.data.every(e => (Number(e.Total||0) === 0) && (Number(e.ICON||0) === 0) && (Number(e.BAMO||0) === 0) && (Number(e.Puntaje||0) === 0));

        if (!(payloadEmpty || payloadZero)) {
          // Mapear datos de la API al formato esperado (mantener Puntaje como número)
          teamData = data.data.map(equipo => ({
            name: equipo.TEAM || equipo.team || 'Sin equipo',
            ICON: parseFloat(equipo.ICON || 0),
            BAMO: parseFloat(equipo.BAMO || 0),
            Total: parseFloat(equipo.Total || 0),
            Puntaje: parseFloat(equipo.Puntaje || 0)
          }));
        }

        // Solo fallback si la respuesta viene vacía/cero
        if (payloadEmpty || payloadZero) {
          try {
            console.log('[ESTADISTICAS][MES] Construyendo datos desde /api/leads (fallback por rol o vacío)');
            const leadsResp = await fetchWithAuth('/api/leads'); // ya filtra por el mes actual
            if (leadsResp && leadsResp.ok) {
              const leadsJson = await leadsResp.json();
              const leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
              const getByPath = (obj, path) => { try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch(_) { return undefined; } };
              const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
              const teamMap = new Map();
              const teamNameOf = (lead) => {
                const t = findFirst(lead, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']);
                const s = (t || '').toString().trim();
                return s || 'Sin equipo';
              };
              const isICON = (lead) => {
                const v = (findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
                return v.includes('ICON');
              };
              const isBAMO = (lead) => {
                const v = (findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
                return v.includes('BAMO');
              };
              const getPuntaje = (lead) => {
                const p = findFirst(lead, ['puntaje','score','puntos']);
                const n = typeof p === 'number' ? p : parseFloat(p);
                return isNaN(n) ? 0 : n;
              };
              leads.forEach(l => {
                const name = teamNameOf(l);
                if (!teamMap.has(name)) teamMap.set(name, { name, ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });
                const agg = teamMap.get(name);
                agg.Total += 1;
                if (isICON(l)) agg.ICON += 1; else if (isBAMO(l)) agg.BAMO += 1;
                agg.Puntaje += getPuntaje(l);
              });
              teamData = Array.from(teamMap.values());
            }
          } catch (fe) {
            console.warn('[ESTADISTICAS][MES] Fallback por rol/empty falló:', fe);
          }
        }
        // Separar TEAM LINEAS a tabla aparte y mantener principal sin LINEA(S)
        const lineasData = Array.isArray(data.lineas) ? data.lineas.map(r => ({
          name: r.name || r.TEAM || 'SIN NOMBRE',
          ICON: parseFloat(r.ICON || 0)
        })) : [];
        const lineasTotalICON = typeof data.lineasTotalICON === 'number' ? data.lineasTotalICON : lineasData.reduce((acc, r) => acc + (r.ICON || 0), 0);
        const excludeNames = new Set(['TEAM LINEA','TEAM LINEAS']);
        let fallbackTeamData = teamData.filter(t => !excludeNames.has((t.name || '').toUpperCase()));
        // Fallback: si principal queda vacío o todos son cero, construir desde /api/leads con rango del DÍA efectivo
        const allZero = fallbackTeamData.length > 0 && fallbackTeamData.every(t => Number(t.Total||0) === 0 && Number(t.ICON||0) === 0 && Number(t.BAMO||0) === 0 && Number(t.Puntaje||0) === 0);
        if (fallbackTeamData.length === 0 || allZero) {
          try {
            console.warn('fallbackTeamData vacío. Construyendo desde /api/leads para el día efectivo...');
            // Helpers locales
            const BUSINESS_TZ_OFFSET_MIN = -6 * 60; // ajustar si tu TZ cambia
            const toISOInTZLocal = (date, tzOffsetMinutes) => {
              const target = new Date(date.getTime() + tzOffsetMinutes * 60000);
              const y = target.getUTCFullYear();
              const m = String(target.getUTCMonth() + 1).padStart(2, '0');
              const d = String(target.getUTCDate()).padStart(2, '0');
              return `${y}-${m}-${d}`;
            };
            const getByPath = (obj, path) => {
              try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch (_) { return undefined; }
            };
            const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
            const tryDateFrom = (val) => {
              if (!val) return null; if (typeof val === 'string') { const s = val.trim();
                if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [y,m,d] = s.split('-').map(Number); return new Date(Date.UTC(y, m-1, d, 12, 0, 0)); }
                if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) { const parts = s.split(/[\/\-]/).map(Number); const [d,m,y] = parts; return new Date(Date.UTC(y, m-1, d, 12, 0, 0)); }
              }
              if (typeof val === 'number') return new Date(val < 1e12 ? val*1000 : val);
              const dt = new Date(val); return isNaN(dt) ? null : dt;
            };

            // Rango día efectivo (mismo criterio que arriba)
            const nowLocal = new Date();
            const cutoffHour = 9, cutoffMinute = 30;
            const isBeforeCutoff = (nowLocal.getHours() < cutoffHour) || (nowLocal.getHours() === cutoffHour && nowLocal.getMinutes() < cutoffMinute);
            const effective = new Date(nowLocal);
            if (isBeforeCutoff) effective.setDate(effective.getDate() - 1);
            const startLocal = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate(), 0, 0, 0, 0);
            // SIEMPRE mostrar datos hasta las 9:30 AM del día siguiente (no cortar a la hora actual)
            // Esto permite que los datos se mantengan visibles todo el día hasta el siguiente corte
            const endExclusive = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate() + 1, cutoffHour, cutoffMinute, 0, 0);
            const dayKey = toISOInTZLocal(effective, BUSINESS_TZ_OFFSET_MIN);

            // Obtener leads
            const leadsResp = await fetchWithAuth('/api/leads');
            if (leadsResp && leadsResp.ok) {
              const leadsJson = await leadsResp.json();
              let leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
              console.log(`[FALLBACK LEADS] Recibidos ${leads.length} registros`);

              // Filtrar por día efectivo
              const createdPaths = [
                'dia_venta','diaVenta','creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha',
                '_raw.creadoEn','_raw.fecha_creacion','_raw.fechaCreacion','_raw.createdAt','_raw.created_at','_raw.fecha',
                'metadata.createdAt','audit.createdAt','timestamps.createdAt'
              ];

              const inDay = leads.filter(l => {
                const v = findFirst(l, createdPaths);
                const dt = tryDateFrom(v);
                const d = dt && new Date(dt);
                return d && d >= startLocal && d < endExclusive;
              });

              // Agrupar por equipo e inferir métricas
              const teamMap = new Map();
              const teamNameOf = (lead) => {
                const t = findFirst(lead, ['TEAM','team','equipo','grupo','department','team_name','Team']);
                const s = (t || '').toString().trim();
                return s || 'Sin equipo';
              };
              const isICON = (lead) => {
                const v = (findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
                return v.includes('ICON');
              };
              const isBAMO = (lead) => {
                const v = (findFirst(lead, ['producto','servicio','market','mercado','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
                return v.includes('BAMO');
              };
              const getPuntaje = (lead) => {
                const p = findFirst(lead, ['puntaje','score','puntos']);
                const n = typeof p === 'number' ? p : parseFloat(p); return isNaN(n) ? 0 : n;
              };

              inDay.forEach(l => {
                const name = teamNameOf(l);
                if (!teamMap.has(name)) teamMap.set(name, { name, ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });
                const agg = teamMap.get(name);
                agg.Total += 1;
                if (isICON(l)) agg.ICON += 1; else if (isBAMO(l)) agg.BAMO += 1;
                agg.Puntaje += getPuntaje(l);
              });

              fallbackTeamData = Array.from(teamMap.values()).filter(t => !excludeNames.has((t.name || '').toUpperCase()));
              teamData = fallbackTeamData; // usar fallback también para totales
              console.log('[FALLBACK LEADS] Construido fallbackTeamData y aplicado a teamData:', fallbackTeamData);
            } else {
              console.warn('No se pudo obtener /api/leads para fallback.');
            }
          } catch (fe) {
            console.error('Error en fallback por leads:', fe);
          }
        }
        
        // Visibilidad (MES): no filtrar por fin de semana; siempre considerar todos los equipos
        (function applyMonthVisibility(){
          try {
            const norm = (s)=>String(s||'').normalize('NFD').replace(/\p{Diacritic}+/gu,'').trim().toLowerCase();
            const teamCanon = (name)=>{
              const n = norm(name).replace(/^team\s+/, '');
              if (n.includes('pleitez')) return 'Pleitez';
              if (n.includes('roberto')) return 'Roberto';
              if (n.includes('marisol')) return 'Marisol';
              if (n.includes('johana') || n.includes('johanna')) return 'Johana';
              if (n.includes('irania')) return 'Irania';
              return name || 'Sin equipo';
            };
            const groupA = new Set(['johana','irania']);
            const groupB = new Set(['pleitez','roberto','marisol']);
            const today = new Date();
            // No filtrar por día: mantener todos los equipos del mes

            // Asegurar presencia de filas en 0 para equipos faltantes
            const allTeams = (function(){
              try {
                if (window.Teams && typeof window.Teams.getAllTeams === 'function') {
                  const arr = window.Teams.getAllTeams(); // devuelve nombres
                  return Array.isArray(arr) ? arr : [];
                }
              } catch(_){ }
              // fallback estático
              return ['Pleitez','Roberto','Marisol','Johana','Irania'];
            })();
            const targetSet = new Set(allTeams.map(x=>norm(x)));
            const ensureRows = (arr)=>{
              try {
                const have = new Set((arr||[]).map(t=>norm(t?.name)));
                const out = Array.isArray(arr) ? arr.slice() : [];
                for (const t of targetSet) {
                  if (!have.has(t)) {
                    // no incluir TEAM LINEAS aquí (va aparte)
                    out.push({ name: t.charAt(0).toUpperCase()+t.slice(1), ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });
                  }
                }
                return out;
              } catch(_) { return arr; }
            };
            fallbackTeamData = ensureRows(fallbackTeamData);
            teamData = ensureRows(teamData);
          } catch(e) { console.warn('[ESTADISTICAS] Weekend visibility filter error:', e); }
        })();

        // Calcular totales preliminares (serán recalculados tras el orden final)
        let totals = teamData.reduce((acc, r) => ({
          ICON: acc.ICON + (r.ICON || 0),
          BAMO: acc.BAMO + (r.BAMO || 0),
          Total: acc.Total + (r.Total || 0),
          Puntaje: acc.Puntaje + parseFloat(r.Puntaje || 0)
        }), { ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });

        // Orden fijo MES: siempre mostrar todos los equipos en ORDER_ALL
        (function applyFinalOrdering(){
          try {
            const norm = (s)=>String(s||'').normalize('NFD').replace(/\p{Diacritic}+/gu,'').trim().toLowerCase();
            const teamCanon = (name)=>{
              const n = norm(name).replace(/^team\s+/, '');
              if (n.includes('pleitez')) return 'Pleitez';
              if (n.includes('roberto')) return 'Roberto';
              if (n.includes('marisol')) return 'Marisol';
              if (n.includes('johana') || n.includes('johanna')) return 'Johana';
              if (n.includes('irania')) return 'Irania';
              return name || 'Sin equipo';
            };
            const ORDER_ALL = ['Pleitez','Roberto','Marisol','Johana','Irania'];
            const ORDER_A = ['Johana','Irania'];
            const ORDER_B = ['Pleitez','Roberto','Marisol'];
            let order = ORDER_ALL;
            const canonRows = (fallbackTeamData||[]).map(t=>({ ...t, name: teamCanon(t?.name) }));
            const map = new Map(canonRows.map(t=>[norm(t?.name), t]));
            const ensureRow = (name)=> map.get(norm(name)) || { name, ICON:0, BAMO:0, Total:0, Puntaje:0 };
            const ordered = order.map(ensureRow);
            const displayRows = ordered;
            fallbackTeamData = displayRows;
            // mantener teamData en sincronía para totales
            teamData = displayRows.slice();
            // recalcular totales definitivos con displayRows
            totals = (displayRows||[]).reduce((acc, r) => ({
              ICON: acc.ICON + (r.ICON || 0),
              BAMO: acc.BAMO + (r.BAMO || 0),
              Total: acc.Total + (r.Total || 0),
              Puntaje: acc.Puntaje + parseFloat(r.Puntaje || 0)
            }), { ICON: 0, BAMO: 0, Total: 0, Puntaje: 0 });
            try { window.__statsDisplayRows = displayRows.slice(); } catch(_) {}
          } catch(e) { console.warn('[ESTADISTICAS] Final ordering error:', e); }
        })();

        // Encabezado: siempre mostrar MES (mm/yyyy) para esta tabla (izquierda)
        const hoy = new Date();
        const mesTexto = `${String(hoy.getMonth()+1).padStart(2,'0')}/${hoy.getFullYear()}`;
        const encabezadoTitulo = `VENTAS POR MERCADO Y PUNTAJE DEL MES (${mesTexto})`;

        // Generar HTML de la tabla de equipos
        let html = `
          <div class="conversion-card">
            <div class="conversion-title">${encabezadoTitulo}</div>
            <div style="display:flex; justify-content:flex-end; margin:8px 0 6px;">
              <button id="btn-detalle-mensual" class="filter-button" style="height:28px;">Ver detalle</button>
            </div>
            <div class="conv-two-col">
              <div class="conv-left">
                <table class="sales-table">
                  <thead>
                    <tr>
                      <th>EQUIPO</th>
                      <th>ICON</th>
                      <th>BAMO</th>
                      <th>TOTAL</th>
                      <th>PUNTAJE</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${(!fallbackTeamData || fallbackTeamData.length === 0) ? `
                      <tr>
                        <td colspan="5" style="text-align: center; padding: 20px; color: #666; font-style: italic;">
                          No hay datos disponibles para la fecha seleccionada
                        </td>
                      </tr>
                    ` : (fallbackTeamData || []).map(team => `
                      <tr>
                        <td>${team.name}</td>
                        <td>${team.ICON || 0}</td>
                        <td>${team.BAMO || 0}</td>
                        <td>${team.Total || 0}</td>
                        <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                      </tr>
                    `).join('')}
                    ${ (fallbackTeamData && fallbackTeamData.length > 0) ? `
                      <tr class="total-row">
                        <td>TOTAL</td>
                        <td>${totals.ICON}</td>
                        <td>${totals.BAMO}</td>
                        <td>${totals.Total}</td>
                        <td>${Number(totals.Puntaje).toFixed(2)}</td>
                      </tr>
                    ` : ''}
                  </tbody>
                </table>
              </div>
              <div class="conv-right">
                <div class="mini-card">
                  <table class="mini-table">
                    <thead>
                      <tr>
                        <th>TEAM LINEAS</th>
                        <th>ICON</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${lineasData.map(r => `
                        <tr>
                          <td>${r.name}</td>
                          <td>${r.ICON || 0}</td>
                        </tr>
                      `).join('')}
                      <tr class="total">
                        <td>TOTAL</td>
                        <td class="total-icon">${lineasTotalICON}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        `;
        
        // Asignar el HTML generado al elemento raíz
        root.innerHTML = html;
        try {
          const btn = document.getElementById('btn-detalle-mensual');
          if (btn) {
            // Control de roles: solo Supervisores, Admin y Backoffice
            const user = JSON.parse(sessionStorage.getItem('user') || localStorage.getItem('user') || 'null');
            const role = (user?.role || '').toString().trim().toLowerCase();
            const allowed = new Set(['admin','administrador','supervisor','backoffice','back office','b.o','bo']);
            if (!allowed.has(role)) {
              btn.style.display = 'none';
            } else {
              btn.addEventListener('click', () => { try { showMonthDetailModal(); } catch(e){ console.error(e); } });
            }
          }
        } catch(_) {}

        // Ahora, renderizar el gráfico de dona con los datos de los equipos
        renderVentasPorEquipoChart(fallbackTeamData);
        
        // Filtro eliminado: no se requiere manejar eventos de filtrado
      } catch (e) {
        console.error('Error renderizando tabla de conversiÃ³n', e);
        console.log('Usando datos de prueba para la tabla de conversiÃ³n...');
        
        // Datos de prueba cuando falla la API
        const hoy = new Date();
        const fecha = hoy.toLocaleDateString('es-ES', { day:'2-digit', month:'2-digit', year:'numeric' });
        const fallbackTeamData = [
          { name: 'TEAM IRANIA', ICON: 8, BAMO: 7, Total: 15, Puntaje: '8.5' },
          { name: 'TEAM ROBERTO VELASQUEZ', ICON: 12, BAMO: 11, Total: 23, Puntaje: '9.2' },
          { name: 'TEAM BRYAN PLEITEZ', ICON: 9, BAMO: 9, Total: 18, Puntaje: '7.8' },
          { name: 'TEAM MARISOL BELTRAN', ICON: 6, BAMO: 6, Total: 12, Puntaje: '7.1' },
          { name: 'TEAM RANDAL MARTINEZ', ICON: 11, BAMO: 9, Total: 20, Puntaje: '8.9' },
          { name: 'TEAM LINEA', ICON: 4, BAMO: 4, Total: 8, Puntaje: '6.5' }
        ];

        // Generar HTML de la tabla con datos de prueba
        let html = `
          <div class="conversion-card">
            <div class="conversion-title">VENTAS POR MERCADO Y PUNTAJE DEL MES</div>
            <div class="conv-two-col">
              <div class="conv-left">
                <table class="sales-table">
                  <thead>
                    <tr>
                      <th>EQUIPO</th>
                      <th>ICON</th>
                      <th>BAMO</th>
                      <th>TOTAL</th>
                      <th>PUNTAJE</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${fallbackTeamData.length === 0 ? `
                      <tr>
                        <td colspan="5" style="text-align: center; padding: 20px; color: #666; font-style: italic;">
                          No hay datos disponibles para la fecha seleccionada
                        </td>
                      </tr>
                    ` : fallbackTeamData.map(team => `
                      <tr>
                        <td>${team.name}</td>
                        <td>${team.ICON || 0}</td>
                        <td>${team.BAMO || 0}</td>
                        <td>${team.Total || 0}</td>
                        <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                      </tr>
                    `).join('')}
                    ${fallbackTeamData.length > 0 ? `
                      <tr class="total-row">
                        <td>TOTAL</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(2)}</td>
                      </tr>
                    ` : ''}
                  </tbody>
                </table>
              </div>
              ${true ? `
              <div class="conv-right">
                <div class="mini-card">
                  <table class="mini-table">
                    <thead>
                      <tr>
                        <th>TEAM LINEAS</th>
                        <th>ICON</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${lineasData.map(r => `
                        <tr>
                          <td>${r.name}</td>
                          <td>${r.ICON || 0}</td>
                        </tr>
                      `).join('')}
                      <tr class="total">
                        <td>TOTAL</td>
                        <td class="total-icon">${lineasTotalICON}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              ` : ''}
            </div>DÃA (${fecha})</div>
            <div class="alert alert-warning mb-3" style="padding: 10px; margin-bottom: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; color: #856404; font-size: 0.9rem;">
              <i class="fas fa-exclamation-triangle me-2"></i>
              Mostrando datos de prueba (Error de conexiÃ³n con la base de datos)
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; grid-column: 1 / -1; width: 100%; margin: 0; padding: 0;">
              <div class="card">
                <h3></h3>
                <div id="conversion-table" class="conversion-grid">
                  <table class="sales-table">
                    <thead>
                      <tr>
                        <th>EQUIPO</th>
                        <th>ICON</th>
                        <th>BAMO</th>
                        <th>TOTAL</th>
                        <th>PUNTAJE</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${fallbackTeamData.map(team => `
                        <tr>
                          <td>${team.name}</td>
                          <td>${team.ICON || 0}</td>
                          <td>${team.BAMO || 0}</td>
                          <td>${team.Total || 0}</td>
                          <td class="score-col">${team.Puntaje || '0.0'}</td>
                        </tr>
                      `).join('')}
                      <tr class="total-row">
                        <td>TOTAL</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                        <td>${fallbackTeamData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(1)}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        `;
        
        // Asignar el HTML generado al elemento raÃ­z
        root.innerHTML = html;
        
        // Agregar evento al botÃ³n de filtrar
        const btnFiltrar = document.getElementById('btnFiltrarEquipos');
        if (btnFiltrar) {
          btnFiltrar.addEventListener('click', () => {
            renderConversionTable(root);
          });
        }
      }
    }

    // Variable para mantener la referencia al grÃ¡fico
    let ventasChart = null;
    
    // Función para verificar autenticación
    function checkAuth() {
      // Verificar si hay un usuario en sessionStorage o localStorage
      const user = JSON.parse(sessionStorage.getItem('user') || localStorage.getItem('user') || 'null');
      if (!user) {
        console.error('No se encontró sesión de usuario activa');
        window.location.href = '/login.html';
        return false;
      }
      // Acceso permitido para todos los usuarios autenticados
      console.log('Usuario autenticado con acceso a Estadísticas:', user.username || user.name);
      return true;
    }
    
    // FunciÃ³n para realizar peticiones autenticadas
    async function fetchWithAuth(url, options = {}) {
      if (!checkAuth()) return null;
      
      const defaultHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      };
      
      const response = await fetch(url, {
        ...options,
        headers: {
          ...defaultHeaders,
          ...(options.headers || {})
        },
        credentials: 'include' // Importante para enviar las cookies de autenticaciÃ³n
      });
      
      if (response.status === 401) {
        // No autorizado - redirigir al login
        console.error('Error de autenticaciÃ³n - Redirigiendo al login');
        window.location.href = '/login.html';
        return null;
      }
      
      return response;
    }
    
    function renderVentasPorEquipoChart(teamData) {
      const ctx = document.getElementById('chart-ventas-dia');
      if (!ctx) return;

      // Filtrar equipos sin ventas para no saturar el gráfico
      // Filtrar equipos para fines de semana: solo mostrar si Total > 0
      const today = new Date();
      const isWeekend = today.getDay() === 0 || today.getDay() === 6; // 0 = domingo, 6 = sábado
      const filteredDayTeams = isWeekend ? teamData.filter(team => team.Total > 0) : teamData;
      const labels = filteredDayTeams.map(t => (t.name || t._id || 'SIN EQUIPO'));
      const data = filteredDayTeams.map(t => t.Total);

      // Paleta de colores atractiva (más colores si es necesario)
      const colors = [
        '#22b3ec', '#3498db', '#5dade2', '#85c1e9', '#aed6f1',
        '#36c2cf', '#48c9b0', '#76d7c4', '#a3e4d7', '#d1f2eb',
        '#f39c12', '#e67e22', '#e74c3c', '#9b59b6', '#34495e'
      ];

      // Destruir el grÃ¡fico anterior si existe para evitar conflictos
      if (window.ventasPorEquipoChart) {
        window.ventasPorEquipoChart.destroy();
      }

      window.ventasPorEquipoChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ventas por Equipo',
            data: data,
            backgroundColor: colors.slice(0, data.length),
            borderColor: '#fff',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  let label = context.label || '';
                  if (label) {
                    label += ': ';
                  }
                  if (context.parsed !== null) {
                    label += context.parsed;
                  }
                  return label + ' ventas';
                }
              }
            }
          }
        }
      });
    }

    async function initCharts(){
      // Esta funciÃ³n se deja vacÃ­a intencionalmente para dar paso al nuevo grÃ¡fico de dona.
      console.log('initCharts ya no renderiza el grÃ¡fico de barras diario.');
    }
    
    // FunciÃ³n para renderizar el grÃ¡fico de ventas diarias
    function renderVentasDiarias(container, labels, data, isFallback) {
      if (!container) return;
      
      const warningHtml = isFallback ? `
        <div class="alert alert-warning mb-3" style="padding: 10px; margin-bottom: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; color: #856404;">
          <i class="fas fa-exclamation-triangle me-2"></i>
          Mostrando datos de prueba (Error de conexiÃ³n con la base de datos)
        </div>
      ` : '';
      
      container.innerHTML = `
        ${warningHtml}
        <canvas id="chart-ventas-diarias"></canvas>
      `;
      
      const canvas = container.querySelector('#chart-ventas-diarias');
      if (!canvas) {
        console.error('No se pudo crear el canvas para el grÃ¡fico de ventas diarias');
        return;
      }
      
      // Destruir grÃ¡fico anterior si existe
      if (window.ventasDiariasChart) {
        window.ventasDiariasChart.destroy();
      }
      
      // ConfiguraciÃ³n del grÃ¡fico
      const config = {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ventas',
            data: data,
            backgroundColor: 'rgba(34, 179, 236, 0.8)',
            borderColor: 'rgba(26, 144, 193, 1)',
            borderWidth: 1,
            borderRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Ventas: ${context.raw}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'NÃºmero de ventas',
                font: {
                  weight: 'bold'
                }
              },
              ticks: {
                stepSize: 1,
                precision: 0
              }
            },
            x: {
              title: {
                display: true,
                text: 'Fechas',
                font: {
                  weight: 'bold'
                }
              }
            }
          }
        }
      };
      
      // Crear el grÃ¡fico
      window.ventasDiariasChart = new Chart(canvas, config);
    }
    

    // FunciÃ³n auxiliar para renderizar el grÃ¡fico
    function renderChart(container, labels, data, isFallback) {
      if (!container) return;
      
      const warningHtml = isFallback ? `
        <div class="alert alert-warning mb-3" style="padding: 10px; margin-bottom: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; color: #856404;">
          <i class="fas fa-exclamation-triangle me-2"></i>
          Mostrando datos de prueba (Error de conexiÃ³n con la base de datos)
        </div>
      ` : '';
      
      container.innerHTML = `
        ${warningHtml}
        <canvas id="chart-ventas-canvas"></canvas>
      `;
      
      const canvas = container.querySelector('#chart-ventas-canvas');
      if (!canvas) {
        console.error('No se pudo crear el canvas');
        return;
      }
      
      // Destruir grÃ¡fico anterior si existe
      if (window.ventasChart) {
        window.ventasChart.destroy();
      }
      
      // Crear nuevo grÃ¡fico
      const chartConfig = {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ventas',
            backgroundColor: '#22b3ec',
            borderColor: '#1a90c1',
            borderWidth: 1,
            borderRadius: 6,
            data: data
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Ventas: ${context.raw}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'NÃºmero de ventas',
                font: { weight: 'bold' }
              }
            },
            x: {
              title: {
                display: true,
                text: 'Equipos',
                font: { weight: 'bold' }
              },
              ticks: {
                autoSkip: false,
                maxRotation: 45,
                minRotation: 45
              }
            }
          }
        }
      };
      
      try {
        window.ventasChart = new Chart(canvas, chartConfig);
        console.log('GrÃ¡fico creado exitosamente');
      } catch (error) {
        console.error('Error al crear el grÃ¡fico:', error);
        container.innerHTML = `
          <div class="alert alert-danger">
            <i class="fas fa-exclamation-triangle me-2"></i>
            Error al crear el grÃ¡fico: ${error.message}
          </div>
        `;
      }

      // Renderizar tabla de ConversiÃ³n por equipo
      console.log('Buscando elemento con ID conversion-table...');
      const convRoot = document.getElementById('conversion-table');
      console.log('Elemento encontrado:', convRoot);
      if (convRoot) {
        console.log('Elemento conversion-table encontrado, procediendo a renderizar...');
        // Establecer fechas por defecto (Ãºltimos 30 dÃ­as)
        const fechaFin = new Date();
        const fechaInicio = new Date();
        fechaInicio.setDate(fechaInicio.getDate() - 30);
        
        // Formatear fechas para los inputs
        const fechaInicioInput = document.getElementById('fechaInicio');
        const fechaFinInput = document.getElementById('fechaFin');
        
        if (fechaInicioInput) fechaInicioInput.valueAsDate = fechaInicio;
        if (fechaFinInput) fechaFinInput.valueAsDate = fechaFin;
        
        // Cargar datos
        renderConversionTable(convRoot);
      }

      const rendCtx = document.getElementById('chart-rendimiento-mes');
      if (rendCtx) {
        new Chart(rendCtx, {
          type: 'line',
          data: {
            labels: ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'],
            datasets: [{
              label: 'Puntos',
              data: Array.from({length: 12}, () => rand(10, 40)),
              borderColor: '#10b981',
              backgroundColor: 'rgba(16,185,129,0.12)',
              fill: true,
              tension: 0.35
            }]
          },
          options: { responsive: true, maintainAspectRatio: false }
        });
      }
    }

    function initializeApp() {
      console.log('Inicializando aplicación...');
      
      // Verificar que Chart esté disponible
      if (typeof Chart === 'undefined') {
        console.error('Error: Chart.js no se ha cargado correctamente');
        const chartContainer = document.querySelector('.chart-wrapper');
        if (chartContainer) {
          chartContainer.innerHTML = `
            <div class="alert alert-danger">
              <i class="fas fa-exclamation-triangle me-2"></i>
              Error: No se pudo cargar la biblioteca de gráficos. Por favor, recarga la página.
            </div>
          `;
        }
        return;
      }
      
      console.log('Chart.js cargado correctamente:', Chart.version);
      
      // Inicializar gráficos
      initCharts();
      
      // Configurar botón de actualización
      const btn = document.getElementById('btn-refresh');
      if (btn) {
        btn.addEventListener('click', () => {
          console.log('Actualizando gráficos...');
          initCharts();
        });
      }

      // Inicializar tabla de conversión después de que el DOM esté listo
      setTimeout(() => {
        initConversionTable();
        loadDayData();
        try { prepareMonthDetails(); } catch(_){ }
        // Inyectar el botón dentro del contenedor mensual cuando esté renderizado
        try { injectMonthlyDetailButton(); } catch(_){}
      }, 200); // Delay para asegurar que el DOM esté listo
    }

    // ====== MODAL DETALLE DÍA ======
    // Estilos básicos del modal (inline para no depender de CSS externo)
    (function ensureModalStyles(){
      const css = `
      .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
      .modal{background:#fff;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.2);max-width:960px;width:92%;max-height:80vh;overflow:auto}
      .modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e2e8f0;font-weight:800}
      .close-btn{border:none;background:#e11d48;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
      .table-compact{width:100%;border-collapse:collapse;font-size:.9rem}
      .table-compact th,.table-compact td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left}
      .table-compact th{background:#1f3b63;color:#fff}
      .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
      `;
      const s = document.createElement('style'); s.textContent = css; document.head.appendChild(s);
    })();

    // Contenedor del modal
    (function ensureModalContainer(){
      let overlay = document.getElementById('day-detail-modal');
      if (!overlay){
        overlay = document.createElement('div');
        overlay.id = 'day-detail-modal';
        overlay.className = 'modal-overlay';
        overlay.innerHTML = `
          <div class="modal" role="dialog" aria-modal="true" aria-labelledby="dayDetailTitle">
            <div class="modal-header">
              <div id="dayDetailTitle">Detalle de Ventas del Día</div>
              <button class="close-btn" id="day-detail-close">Cerrar</button>
            </div>
            <div class="modal-body">
              <div class="toolbar">
                <label for="filter-team-select" style="font-weight:600">Equipo:</label>
                <select id="filter-team-select"></select>
                <span id="day-detail-subtitle" style="margin-left:auto;color:#475569"></span>
              </div>
              <div style="overflow:auto">
                <table class="table-compact" id="day-detail-table">
                  <thead>
                    <tr>
                      <th>Equipo</th>
                      <th>Agente</th>
                      <th>Servicio</th>
                      <th>Mercado</th>
                      <th>Puntaje</th>
                      <th>Fecha</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
          </div>`;
        document.body.appendChild(overlay);
      }
      // Conectar listeners (siempre)
      overlay.addEventListener('click', (e)=>{ if(e.target===overlay) hideDayDetailModal(); });
      const closeBtn = document.getElementById('day-detail-close');
      if (closeBtn) closeBtn.onclick = hideDayDetailModal;
      // Cerrar con ESC
      document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideDayDetailModal(); });
    })();

    function hideDayDetailModal(){
      const el = document.getElementById('day-detail-modal');
      if (el) el.style.display = 'none';
    }

    function showDayDetailModal(){
      try{
        const store = window.DayDetailRows || { fecha:'', rows:[] };
        const rows = Array.isArray(store.rows) ? store.rows : [];
        const overlay = document.getElementById('day-detail-modal');
        if (!overlay) return;
        const tbody = overlay.querySelector('#day-detail-table tbody');
        const sel = overlay.querySelector('#filter-team-select');
        const subtitle = overlay.querySelector('#day-detail-subtitle');

        subtitle.textContent = `Fecha: ${store.fecha}`;

        // Poblar select de equipos
        const teams = Array.from(new Set(rows.map(r => (r.team||'').toString().trim()).filter(Boolean))).sort();
        sel.innerHTML = `<option value="">Todos</option>` + teams.map(t=>`<option value="${t}">${t}</option>`).join('');

        function render(filterTeam){
          const data = rows.filter(r => !filterTeam || String(r.team).trim() === filterTeam);
          tbody.innerHTML = data.map(r => `
            <tr>
              <td>${r.team || ''}</td>
              <td>${r.agente || ''}</td>
              <td>${r.servicio || ''}</td>
              <td>${r.mercado || ''}</td>
              <td>${Number(r.puntaje||0).toFixed(2)}</td>
              <td>${typeof r.fecha==='string' ? r.fecha : (r.fecha instanceof Date ? r.fecha.toISOString() : (r.fecha||''))}</td>
            </tr>
          `).join('');
        }

        render('');
        sel.onchange = () => render(sel.value);

        overlay.style.display = 'flex';
      } catch(e){ console.error('Error abriendo detalle del día', e); }
    }

    // ====== DETALLE MENSUAL ======

    (function ensureMonthModal(){
      if (!document.getElementById('month-detail-modal')){
        const overlay = document.createElement('div');
        overlay.id = 'month-detail-modal';
        overlay.className = 'modal-overlay';
        overlay.innerHTML = `
          <div class="modal" role="dialog" aria-modal="true" aria-labelledby="monthDetailTitle">
            <div class="modal-header">
              <div id="monthDetailTitle">Detalle Mensual</div>
              <button class="close-btn" id="month-detail-close">Cerrar</button>
            </div>
            <div class="modal-body">
              <div class="toolbar">
                <label for="month-filter-team" style="font-weight:600">Equipo:</label>
                <select id="month-filter-team" style="min-width:200px"></select>
                <label for="month-filter-agent" style="font-weight:600; margin-left:8px;">Agente:</label>
                <select id="month-filter-agent" style="min-width:220px"></select>
                <span id="month-detail-subtitle" style="margin-left:auto;color:#475569"></span>
              </div>
              <div style="overflow:auto">
                <table class="table-compact" id="month-detail-table">
                  <thead>
                    <tr>
                      <th>Equipo</th>
                      <th>Agente</th>
                      <th>Servicio</th>
                      <th>Mercado</th>
                      <th>Puntaje</th>
                      <th>Fecha</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
          </div>`;
        document.body.appendChild(overlay);
        overlay.addEventListener('click', (e)=>{ if(e.target===overlay) hideMonthDetailModal(); });
        document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideMonthDetailModal(); });
        const closeBtn = overlay.querySelector('#month-detail-close');
        if (closeBtn) closeBtn.addEventListener('click', hideMonthDetailModal);
      }
    })();

    async function prepareMonthDetails(){
      try{
        const hoy = new Date();
        const start = new Date(hoy.getFullYear(), hoy.getMonth(), 1, 0, 0, 0, 0);
        const end = new Date(hoy.getFullYear(), hoy.getMonth()+1, 1, 0, 0, 0, 0);
        // Intentar SIEMPRE el agregado del DÍA con forceAll=1 (todos los equipos)
        let leads = [];
        let usedEquiposAggreg = false;
        try {
          let u = `/api/equipos/estadisticas?${qs}&forceAll=1`;
          const resp = await fetchWithAuth(u);
          if (resp && resp.ok) {
            const dj = await resp.json();
            if (dj && dj.success && Array.isArray(dj.data) && dj.data.length) {
              dayData = dj.data.map(equipo => ({
                name: equipo.TEAM || equipo.team || 'Sin equipo',
                ICON: parseFloat(equipo.ICON || 0),
                BAMO: parseFloat(equipo.BAMO || 0),
                Total: parseFloat(equipo.Total || 0),
                Puntaje: parseFloat(equipo.Puntaje || 0)
              }));
              usedEquiposAggreg = true;
            }
          }
        } catch(_){ /* ignorar y caer al fallback por leads */ }
        if (!usedEquiposAggreg) {
          // Construir desde /api/leads con ventana [00:00, +1 día 09:30]
          const leadsResp = await fetchWithAuth('/api/leads');
          if (!leadsResp) return;
          const leadsJson = await leadsResp.json();
          leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
        }
        const getByPath = (obj, path) => { try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch(_) { return undefined; } };
        const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
        const tryDateFrom = (val) => { if (!val) return null; if (typeof val === 'string') { const s = val.trim(); if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [yy,mm,dd] = s.split('-').map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) { const [dd,mm,yy] = s.split(/[\/\-]/).map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } } const dt = new Date(val); return isNaN(dt) ? null : dt; };
        const createdPaths = ['dia_venta','diaVenta','fecha_contratacion','creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha'];
        const normalizeServicio = (lead) => {
          const raw = findFirst(lead, ['servicios_texto','servicios','producto','servicio','tipoProducto','producto.nombre','tipo_servicio']);
          if (Array.isArray(raw)) return raw.map(s=>String(s).trim()).filter(Boolean).join(', ');
          return (raw ? String(raw) : '').trim();
        };
        const normalizeAgente = (lead) => {
          const raw = findFirst(lead, ['agenteNombre','agente','createdBy','registeredBy','usuario','vendedor']);
          const val = (raw ? String(raw) : '').trim();
          return agentCanonical(val);
        };
        const inMonth = leads.filter(l => { const v = findFirst(l, createdPaths); const dt = tryDateFrom(v); return dt && dt >= start && dt < end; });
        const rows = inMonth.map(l => ({
          team: (findFirst(l, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team'])||'').toString().trim(),
          agente: normalizeAgente(l),
          servicio: normalizeServicio(l),
          mercado: (findFirst(l, ['mercado','market','producto','servicio','tipoProducto','producto.nombre'])||'').toString().toUpperCase(),
          puntaje: Number((() => { const p = findFirst(l, ['puntaje','score','puntos']); return typeof p==='number'?p:parseFloat(p)||0; })()),
          fecha: findFirst(l, createdPaths)
        }));
        window.MonthDetailRows = {
          rango: `${String(start.getDate()).padStart(2,'0')}/${String(start.getMonth()+1).padStart(2,'0')}/${start.getFullYear()} - ${String(new Date(end-1).getDate()).padStart(2,'0')}/${String(start.getMonth()+1).padStart(2,'0')}/${start.getFullYear()}`,
          rows
        };
      } catch(e){ console.error('Error preparando detalle mensual', e); }
    }

    function hideMonthDetailModal(){ const el = document.getElementById('month-detail-modal'); if (el) el.style.display = 'none'; }
    function normStr(s){
      return (s||'').toString().normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().replace(/\s+/g,'').replace(/\./g,'');
    }
    function agentCanonical(name){
      const n = normStr(name);
      const aliases = {
        // Eduardo Rivas
        'eduardor': 'Eduardo Rivas',
        'eduardorivas': 'Eduardo Rivas',
        'eduardor.': 'Eduardo Rivas',
        'eduardorrivas': 'Eduardo Rivas'
      };
      return aliases[n] || (name || '');
    }

    function showMonthDetailModal(){
      try{
        const store = window.MonthDetailRows || { rango:'', rows:[] };
        const rows = Array.isArray(store.rows) ? store.rows : [];
        const overlay = document.getElementById('month-detail-modal'); if (!overlay) return;
        const tbody = overlay.querySelector('#month-detail-table tbody');
        const selTeam = overlay.querySelector('#month-filter-team');
        const selAgent = overlay.querySelector('#month-filter-agent');
        const subtitle = overlay.querySelector('#month-detail-subtitle');
        subtitle.textContent = `Rango: ${store.rango}`;
        const teams = Array.from(new Set(rows.map(r => (r.team||'').toString().trim()).filter(Boolean))).sort();
        selTeam.innerHTML = `<option value="">Todos</option>` + teams.map(t=>`<option value="${t}">${t}</option>`).join('');
        function refreshAgents(){
          const team = selTeam.value;
          const agents = Array.from(new Set(rows
            .filter(r => !team || r.team === team)
            .map(r => (r.agente||'').toString().trim())
            .filter(Boolean)))
            .sort();
          selAgent.innerHTML = `<option value="">Todos</option>` + agents.map(a=>`<option value="${a}">${a}</option>`).join('');
        }
        function render(){
          const team = selTeam.value; const agent = selAgent.value;
          const agentNorm = normStr(agent);
          const data = rows.filter(r => {
            const okTeam = (!team || r.team === team);
            if (!okTeam) return false;
            if (!agent) return true;
            return normStr(r.agente) === agentNorm;
          });
          tbody.innerHTML = data.map(r => `
            <tr>
              <td>${r.team || ''}</td>
              <td>${r.agente || ''}</td>
              <td>${r.servicio || ''}</td>
              <td>${r.mercado || ''}</td>
              <td>${Number(r.puntaje||0).toFixed(2)}</td>
              <td>${typeof r.fecha==='string' ? r.fecha : (r.fecha instanceof Date ? r.fecha.toISOString() : (r.fecha||''))}</td>
            </tr>
          `).join('');
        }
        refreshAgents();
        render();
        selTeam.onchange = () => { refreshAgents(); render(); };
        selAgent.onchange = () => { render(); };
        overlay.style.display = 'flex';
      } catch(e){ console.error('Error abriendo detalle mensual', e); }
    }

    // Inserta el botón dentro de la tarjeta mensual cuando exista en el DOM
    function injectMonthlyDetailButton(attempt = 0){
      const root = document.getElementById('conversion-table');
      const card = root ? root.querySelector('.conversion-card') : null;
      if (!card) {
        if (attempt < 20) return setTimeout(() => injectMonthlyDetailButton(attempt + 1), 300);
        return;
      }
      if (card.querySelector('#btn-detalle-mensual')) return;
      const toolbar = document.createElement('div');
      toolbar.style.cssText = 'display:flex; justify-content:flex-end; margin:8px 0 6px;';
      const btn = document.createElement('button');
      btn.id = 'btn-detalle-mensual';
      btn.className = 'filter-button';
      btn.style.height = '28px';
      btn.textContent = 'Ver detalle mensual';
      btn.addEventListener('click', () => { try { showMonthDetailModal(); } catch(e){ console.error(e); } });
      toolbar.appendChild(btn);
      const convTwoCol = card.querySelector('.conv-two-col');
      if (convTwoCol) card.insertBefore(toolbar, convTwoCol); else card.appendChild(toolbar);
    }

    // FunciÃ³n para inicializar la tabla de conversiÃ³n
    function initConversionTable() {
      console.log('Inicializando tabla de conversiÃ³n...');
      const convRoot = document.getElementById('conversion-table');
      if (convRoot) {
        console.log('Elemento conversion-table encontrado, renderizando...');
        renderConversionTable(document.getElementById('conversion-table'));
      } else {
        console.error('No se encontrÃ³ el elemento con ID conversion-table');
      }
    }

    // Función para cargar y renderizar la tabla del Día con el mismo diseño que la del Mes
    async function loadDayData() {
      console.log('Cargando datos del día actual...');
      const container = document.getElementById('ventas-dia-card');
      if (!container) {
        console.error('No se encontró el contenedor #ventas-dia-card');
        return;
      }

      // Día efectivo con corte 09:30 local
      const nowLocal = new Date();
      const cutoffHour = 9, cutoffMinute = 30;
      const beforeCutoff = (nowLocal.getHours() < cutoffHour) || (nowLocal.getHours() === cutoffHour && nowLocal.getMinutes() < cutoffMinute);
      const effective = new Date(nowLocal);
      if (beforeCutoff) effective.setDate(effective.getDate() - 1);
      const diaTexto = `${String(effective.getDate()).padStart(2,'0')}/${String(effective.getMonth()+1).padStart(2,'0')}/${effective.getFullYear()}`;

      // Placeholder de carga
      container.innerHTML = `
        <div class="text-center" style="padding: 12px; color:#666;">Cargando datos del día...</div>
      `;

      try {
        // 1) Construir SIEMPRE desde /api/leads (global, sin filtrar por agente)
        const y = effective.getFullYear();
        const m = String(effective.getMonth()+1).padStart(2,'0');
        const d = String(effective.getDate()).padStart(2,'0');
        const qs = `fechaInicio=${y}-${m}-${d}&fechaFin=${y}-${m}-${d}&scope=day`;
        let dayData = [];
        const startLocal = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate(), 0, 0, 0, 0);
        const endExclusive = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate() + 1, cutoffHour, cutoffMinute, 0, 0);
        const leadsResp = await fetchWithAuth('/api/leads');
        if (!leadsResp) return;
        const leadsJson = await leadsResp.json();
        const leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
        const getByPath = (obj, path) => { try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch (_) { return undefined; } };
        const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
        const tryDateFrom = (val) => { if (!val) return null; if (typeof val === 'string') { const s = val.trim(); if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [yy,mm,dd] = s.split('-').map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) { const [dd,mm,yy] = s.split(/[\/\-]/).map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } } const dt = new Date(val); return isNaN(dt) ? null : dt; };
        const createdPaths = ['dia_venta','diaVenta','fecha_contratacion','creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha'];
        const inDay = leads.filter(l => { const v = findFirst(l, createdPaths); const dt = tryDateFrom(v); return dt && dt >= startLocal && dt < endExclusive; });
        // Construir filas de detalle (agente, servicio, etc.) y exponerlas globalmente
        const normalizeServicio = (lead) => {
          const raw = findFirst(lead, ['servicios_texto','servicios','producto','servicio','tipoProducto','producto.nombre']);
          if (Array.isArray(raw)) return raw.map(s=>String(s).trim()).filter(Boolean).join(', ');
          return (raw ? String(raw) : '').trim();
        };
        const normalizeAgente = (lead) => {
          const raw = findFirst(lead, ['agenteNombre','agente','createdBy','registeredBy','usuario','vendedor']);
          return (raw ? String(raw) : '').trim();
        };
        const detailRows = inDay.map(l => {
          const team = (findFirst(l, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']) || '').toString().trim();
          const servicio = normalizeServicio(l);
          const mercado = (findFirst(l, ['mercado','market','producto','servicio','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
          const pRaw = findFirst(l, ['puntaje','score','puntos']);
          const puntaje = typeof pRaw === 'number' ? pRaw : parseFloat(pRaw) || 0;
          const agente = normalizeAgente(l);
          const fechaFuente = findFirst(l, createdPaths);
          return { team, agente, servicio, mercado, puntaje: Number(puntaje || 0), fecha: fechaFuente };
        });
        window.DayDetailRows = { fecha: `${String(effective.getDate()).padStart(2,'0')}/${String(effective.getMonth()+1).padStart(2,'0')}/${effective.getFullYear()}`, rows: detailRows };

        // Intentar agregado del día desde backend (global)
        let preTeamData = null;
        try {
          const aggResp = await fetchWithAuth(`/api/equipos/estadisticas?${qs}&scope=day&forceAll=1`);
          if (aggResp && aggResp.ok) {
            const dj = await aggResp.json();
            if (dj && dj.success && Array.isArray(dj.data) && dj.data.length) {
              preTeamData = dj.data.map(equipo => ({
                name: equipo.TEAM || equipo.team || 'Sin equipo',
                ICON: parseFloat(equipo.ICON || 0),
                BAMO: parseFloat(equipo.BAMO || 0),
                Total: parseFloat(equipo.Total || 0),
                Puntaje: parseFloat(equipo.Puntaje || 0)
              }));
            }
          }
        } catch(_) {}

        const teamMap = new Map();
        const teamNameOf = (lead) => {
          const t = findFirst(lead, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']);
          const s = (t || '').toString().trim(); return s || 'Sin equipo';
        };
        const mercadoOf = (lead) => (String(findFirst(lead, ['mercado','market','producto','servicio','tipoProducto','producto.nombre'])||'').toUpperCase());
        const puntajeOf = (lead) => { const p = findFirst(lead, ['puntaje','score','puntos']); const n = typeof p === 'number' ? p : parseFloat(p); return isNaN(n) ? 0 : n; };
        if (preTeamData) {
          dayData = preTeamData;
        } else {
          inDay.forEach(l => { const name = teamNameOf(l); if (!teamMap.has(name)) teamMap.set(name, { name, ICON:0, BAMO:0, Total:0, Puntaje:0 }); const agg = teamMap.get(name); agg.Total += 1; const mk = mercadoOf(l); if (mk.includes('ICON')) agg.ICON += 1; else if (mk.includes('BAMO')) agg.BAMO += 1; agg.Puntaje += puntajeOf(l); });
          dayData = Array.from(teamMap.values());
        }

        // Separar LINEAS para panel derecho y excluirlas de la tabla principal
        const isLinea = (n) => /LINEA/i.test(String(n || ''));
        const lineasData = dayData.filter(t => isLinea(t.name)).map(r => ({ name: r.name, ICON: r.ICON || 0 }));
        const lineasTotalICON = lineasData.reduce((acc, r) => acc + (r.ICON || 0), 0);
        const excludeNames = new Set(dayData.filter(t => isLinea(t.name)).map(t => String(t.name).toUpperCase()));
        let mainData = dayData.filter(t => !excludeNames.has(String(t.name).toUpperCase()));

        // Asegurar presencia de equipos aunque no vendan (orden fijo y rotación fin de semana)
        (function ensureDayRows(){
          try {
            const norm = (s)=>String(s||'').normalize('NFD').replace(/\p{Diacritic}+/gu,'').trim().toLowerCase();
            const teamCanon = (name)=>{
              const n = norm(name).replace(/^team\s+/, '');
              if (n.includes('pleitez')) return 'Pleitez';
              if (n.includes('roberto')) return 'Roberto';
              if (n.includes('marisol')) return 'Marisol';
              if (n.includes('johana') || n.includes('johanna')) return 'Johana';
              if (n.includes('irania')) return 'Irania';
              return name || 'Sin equipo';
            };
            const ORDER_ALL = ['Pleitez','Roberto','Marisol','Johana','Irania'];
            const ORDER_A = ['Johana','Irania'];
            const ORDER_B = ['Pleitez','Roberto','Marisol'];
            // Rotación anclada al PRIMER SÁBADO DEL MES actual (alterna cada fin de semana dentro del mes)
            const today = new Date();
            const dow = today.getDay(); // 0=Dom, 6=Sáb
            const normMid = d => new Date(d.getFullYear(), d.getMonth(), d.getDate());
            const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);
            const offsetToSat = (6 - monthStart.getDay() + 7) % 7; // 0..6
            const FIRST_SAT = new Date(monthStart.getFullYear(), monthStart.getMonth(), 1 + offsetToSat);
            const startOfWeekend = (dow === 6) ? normMid(today) : (dow === 0 ? new Date(normMid(today).getTime() - 86400000) : null);
            const weekendsPassed = startOfWeekend ? Math.floor((normMid(startOfWeekend) - normMid(FIRST_SAT)) / (7 * 86400000)) : 0;
            const weekendParity = ((weekendsPassed % 2) + 2) % 2; // 0 ó 1
            let order = ORDER_ALL;
            if (dow === 6) { // Sábado
              // En fin de semana base: Sábado -> ORDER_A; siguiente fin de semana alterna
              order = weekendParity === 0 ? ORDER_A : ORDER_B;
            } else if (dow === 0) { // Domingo
              // En fin de semana base: Domingo -> ORDER_B; siguiente fin de semana alterna
              order = weekendParity === 0 ? ORDER_B : ORDER_A;
            }
            // Regla estable: los DOMINGOS siempre muestran el grupo B por defecto
            try {
              if (dow === 0) {
                order = ORDER_B;
                console.log('[ESTADISTICAS][DAY] Sunday rule: forcing ORDER_B');
              }
            } catch(_) {}
            // Override manual: ?group=A|B, localStorage('stats_force_group'), window.__forceWeekendGroup
            try {
              const params = new URLSearchParams(location.search);
              const gParam = (params.get('group')||'').toUpperCase();
              const gStore = (localStorage.getItem('stats_force_group')||'').toUpperCase();
              const gWin = (window.__forceWeekendGroup||'').toUpperCase();
              const forced = gParam || gStore || gWin;
              if (forced === 'A') order = ORDER_A; else if (forced === 'B') order = ORDER_B;
              if (forced) console.log('[ESTADISTICAS][DAY] Forced group:', forced, 'order=', order);
            } catch(_) {}
            // Debug opcional
            try { console.log('[ESTADISTICAS][DAY] weekendParity=', weekendParity, 'dow=', dow, 'order=', order); } catch(_) {}
            const canonRows = (mainData||[]).map(t=>({ ...t, name: teamCanon(t?.name) }));
            const map = new Map(canonRows.map(t=>[norm(t?.name), t]));
            const ensureRow = (name)=> map.get(norm(name)) || { name, ICON:0, BAMO:0, Total:0, Puntaje:0 };
            const ordered = order.map(ensureRow);
            mainData = ordered;
            try { window.DayDisplayRows = ordered.slice(); } catch(_) {}
          } catch(e) { console.warn('[ESTADISTICAS][DAY] ensure rows error:', e); }
        })();

        // Construir HTML con el mismo diseño (conversion-card + sales-table) incluyendo panel LINEAS a la derecha
        // Siempre renderizar filas (aunque sean 0)
        const tablaHtml = `
            <div class="conversion-card">
              <div class="conversion-title">VENTAS POR MERCADO Y PUNTAJE DEL DÍA (${diaTexto})</div>
              <div style="display:flex; justify-content:flex-end; margin:8px 0 6px;">
                <button id="btn-detalle-dia" class="filter-button" style="height:28px;">Ver detalle</button>
              </div>
              <div class="conv-two-col">
                <div class="conv-left">
                  <table class="sales-table">
                    <thead>
                      <tr>
                        <th>EQUIPO</th>
                        <th>ICON</th>
                        <th>BAMO</th>
                        <th>TOTAL</th>
                        <th>PUNTAJE</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${mainData.map(team => `
                        <tr>
                          <td>${team.name}</td>
                          <td>${team.ICON || 0}</td>
                          <td>${team.BAMO || 0}</td>
                          <td>${team.Total || 0}</td>
                          <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                        </tr>
                      `).join('')}
                      <tr class="total-row">
                        <td>TOTAL</td>
                        <td>${mainData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                        <td>${mainData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                        <td>${mainData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                        <td>${mainData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(2)}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="conv-right">
                  <div class="mini-card">
                    <table class="mini-table">
                      <thead>
                        <tr>
                          <th>TEAM LINEAS</th>
                          <th>ICON</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${(lineasData || []).map(r => `
                          <tr>
                            <td>${r.name}</td>
                            <td>${r.ICON || 0}</td>
                          </tr>
                        `).join('')}
                        <tr class="total">
                          <td>TOTAL</td>
                          <td class="total-icon">${lineasTotalICON}</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          `;

        container.innerHTML = tablaHtml;
        // Safety enforcement: on Sundays, force display order to GROUP B in the DOM
        try {
          const dowToday = (new Date()).getDay(); // 0=Sun
          if (dowToday === 0) {
            const ORDER_B = ['Pleitez','Roberto','Marisol'];
            const card = container.querySelector('.conversion-card');
            const tbody = card && card.querySelector('.sales-table tbody');
            if (tbody) {
              const totalRow = tbody.querySelector('.total-row');
              const totalHTML = totalRow ? totalRow.outerHTML : '';
              const buildRow = (name)=>`<tr><td>${name}</td><td>0</td><td>0</td><td>0</td><td class="score-col">0.00</td></tr>`;
              tbody.innerHTML = ORDER_B.map(buildRow).join('') + totalHTML;
              console.log('[ESTADISTICAS][DAY][DOM] Enforced Sunday GROUP B');
            }
            // Also set a MutationObserver to re-apply if the section re-renders later
            if (!window.__statsDayObserverB) {
              const apply = () => {
                const c = document.querySelector('#ventas-dia-card .conversion-card');
                const tb = c && c.querySelector('.sales-table tbody');
                if (!tb) return false;
                const totalRow = tb.querySelector('.total-row');
                const totalHTML = totalRow ? totalRow.outerHTML : '';
                const buildRow = (name)=>`<tr><td>${name}</td><td>0</td><td>0</td><td>0</td><td class="score-col">0.00</td></tr>`;
                tb.innerHTML = ORDER_B.map(buildRow).join('') + totalHTML;
                console.log('[ESTADISTICAS][DAY][DOM] Observer re-applied GROUP B');
                return true;
              };
              // Try now; if not, observe until it appears or timeout
              if (!apply()) {
                const mo = new MutationObserver(() => { if (apply()) { try { mo.disconnect(); } catch(_) {} window.__statsDayObserverB = null; } });
                mo.observe(document.body, { childList: true, subtree: true });
                window.__statsDayObserverB = mo;
                setTimeout(() => { try { mo.disconnect(); } catch(_) {} window.__statsDayObserverB = null; }, 15000);
              }
            }
          }
        } catch(_) {}
        // Hook botón detalle
        const btnDet = document.getElementById('btn-detalle-dia');
        if (btnDet) {
          btnDet.addEventListener('click', () => {
            try { showDayDetailModal(); } catch (e) { console.error('No se pudo abrir detalle del día', e); }
          });
        }
      } catch (e) {
        console.error('Error cargando datos del día:', e);
        container.innerHTML = `
          <div class="conversion-card">
            <div class="conversion-title">VENTAS POR MERCADO Y PUNTAJE DEL DÍA (${diaTexto})</div>
            <div class="conv-two-col">
              <div class="conv-left">
                <table class="sales-table">
                  <thead>
                    <tr>
                      <th>EQUIPO</th>
                      <th>ICON</th>
                      <th>BAMO</th>
                      <th>TOTAL</th>
                      <th>PUNTAJE</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td colspan="5" style="text-align:center; padding:16px; color:#666; font-style:italic;">Error de conexión</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        `;
      }
    }

    // ====== MODAL DETALLE DÍA ======
    // Estilos básicos del modal (inline para no depender de CSS externo)
    (function ensureModalStyles(){
      const css = `
      .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:1000}
      .modal{background:#fff;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.2);max-width:960px;width:92%;max-height:80vh;overflow:auto}
      .modal-header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e2e8f0;font-weight:800}
      .close-btn{border:none;background:#e11d48;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;font-weight:600}
      .table-compact{width:100%;border-collapse:collapse;font-size:.9rem}
      .table-compact th,.table-compact td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left}
      .table-compact th{background:#1f3b63;color:#fff}
      .toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
      `;
      const s = document.createElement('style'); s.textContent = css; document.head.appendChild(s);
    })();

    // Contenedor del modal
    (function ensureModalContainer(){
      if (!document.getElementById('day-detail-modal')){
        const overlay = document.createElement('div');
        overlay.id = 'day-detail-modal';
        overlay.className = 'modal-overlay';
        overlay.innerHTML = `
          <div class="modal" role="dialog" aria-modal="true" aria-labelledby="dayDetailTitle">
            <div class="modal-header">
              <div id="dayDetailTitle">Detalle de Ventas del Día</div>
              <button class="close-btn" id="day-detail-close">Cerrar</button>
            </div>
            <div class="modal-body">
              <div class="toolbar">
                <label for="filter-team-select" style="font-weight:600">Equipo:</label>
                <select id="filter-team-select"></select>
                <span id="day-detail-subtitle" style="margin-left:auto;color:#475569"></span>
              </div>
              <div style="overflow:auto">
                <table class="table-compact" id="day-detail-table">
                  <thead>
                    <tr>
                      <th>Equipo</th>
                      <th>Agente</th>
                      <th>Servicio</th>
                      <th>Mercado</th>
                      <th>Puntaje</th>
                      <th>Fecha</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
          </div>`;
        document.body.appendChild(overlay);
        overlay.addEventListener('click', (e)=>{ if(e.target===overlay) hideDayDetailModal(); });
        document.getElementById('day-detail-close').addEventListener('click', hideDayDetailModal);
      }
    })();

    function hideDayDetailModal(){
      const el = document.getElementById('day-detail-modal');
      if (el) el.style.display = 'none';
    }

    function showDayDetailModal(){
      try{
        const store = window.DayDetailRows || { fecha:'', rows:[] };
        const rows = Array.isArray(store.rows) ? store.rows : [];
        const overlay = document.getElementById('day-detail-modal');
        if (!overlay) return;
        const tbody = overlay.querySelector('#day-detail-table tbody');
        const sel = overlay.querySelector('#filter-team-select');
        const subtitle = overlay.querySelector('#day-detail-subtitle');

        subtitle.textContent = `Fecha: ${store.fecha}`;

        // Poblar select de equipos
        const teams = Array.from(new Set(rows.map(r => (r.team||'').toString().trim()).filter(Boolean))).sort();
        sel.innerHTML = `<option value="">Todos</option>` + teams.map(t=>`<option value="${t}">${t}</option>`).join('');

        function render(filterTeam){
          const data = rows.filter(r => !filterTeam || String(r.team).trim() === filterTeam);
          tbody.innerHTML = data.map(r => `
            <tr>
              <td>${r.team || ''}</td>
              <td>${r.agente || ''}</td>
              <td>${r.servicio || ''}</td>
              <td>${r.mercado || ''}</td>
              <td>${Number(r.puntaje||0).toFixed(2)}</td>
              <td>${typeof r.fecha==='string' ? r.fecha : (r.fecha instanceof Date ? r.fecha.toISOString() : (r.fecha||''))}</td>
            </tr>
          `).join('');
        }

        render('');
        sel.onchange = () => render(sel.value);

        overlay.style.display = 'flex';
      } catch(e){ console.error('Error abriendo detalle del día', e); }
    }

    // FunciÃ³n para inicializar la tabla de conversiÃ³n
    function initConversionTable() {
      console.log('Inicializando tabla de conversiÃ³n...');
      const convRoot = document.getElementById('conversion-table');
      if (convRoot) {
        console.log('Elemento conversion-table encontrado, renderizando...');
        renderConversionTable(document.getElementById('conversion-table'));
      } else {
        console.error('No se encontrÃ³ el elemento con ID conversion-table');
      }
    }

    // Función para cargar y renderizar la tabla del Día con el mismo diseño que la del Mes
    async function loadDayData() {
      console.log('Cargando datos del día actual...');
      const container = document.getElementById('ventas-dia-card');
      if (!container) {
        console.error('No se encontró el contenedor #ventas-dia-card');
        return;
      }

      // Día efectivo con corte 09:30 local
      const nowLocal = new Date();
      const cutoffHour = 9, cutoffMinute = 30;
      const beforeCutoff = (nowLocal.getHours() < cutoffHour) || (nowLocal.getHours() === cutoffHour && nowLocal.getMinutes() < cutoffMinute);
      const effective = new Date(nowLocal);
      if (beforeCutoff) effective.setDate(effective.getDate() - 1);
      const diaTexto = `${String(effective.getDate()).padStart(2,'0')}/${String(effective.getMonth()+1).padStart(2,'0')}/${effective.getFullYear()}`;

      // Placeholder de carga
      container.innerHTML = `
        <div class="text-center" style="padding: 12px; color:#666;">Cargando datos del día...</div>
      `;

      try {
        // 1) Intentar primero el endpoint de equipos con fecha efectiva
        const y = effective.getFullYear();
        const m = String(effective.getMonth()+1).padStart(2,'0');
        const d = String(effective.getDate()).padStart(2,'0');
        const qs = `fechaInicio=${y}-${m}-${d}&fechaFin=${y}-${m}-${d}&scope=day`;
        // Construir SIEMPRE desde /api/leads con ventana [00:00, +1 día 09:30]
        let dayData = [];
        const startLocal = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate(), 0, 0, 0, 0);
        const endExclusive = new Date(effective.getFullYear(), effective.getMonth(), effective.getDate() + 1, cutoffHour, cutoffMinute, 0, 0);
        const leadsResp = await fetchWithAuth('/api/leads');
        if (!leadsResp) return;
        const leadsJson = await leadsResp.json();
        const leads = Array.isArray(leadsJson) ? leadsJson : (Array.isArray(leadsJson.data) ? leadsJson.data : (Array.isArray(leadsJson.leads) ? leadsJson.leads : []));
        const getByPath = (obj, path) => { try { return path.split('.').reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj); } catch (_) { return undefined; } };
        const findFirst = (obj, paths) => { for (const p of paths) { const v = getByPath(obj, p); if (v !== undefined && v !== null && v !== '') return v; } return undefined; };
        const tryDateFrom = (val) => { if (!val) return null; if (typeof val === 'string') { const s = val.trim(); if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [yy,mm,dd] = s.split('-').map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) { const [dd,mm,yy] = s.split(/[\/\-]/).map(Number); return new Date(yy, mm-1, dd, 12, 0, 0); } } const dt = new Date(val); return isNaN(dt) ? null : dt; };
        const createdPaths = ['dia_venta','diaVenta','fecha_contratacion','creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha'];
        const inDay = leads.filter(l => { const v = findFirst(l, createdPaths); const dt = tryDateFrom(v); return dt && dt >= startLocal && dt < endExclusive; });
        // Construir filas de detalle (agente, servicio, etc.) y exponerlas globalmente
        const normalizeServicio = (lead) => {
          const raw = findFirst(lead, ['servicios_texto','servicios','producto','servicio','tipoProducto','producto.nombre']);
          if (Array.isArray(raw)) return raw.map(s=>String(s).trim()).filter(Boolean).join(', ');
          return (raw ? String(raw) : '').trim();
        };
        const normalizeAgente = (lead) => {
          const raw = findFirst(lead, ['agenteNombre','agente','createdBy','registeredBy','usuario','vendedor']);
          return (raw ? String(raw) : '').trim();
        };
        const detailRows = inDay.map(l => {
          const team = (findFirst(l, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']) || '').toString().trim();
          const servicio = normalizeServicio(l);
          const mercado = (findFirst(l, ['mercado','market','producto','servicio','tipoProducto','producto.nombre']) || '').toString().toUpperCase();
          const pRaw = findFirst(l, ['puntaje','score','puntos']);
          const puntaje = typeof pRaw === 'number' ? pRaw : parseFloat(pRaw) || 0;
          const agente = normalizeAgente(l);
          const fechaFuente = findFirst(l, createdPaths);
          return { team, agente, servicio, mercado, puntaje: Number(puntaje || 0), fecha: fechaFuente };
        });
        window.DayDetailRows = { fecha: `${String(effective.getDate()).padStart(2,'0')}/${String(effective.getMonth()+1).padStart(2,'0')}/${effective.getFullYear()}`, rows: detailRows };

        const teamMap = new Map();
        const teamNameOf = (lead) => {
          const t = findFirst(lead, ['supervisor','Supervisor','TEAM','team','equipo','grupo','department','team_name','Team']);
          const s = (t || '').toString().trim(); return s || 'Sin equipo';
        };
        const mercadoOf = (lead) => (String(findFirst(lead, ['mercado','market','producto','servicio','tipoProducto','producto.nombre'])||'').toUpperCase());
        const puntajeOf = (lead) => { const p = findFirst(lead, ['puntaje','score','puntos']); const n = typeof p === 'number' ? p : parseFloat(p); return isNaN(n) ? 0 : n; };
        inDay.forEach(l => { const name = teamNameOf(l); if (!teamMap.has(name)) teamMap.set(name, { name, ICON:0, BAMO:0, Total:0, Puntaje:0 }); const agg = teamMap.get(name); agg.Total += 1; const mk = mercadoOf(l); if (mk.includes('ICON')) agg.ICON += 1; else if (mk.includes('BAMO')) agg.BAMO += 1; agg.Puntaje += puntajeOf(l); });
        dayData = Array.from(teamMap.values());

        // Separar LINEAS para panel derecho y excluirlas de la tabla principal
        const isLinea = (n) => /LINEA/i.test(String(n || ''));
        const lineasData = dayData.filter(t => isLinea(t.name)).map(r => ({ name: r.name, ICON: r.ICON || 0 }));
        const lineasTotalICON = lineasData.reduce((acc, r) => acc + (r.ICON || 0), 0);
        const excludeNames = new Set(dayData.filter(t => isLinea(t.name)).map(t => String(t.name).toUpperCase()));
        let mainData = dayData.filter(t => !excludeNames.has(String(t.name).toUpperCase()));

        // Completar equipos y fijar orden (L–V: todos; FDS: grupo rotativo)
        (function ensureDayRows(){
          try {
            const norm = (s)=>String(s||'').normalize('NFD').replace(/\p{Diacritic}+/gu,'').trim().toLowerCase();
            const ORDER_ALL = ['Pleitez','Roberto','Marisol','Johana','Irania'];
            const ORDER_A = ['Johana','Irania'];
            const ORDER_B = ['Pleitez','Roberto','Marisol'];
            const dow = effective.getDay();
            let order = ORDER_ALL;
            if (dow === 6) order = ORDER_A; else if (dow === 0) order = ORDER_B;
            const map = new Map((mainData||[]).map(t=>[norm(t?.name), t]));
            const ensureRow = (name)=> map.get(norm(name)) || { name, ICON:0, BAMO:0, Total:0, Puntaje:0 };
            mainData = order.map(ensureRow);
            try { window.DayDisplayRows = mainData.slice(); } catch(_) {}
          } catch(e) { console.warn('[ESTADISTICAS][DAY-2] ensure rows error:', e); }
        })();

        // Construir HTML con el mismo diseño (conversion-card + sales-table) incluyendo panel LINEAS a la derecha
        const tablaHtml = `
            <div class="conversion-card">
              <div class="conversion-title">VENTAS POR MERCADO Y PUNTAJE DEL DÍA (${diaTexto})</div>
              <div style="display:flex; justify-content:flex-end; margin:8px 0 6px;">
                <button id="btn-detalle-dia" class="filter-button" style="height:28px;">Ver detalle</button>
              </div>
              <div class="conv-two-col">
                <div class="conv-left">
                  <table class="sales-table">
                    <thead>
                      <tr>
                        <th>EQUIPO</th>
                        <th>ICON</th>
                        <th>BAMO</th>
                        <th>TOTAL</th>
                        <th>PUNTAJE</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${mainData.map(team => `
                        <tr>
                          <td>${team.name}</td>
                          <td>${team.ICON || 0}</td>
                          <td>${team.BAMO || 0}</td>
                          <td>${team.Total || 0}</td>
                          <td class="score-col">${parseFloat(team.Puntaje || 0).toFixed(2)}</td>
                        </tr>
                      `).join('')}
                      <tr class="total-row">
                        <td>TOTAL</td>
                        <td>${mainData.reduce((sum, t) => sum + (t.ICON || 0), 0)}</td>
                        <td>${mainData.reduce((sum, t) => sum + (t.BAMO || 0), 0)}</td>
                        <td>${mainData.reduce((sum, t) => sum + (t.Total || 0), 0)}</td>
                        <td>${mainData.reduce((sum, t) => sum + parseFloat(t.Puntaje || 0), 0).toFixed(2)}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                <div class="conv-right">
                  <div class="mini-card">
                    <table class="mini-table">
                      <thead>
                        <tr>
                          <th>TEAM LINEAS</th>
                          <th>ICON</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${(lineasData || []).map(r => `
                          <tr>
                            <td>${r.name}</td>
                            <td>${r.ICON || 0}</td>
                          </tr>
                        `).join('')}
                        <tr class="total">
                          <td>TOTAL</td>
                          <td class="total-icon">${lineasTotalICON}</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          `;

        container.innerHTML = tablaHtml;
        // Hook botón detalle
        const btnDet = document.getElementById('btn-detalle-dia');
        if (btnDet) {
          btnDet.addEventListener('click', () => {
            try { showDayDetailModal(); } catch (e) { console.error('No se pudo abrir detalle del día', e); }
          });
        }
      } catch (e) {
        console.error('Error cargando datos del día:', e);
        container.innerHTML = `
          <div class="conversion-card">
            <div class="conversion-title">VENTAS POR MERCADO Y PUNTAJE DEL DÍA (${diaTexto})</div>
            <div class="conv-two-col">
              <div class="conv-left">
                <table class="sales-table">
                  <thead>
                    <tr>
                      <th>EQUIPO</th>
                      <th>ICON</th>
                      <th>BAMO</th>
                      <th>TOTAL</th>
                      <th>PUNTAJE</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td colspan="5" style="text-align:center; padding:16px; color:#666; font-style:italic;">Error de conexión</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        `;
      }
    }

    // ===== FUNCIONES DE LA GRÁFICA DE VENTAS Y PUNTAJE =====
    
    // Variables globales para la nueva gráfica
    let ventasPuntajeChart = null;
    
    // Datos de prueba para la gráfica
    const datosPrueba = [
      { fecha: '2025-08-06', ventas: 12, puntaje: 85 },
      { fecha: '2025-08-07', ventas: 8, puntaje: 70 },
      { fecha: '2025-08-08', ventas: 15, puntaje: 95 },
      { fecha: '2025-08-09', ventas: 10, puntaje: 80 },
      { fecha: '2025-08-10', ventas: 20, puntaje: 100 },
      { fecha: '2025-08-11', ventas: 14, puntaje: 88 },
      { fecha: '2025-08-12', ventas: 18, puntaje: 90 }
    ];

    // Función para inicializar la gráfica de ventas y puntaje
    function inicializarGraficaVentasPuntaje() {
      try {
        const canvas = document.getElementById('ventasPuntajeChart');
        if (!canvas) {
          console.error('No se encontró el elemento canvas para la gráfica de ventas y puntaje');
          return null;
        }
        
        if (ventasPuntajeChart) {
          console.log('Destruyendo instancia anterior del gráfico...');
          ventasPuntajeChart.destroy();
          ventasPuntajeChart = null;
        }
        
        const ctx = canvas.getContext('2d');
        const container = canvas.parentElement;
        container.style.width = '100%';
        container.style.height = '400px';
        
        return new Chart(ctx, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [
              {
                label: 'Ventas',
                type: 'bar',
                backgroundColor: 'rgba(54, 162, 235, 0.5)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                yAxisID: 'y',
                datalabels: {
                  anchor: 'end',
                  align: 'end',
                  offset: 4,
                  color: '#2c3e50',
                  font: { weight: 'bold' },
                  formatter: (v) => (v != null && !isNaN(v) && Number(v) !== 0 ? Math.round(v) : '')
                }
              },
              {
                label: 'Puntaje',
                type: 'bar',
                backgroundColor: 'rgba(255, 99, 132, 0.7)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                borderRadius: 4,
                yAxisID: 'y1',
                datalabels: {
                  anchor: 'end',
                  align: 'end',
                  offset: 4,
                  color: '#7f1d1d',
                  font: { weight: 'bold' },
                  formatter: (v) => {
                    if (v == null || isNaN(v) || Number(v) === 0) return '';
                    const n = Number(v);
                    return n.toFixed(2).replace(/\.00$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
                  }
                }
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { bottom: 40 } },
            plugins: {
              legend: {
                position: 'right'
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed !== null) {
                      label += context.parsed;
                    }
                    return label;
                  }
                }
              },
              datalabels: {
                display: false,
                formatter: () => '',
                clamp: true,
                clip: false
              }
            },
            scales: {
              y: {
                type: 'linear',
                display: true,
                position: 'left',
                title: { display: false, text: 'Ventas' },
                grid: { display: false, drawTicks: false },
                border: { display: false },
                ticks: { display: false, callback: () => '' }
              },
              y1: {
                type: 'linear',
                display: true,
                position: 'right',
                grid: { display: false, drawOnChartArea: false, drawTicks: false },
                border: { display: false },
                title: { display: false, text: 'Puntaje' },
                ticks: { display: false, callback: () => '' },
                min: 0,
                max: 100
              },
              x: {
                display: true,
                grid: { display: false },
                ticks: { display: false, callback: () => '' },
                title: { display: false, text: '' }
              }
            },
            elements: {
              point: { radius: 0, hoverRadius: 0 }
            }
          }
        });
      } catch (error) {
        console.error('Error al inicializar la gráfica de ventas y puntaje:', error);
        return null;
      }
    }

    // Función para mostrar notificaciones
    function mostrarNotificacion(mensaje, tipo = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${tipo}`;
      notification.innerHTML = `
        <i class="fas ${tipo === 'success' ? 'fa-check-circle' : 'fa-exclamation-triangle'}"></i>
        ${mensaje}
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.classList.add('show');
      }, 100);
      
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    // Función para mostrar mensajes de error
    function mostrarMensajeError(mensaje) {
      mostrarNotificacion(mensaje, 'error');
    }

    // Función para actualizar la gráfica de ventas y puntaje con datos de la API
    async function actualizarGraficaVentasPuntaje(datos = null) {
      try {
        console.log('=== INICIANDO ACTUALIZACIÓN DE GRÁFICA DE VENTAS ===');
        
        // Si se proporcionan datos directamente, úsalos y omite la llamada al backend
        if (Array.isArray(datos) && datos.length) {
          console.log('Usando datos proporcionados para la gráfica');
          return await procesarDatosGraficaEstadisticas(datos);
        }
        
        // Obtener el nombre del agente del localStorage o del DOM
        const userData = JSON.parse(localStorage.getItem('user') || sessionStorage.getItem('user') || '{}');
        const nombreAgente = userData.name || 'Usuario';
        
        // Construir la URL del endpoint de leads con filtro por agente
        let url = '/api/leads';
        try {
          const userStr = localStorage.getItem('user') || sessionStorage.getItem('user') || '{}';
          const user = JSON.parse(userStr);
          const roleLower = ((user && user.role) || '').toString().toLowerCase();
          const agenteNombreQuery = (user && (user.username || user.name)) || nombreAgente || '';
          const u = new URL(url, location.origin);
          const params = new URLSearchParams(u.search);
          // Solo los agentes se filtran por su propio nombre; roles privilegiados ven todo
          if (roleLower === 'agent' && agenteNombreQuery) {
            params.set('agente', agenteNombreQuery);
            console.info('[Filtro agente] (rol agent) Enviado en query a /api/leads:', agenteNombreQuery);
          } else {
            console.info('[Filtro agente] Rol no-agent detectado (', roleLower, '): no se envía parámetro agente');
          }
          const qs = params.toString();
          url = qs ? `${u.pathname}?${qs}` : `${u.pathname}`;
        } catch (e) {
          console.warn('No se pudo construir la URL con filtro por agente:', e?.message);
        }
        console.log('Solicitando datos a:', url);
        
        // Realizar la petición a la API
        const tokenForGet = localStorage.getItem('token') || sessionStorage.getItem('token');
        const baseHeaders = {
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        };
        if (tokenForGet) baseHeaders['Authorization'] = `Bearer ${tokenForGet}`;
        
        const response = await fetch(url, {
          method: 'GET',
          headers: baseHeaders,
          credentials: 'same-origin'
        });
        
        // Verificar si la respuesta es exitosa; si no, usar datos de prueba
        if (!response.ok) {
          let bodyText = '';
          try { bodyText = await response.text(); } catch (_) {}
          console.warn(`Respuesta no OK (${response.status}). Cuerpo:`, bodyText);
          return await procesarDatosGraficaEstadisticas(datosPrueba);
        }
        
        // Obtener los datos de la respuesta
        const responseData = await response.json();
        console.log('Datos recibidos de la API:', responseData);
        
        // Extraer el array de clientes de la respuesta de forma robusta
        const safeData = responseData || {};
        let costumers = [];
        if (Array.isArray(safeData)) {
          costumers = safeData;
        } else if (Array.isArray(safeData.data)) {
          costumers = safeData.data;
        } else if (Array.isArray(safeData.leads)) {
          costumers = safeData.leads;
        } else if (Array.isArray(safeData.customers)) {
          costumers = safeData.customers;
        }

        console.log(`Datos extraídos: ${costumers.length} registros`);

        // Si no hay datos, usar datos de prueba
        if (!Array.isArray(costumers) || costumers.length === 0) {
          console.warn('No se encontraron datos en la respuesta. Usando datos de prueba.');
          return await procesarDatosGraficaEstadisticas(datosPrueba);
        }

        // Procesar datos para agrupar por día
        const BUSINESS_TZ_OFFSET_MIN = -6 * 60; // UTC-6 fijo
        const toISOInTZ_local = (date, tzOffsetMinutes) => {
          const target = new Date(date.getTime() + tzOffsetMinutes * 60000);
          const y = target.getUTCFullYear();
          const m = String(target.getUTCMonth() + 1).padStart(2, '0');
          const d = String(target.getUTCDate()).padStart(2, '0');
          return `${y}-${m}-${d}`;
        };

        // Inicializar los últimos 7 días
        const ventasPorDia = {};
        const fechasUltimos7Dias = new Set();
        const hoyISO = toISOInTZ_local(new Date(), BUSINESS_TZ_OFFSET_MIN);
        const [hy, hm, hd] = hoyISO.split('-').map(Number);
        const baseUTCNoon = new Date(Date.UTC(hy, hm - 1, hd, 12, 0, 0));
        
        for (let i = 6; i >= 0; i--) {
          const fechaUTC = new Date(baseUTCNoon);
          fechaUTC.setUTCDate(baseUTCNoon.getUTCDate() - i);
          const clave = toISOInTZ_local(fechaUTC, BUSINESS_TZ_OFFSET_MIN);
          fechasUltimos7Dias.add(clave);
          ventasPorDia[clave] = { ventas: 0, puntaje: 0 };
        }

        // Helpers para obtener fechas de los registros
        const getByPath = (obj, path) => {
          try {
            return path.split('.').reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : undefined), obj);
          } catch (_) {
            return undefined;
          }
        };

        const findFirst = (obj, paths) => {
          for (const p of paths) {
            const v = getByPath(obj, p);
            if (v !== undefined && v !== null && v !== '') return v;
          }
          return undefined;
        };

        const tryDateFrom = (val) => {
          if (!val) return null;
          if (typeof val === 'string') {
            const s = val.trim();
            if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
              const [y,m,d] = s.split('-').map(Number);
              return new Date(Date.UTC(y, m-1, d, 12, 0, 0));
            }
            if (/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(s)) {
              const parts = s.split(/[\/\-]/).map(Number);
              const [d,m,y] = parts;
              if (d >= 1 && d <= 31 && m >= 1 && m <= 12 && y >= 1900) {
                return new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
              }
            }
          }
          if (typeof val === 'number') return new Date(val < 1e12 ? val*1000 : val);
          const dt = new Date(val); return isNaN(dt) ? null : dt;
        };

        // Procesar los datos de los clientes
        if (Array.isArray(costumers) && costumers.length > 0) {
          costumers.forEach(costumer => {
            // Elegir día de negocio priorizando dia_venta; si no, usar fechas de creación
            const createdPaths = [
              'creadoEn','fecha_creacion','fechaCreacion','createdAt','created_at','createdon','createdOn','fecha',
              '_raw.creadoEn','_raw.fecha_creacion','_raw.fechaCreacion','_raw.createdAt','_raw.created_at','_raw.fecha',
              'metadata.createdAt','audit.createdAt','timestamps.createdAt'
            ];
            const diaVentaPaths = ['dia_venta','diaVenta'];

            let fecha = null;
            const diaVentaVal = findFirst(costumer, diaVentaPaths);
            fecha = tryDateFrom(typeof diaVentaVal === 'string' ? diaVentaVal.trim() : diaVentaVal);
            
            if (!fecha) {
              const fechaCreacionVal = findFirst(costumer, createdPaths);
              fecha = tryDateFrom(fechaCreacionVal);
            }

            let fechaStr = '';
            if (fecha && !isNaN(fecha.getTime())) {
              fechaStr = toISOInTZ_local(fecha, BUSINESS_TZ_OFFSET_MIN);
            } else {
              fechaStr = toISOInTZ_local(new Date(), BUSINESS_TZ_OFFSET_MIN);
            }
            
            // Contar solo si la fecha pertenece a los últimos 7 días inicializados
            if (!fechasUltimos7Dias.has(fechaStr)) {
              return;
            }
            
            // Obtener el puntaje
            let puntaje = 0;
            if (typeof costumer.puntaje === 'number') {
              puntaje = costumer.puntaje;
            } else if (typeof costumer.puntaje === 'string') {
              puntaje = parseFloat(costumer.puntaje) || 0;
            } else if (costumer.score) {
              puntaje = parseFloat(costumer.score) || 0;
            }
            
            // Contar la venta y sumar el puntaje
            ventasPorDia[fechaStr].ventas += 1;
            ventasPorDia[fechaStr].puntaje += puntaje;
          });
        }
        
        // Convertir el objeto a un array y ordenar por fecha
        const datosFinales = Object.entries(ventasPorDia)
          .map(([fecha, datos]) => ({
            fecha,
            ventas: datos.ventas,
            puntaje: datos.puntaje
          }))
          .sort((a, b) => new Date(a.fecha) - new Date(b.fecha));
        
        console.log('Datos procesados para la gráfica:', datosFinales);
        
        // Procesar los datos y actualizar la gráfica
        try {
          const resultado = await procesarDatosGraficaEstadisticas(datosFinales);
          console.log('Gráfica de ventas y puntaje actualizada correctamente');
          return resultado;
        } catch (error) {
          console.error('Error al procesar datos para la gráfica:', error);
          mostrarMensajeError('Error al procesar los datos de la gráfica');
          return false;
        }
        
      } catch (error) {
        console.error('Error al actualizar la gráfica de ventas y puntaje:', error);
        // Fallback: mostrar gráfica con datos de prueba
        try {
          return await procesarDatosGraficaEstadisticas(datosPrueba);
        } catch (e) {
          mostrarMensajeError('Error al actualizar la gráfica de ventas');
          return false;
        }
      }
    }

    // Función para inicializar la nueva gráfica
    function initVentasPuntajeChart() {
      console.log('Inicializando gráfica de ventas y puntaje...');
      
      try {
        ventasPuntajeChart = inicializarGraficaVentasPuntaje();
        if (ventasPuntajeChart) {
          // Cargar datos reales de la API
          actualizarGraficaVentasPuntaje().catch(() => {
            // Fallback a datos de prueba si falla la API
            procesarDatosGraficaEstadisticas(datosPrueba);
          });
          console.log('Gráfica de ventas y puntaje inicializada correctamente');
          
          // Configurar filtros de fecha
          setupDateFilters();
        }
      } catch (error) {
        console.error('Error al inicializar la gráfica de ventas y puntaje:', error);
      }
    }

    // Función para configurar los filtros de fecha
    function setupDateFilters() {
      // Llenar el select de días
      const daySelect = document.getElementById('day-select');
      const monthSelect = document.getElementById('month-select');
      const yearSelect = document.getElementById('year-select');
      
      if (!daySelect || !monthSelect || !yearSelect) return;

      // Función para llenar los días según el mes y año seleccionado
      function fillDays() {
        const month = parseInt(monthSelect.value);
        const year = parseInt(yearSelect.value);
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        daySelect.innerHTML = '';
        for (let i = 1; i <= daysInMonth; i++) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = i;
          daySelect.appendChild(option);
        }
      }

      // Configurar fecha actual
      const today = new Date();
      monthSelect.value = today.getMonth();
      yearSelect.value = today.getFullYear();
      fillDays();
      daySelect.value = today.getDate();

      // Event listeners para actualizar días cuando cambie mes o año
      monthSelect.addEventListener('change', fillDays);
      yearSelect.addEventListener('change', fillDays);

      // Event listener para aplicar filtro
      const applyFilterBtn = document.getElementById('apply-filter');
      if (applyFilterBtn) {
        applyFilterBtn.addEventListener('click', () => {
          console.log('Aplicando filtro de fecha...');
          // Actualizar gráfica con datos reales de la API
          actualizarGraficaVentasPuntaje().catch(() => {
            console.warn('Error al cargar datos de la API, usando datos de prueba');
            procesarDatosGraficaEstadisticas(datosPrueba);
          });
          mostrarNotificacion('Filtro aplicado correctamente');
        });
      }

      // Event listener para resetear a hoy
      const resetFilterBtn = document.getElementById('reset-filter');
      if (resetFilterBtn) {
        resetFilterBtn.addEventListener('click', () => {
          const today = new Date();
          monthSelect.value = today.getMonth();
          yearSelect.value = today.getFullYear();
          fillDays();
          daySelect.value = today.getDate();
          
          console.log('Reseteando filtro a fecha actual...');
          // Actualizar gráfica con datos reales de la API
          actualizarGraficaVentasPuntaje().catch(() => {
            console.warn('Error al cargar datos de la API, usando datos de prueba');
            procesarDatosGraficaEstadisticas(datosPrueba);
          });
          mostrarNotificacion('Filtro reseteado a fecha actual');
        });
      }
    }

    // Función simplificada para procesar datos en Estadísticas
    function procesarDatosGraficaEstadisticas(datos) {
      try {
        if (!Array.isArray(datos) || datos.length === 0) {
          console.warn('No hay datos disponibles para mostrar en la gráfica');
          return false;
        }

        // Generar etiquetas y datasets para los últimos 7 días
        const labels = [];
        const ventasData = [];
        const puntajesData = [];
        
        // Procesar datos ordenados por fecha
        const datosOrdenados = [...datos].sort((a, b) => new Date(a.fecha) - new Date(b.fecha));
        
        datosOrdenados.forEach(item => {
          // Parsear 'YYYY-MM-DD' como fecha LOCAL para evitar desfase de un día
          let y, m, d;
          if (typeof item.fecha === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(item.fecha)) {
            [y, m, d] = item.fecha.split('-').map(Number);
          } else {
            const tmp = new Date(item.fecha);
            y = tmp.getFullYear(); m = tmp.getMonth() + 1; d = tmp.getDate();
          }
          const fecha = new Date(y, (m || 1) - 1, d || 1, 12, 0, 0); // medio día local
          const dia = fecha.getDate();
          const diasSemana = ['dom', 'lun', 'mar', 'mié', 'jue', 'vie', 'sáb'];
          const diaSemana = diasSemana[fecha.getDay()];
          const etiqueta = `${diaSemana} ${dia}`;
          
          labels.push(etiqueta);
          ventasData.push(Number(item.ventas) || 0);
          puntajesData.push(Number(item.puntaje) || 0);
        });

        // Calcular máximos para escalar ejes
        const maxVentas = Math.max(...ventasData);
        const maxPuntaje = Math.max(...puntajesData);
        const maxBoth = Math.max(maxVentas, maxPuntaje);

        // Configuración de la gráfica
        const config = {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Ventas',
                data: ventasData,
                backgroundColor: 'rgba(54, 162, 235, 0.7)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
                borderRadius: 4,
                yAxisID: 'y',
                categoryPercentage: 0.6,
                barPercentage: 0.9,
                datalabels: {
                  anchor: 'end',
                  align: 'end',
                  offset: 4,
                  color: '#2c3e50',
                  font: { weight: 'bold' },
                  formatter: (v) => (v != null && !isNaN(v) && Number(v) !== 0 ? Math.round(v) : '')
                }
              },
              {
                label: 'Puntaje',
                data: puntajesData,
                type: 'bar',
                backgroundColor: 'rgba(255, 99, 132, 0.7)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
                borderRadius: 4,
                yAxisID: 'y1',
                categoryPercentage: 0.6,
                barPercentage: 0.9,
                datalabels: {
                  anchor: 'end',
                  align: 'end',
                  offset: 4,
                  color: '#7f1d1d',
                  font: { weight: 'bold' },
                  formatter: (v) => {
                    if (v == null || isNaN(v) || Number(v) === 0) return '';
                    const n = Number(v);
                    return n.toFixed(2).replace(/\.00$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
                  }
                }
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { bottom: 40 } },
            scales: {
              x: {
                display: true,
                grid: { display: false },
                ticks: {
                  display: true,
                  color: '#4a4a4a',
                  autoSkip: false,
                  maxRotation: 0,
                  minRotation: 0,
                  padding: 8,
                  font: { size: 12 }
                },
                title: { display: true, text: 'Días' }
              },
              y: {
                type: 'linear',
                display: true,
                position: 'left',
                title: { display: false, text: 'N° de Ventas' },
                beginAtZero: true,
                grid: { display: false },
                border: { display: false },
                ticks: { display: false },
                max: Math.max(5, Math.ceil(maxBoth * 1.2))
              },
              y1: {
                type: 'linear',
                display: true,
                position: 'right',
                grid: { display: false, drawOnChartArea: false },
                border: { display: false },
                title: { display: false, text: 'Puntaje' },
                beginAtZero: true,
                min: 0,
                max: Math.max(5, Math.ceil(maxBoth * 1.2)),
                ticks: { display: false }
              }
            },
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) { label += ': '; }
                    if (context.parsed.y !== null) { label += context.parsed.y; }
                    return label;
                  }
                }
              },
              legend: {
                position: 'top',
                labels: { usePointStyle: true, pointStyle: 'circle', padding: 20 }
              },
              datalabels: {
                display: true,
                clamp: true,
                clip: false
              }
            }
          }
        };

        // Reconstruir la gráfica
        const canvasEl = document.getElementById('ventasPuntajeChart');
        if (!canvasEl) throw new Error('Canvas ventasPuntajeChart no encontrado');
        const ctx = canvasEl.getContext('2d');
        if (ventasPuntajeChart) {
          try { ventasPuntajeChart.destroy(); } catch (_) {}
          ventasPuntajeChart = null;
        }
        ventasPuntajeChart = new Chart(ctx, config);
        
        console.log('Gráfica de ventas y puntaje actualizada correctamente');
        return true;
      } catch (error) {
        console.error('Error al procesar datos de la gráfica:', error);
        mostrarMensajeError('Error al procesar los datos de la gráfica');
        return false;
      }
    }

    // Esperar a que todo el DOM y recursos estÃ©n cargados
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initializeApp();
        initConversionTable();
        // Inicializar la nueva gráfica
        setTimeout(() => {
          initVentasPuntajeChart();
        }, 500);
      });
    } else {
      initializeApp();
      initConversionTable();
      // Inicializar la nueva gráfica
      setTimeout(() => {
        initVentasPuntajeChart();
      }, 500);
    }
  </script>
</body>
</html>
