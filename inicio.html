
<!DOCTYPE html>
<html lang="es">
<head>
  

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="css/theme.css">
  
  <!-- Font Awesome -->
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  
  <!-- Custom CSS -->
  <link rel="stylesheet" href="css/sidebar-shared.css?v=20251124f">
  <link rel="stylesheet" href="css/costumer-table-actions.css">
  <!-- Scripts cr√≠ticos que deben cargar primero (defer para no bloquear parseo) -->
  <script src="js/crm-config.js" defer></script>
  <script src="js/fetch-interceptor.js" defer></script>
  <script src="js/dashboard-init.js" defer></script>
  <style>
    /* Estilos globales para eliminar scroll */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Roboto', sans-serif;
    }
    
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: 'Roboto', sans-serif;
    }
    
    .layout {
      height: 100vh;
      display: flex;
    }
    
    .main-content {
      flex: 1;
      height: 100vh;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .ranking-panel {
      max-width: 1000px;
      width: 100%;
      margin-top: 20px;
    }
    
    /* Limpieza: se eliminan overrides agresivos de .main-content */
    
    .ranking-header {
      position: relative !important;
      z-index: 10 !important;
      margin-bottom: 30px !important;
    }
    
    .ranking-icon {
      position: relative !important;
      z-index: 15 !important;
    }
    
    /* Sidebar espec√≠fico est√° en css/sidebar-inicio.css */
    
    .user-info {
      text-align: center;
      padding: 0 20px 20px;
      border-bottom: 1px solid #e2e8f0;
      margin-bottom: 20px;
    }
    
    .avatar {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #e2e8f0;
      margin: 0 auto 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.5em;
      color: #64748b;
    }
    
    .user-name {
      display: block;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 5px;
    }
    
    .user-role {
      display: block;
      font-size: 0.9em;
      color: #64748b;
    }
    
    .sidebar h3 {
      color: #22b3ec;
      font-size: 1.1rem;
      margin: 0 24px 24px;
      padding-bottom: 10px;
      border-bottom: 1px solid #e2e8f0;
    }
    
    /* Sidebar: estilos unificados en css/sidebar.css */
    
    /* Estilos para el contenedor de la gr√°fica */
    .graph-container {
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }
    
    /* Estilos para el layout principal */
    .layout {
      display: flex;
      min-height: 100vh;
    }
    
    /* Estilos para el contenido principal */
    .main-content {
      flex: 1;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      position: relative;
      overflow-y: auto;
    }
    
    /* Estilos para el panel de ranking */
    .ranking-panel {
      background: transparent;
      border-radius: 0;
      box-shadow: none;
      margin: 20px 0;
      width: 90%;
      max-width: 1400px;
      overflow: visible;
      position: relative;
      backdrop-filter: none;
      border: none;
    }


    .ranking-header {
      text-align: center;
      padding: 50px 30px 30px;
      color: #1e293b;
      position: relative;
      z-index: 1;
      background: transparent;
      backdrop-filter: none;
      border-radius: 0;
    }

    .ranking-icon {
      font-size: 4rem;
      margin-bottom: 20px;
      color: #ffd700;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    }

    .ranking-title {
      font-size: 3rem;
      font-weight: 800;
      margin: 0 0 15px 0;
      background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -0.02em;
    }

    .ranking-subtitle {
      font-size: 1.3rem;
      margin: 0;
      opacity: 0.9;
      font-weight: 300;
    }

    .ranking-content {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      padding: 40px;
      position: relative;
      z-index: 1;
    }

    /* Podio Circular */
    .circular-podium {
      display: flex;
      justify-content: center;
      align-items: flex-end;
      gap: 80px;
      margin: 60px 0;
      position: relative;
    }

    .podium-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    .podium-line {
      width: 200px;
      height: 4px;
      background: #e5e7eb;
      margin-bottom: 20px;
      border-radius: 2px;
    }

    .second-place .podium-line {
      background: #9ca3af;
    }

    .first-place .podium-line {
      background: #fbbf24;
    }

    .third-place .podium-line {
      background: #f97316;
    }

    .podium-circle {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: white;
      border: 6px solid #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      margin-bottom: 20px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
    }

    .second-place .podium-circle {
      border-color: #9ca3af;
    }

    .first-place .podium-circle {
      border-color: #fbbf24;
      width: 140px;
      height: 140px;
    }

    .third-place .podium-circle {
      border-color: #f97316;
    }

    .medal-icon, .trophy-icon {
      font-size: 2.5rem;
      color: #9ca3af;
    }

    .first-place .trophy-icon {
      font-size: 3rem;
      color: #fbbf24;
    }

    .third-place .medal-icon {
      color: #f97316;
    }

    .position-badge {
      position: absolute;
      bottom: -10px;
      right: -10px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #9ca3af;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      font-weight: 700;
      border: 3px solid white;
    }

    .first-place .position-badge {
      background: #fbbf24;
      width: 50px;
      height: 50px;
      font-size: 1.2rem;
    }

    .third-place .position-badge {
      background: #f97316;
    }

    .agent-info {
      text-align: center;
    }

    .agent-info h3 {
      margin: 0 0 8px 0;
      font-size: 1.25rem;
      font-weight: 600;
      color: #1f2937;
    }

    .agent-info p {
      margin: 0 0 16px 0;
      color: #6b7280;
      font-size: 0.875rem;
      font-weight: 400;
      padding: 4px 12px;
      background: #f3f4f6;
      border-radius: 12px;
      display: inline-block;
    }

    .first-place .agent-info p {
      background: #fef3c7;
      color: #92400e;
    }

    .third-place .agent-info p {
      background: #fed7aa;
      color: #c2410c;
    }

    .score {
      font-size: 2rem;
      font-weight: 700;
      color: #9ca3af;
    }

    .first-place .score {
      color: #fbbf24;
      font-size: 2.5rem;
    }

    .third-place .score {
      color: #f97316;
    }

    /* Otros participantes */
    .other-ranks {
      margin-top: 40px;
    }

    .other-ranks h3 {
      text-align: center;
      color: #1e293b;
      font-size: 1.5rem;
      margin-bottom: 30px;
      font-weight: 700;
    }

    .rank-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .rank-item {
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      transition: all 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .rank-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    }

    .rank-number {
      font-size: 1.5rem;
      font-weight: 800;
      color: #64748b;
      min-width: 40px;
      text-align: center;
    }

    .rank-item .agent-info {
      display: flex;
      align-items: center;
      gap: 15px;
      flex: 1;
    }

    .rank-item .agent-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, #64748b 0%, #94a3b8 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 1.2rem;
    }

    .agent-details h4 {
      margin: 0 0 3px 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: #1e293b;
    }

    .agent-details p {
      margin: 0;
      color: #64748b;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .rank-item .agent-stats {
      display: flex;
      flex-direction: column;
      gap: 5px;
      text-align: right;
    }

    .points {
      font-size: 1rem;
      font-weight: 700;
      color: #1e293b;
    }

    .sales {
      font-size: 0.8rem;
      color: #64748b;
      font-weight: 500;
    }

    /* Responsive para ranking */
    @media (max-width: 768px) {
      .ranking-panel {
        border-radius: 15px;
      }
      
      .ranking-header {
        padding: 30px 20px 20px;
      }
      
      .ranking-title {
        font-size: 2rem;
      }
      
      .ranking-subtitle {
        font-size: 0.9rem;
      }
      
      .ranking-content {
        padding: 30px 20px;
      }
      
      .podium {
        flex-direction: column;
        gap: 30px;
        align-items: center;
      }
      
      .podium-position {
        flex-direction: row;
        width: 100%;
        max-width: 350px;
      }
      
      .podium-agent {
        margin-bottom: 0;
        margin-right: 20px;
        flex: 1;
        padding: 20px 15px;
      }
      
      .agent-avatar {
        width: 60px;
        height: 60px;
        font-size: 1.5rem;
      }
      
      .podium-agent h3 {
        font-size: 1.1rem;
      }
      
      .podium-stats {
        gap: 10px;
      }
      
      .stat-number {
        font-size: 1.2rem;
      }
      
      .podium-base {
        width: 80px;
        height: 60px;
      }
      
      .first-place {
        height: 70px;
      }
      
      .second-place {
        height: 60px;
      }
      
      .third-place {
        height: 50px;
      }
      
      .position-number {
        font-size: 1.4rem;
      }
      
      .rank-item {
        padding: 15px;
        gap: 15px;
      }
      
      .rank-item .agent-avatar {
        width: 40px;
        height: 40px;
        font-size: 1rem;
      }
      
      .agent-details h4 {
        font-size: 1rem;
      }
      
      .rank-number {
        font-size: 1.2rem;
        min-width: 30px;
      }
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .welcome-panel {
        flex-direction: column;
        min-height: auto;
      }
      
      .welcome-header {
        flex: none;
        padding: 40px 30px;
      }
      
      .welcome-content {
        flex: none;
        border-left: none;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
      }
      
      .metrics-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .actions-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 768px) {
      .main-content {
        margin-left: 0;
        width: 100%;
        padding: 15px;
      }
      
      .welcome-panel {
        width: 100%;
        border-radius: 15px;
        flex-direction: column;
        min-height: auto;
      }
      
      .welcome-header {
        padding: 30px 20px;
        flex: none;
      }
      
      .welcome-title {
        font-size: 2.2rem;
      }
      
      .welcome-subtitle {
        font-size: 1.1rem;
      }
      
      .welcome-content {
        padding: 20px;
        flex: none;
        border-left: none;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
      }
      
      .metrics-grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .actions-grid {
        grid-template-columns: 1fr;
        gap: 12px;
      }
      
      .status-grid {
        grid-template-columns: 1fr;
        gap: 12px;
      }
    }
    
    /* Estilos para la barra superior */
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .search-bar {
      position: relative;
      width: 300px;
    }
    
    .search-bar input {
      width: 100%;
      padding: 8px 15px 8px 35px;
      border: 1px solid #ddd;
      border-radius: 20px;
      outline: none;
    }
    
    .search-bar i {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: #888;
    }
    
    .user-actions {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    .notification {
      position: relative;
      cursor: pointer;
    }
    
    .badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background: #ff4757;
      color: white;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
    }
    
    /* ==========================
       Ranking v2 (solo CSS)
       - Efecto glass + gradientes
       - Animaciones suaves
       - Sin cambios HTML/JS
    =========================== */
    .ranking-panel {
      background: radial-gradient(1200px 600px at 80% -10%, rgba(14,165,233,.25) 0%, transparent 60%),
                  radial-gradient(800px 400px at 0% 120%, rgba(16,185,129,.18) 0%, transparent 60%);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.35);
      box-shadow: 0 15px 40px rgba(2,132,199,.18);
      backdrop-filter: blur(6px);
    }

    .ranking-header {
      text-align: center;
      padding: 56px 30px 32px;
    }

    .ranking-icon {
      filter: drop-shadow(0 6px 18px rgba(251,191,36,.35));
      transform: translateZ(0);
      animation: trophyGlow 3.2s ease-in-out infinite;
    }

    .ranking-title {
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, #0ea5e9 0%, #22c55e 50%, #f59e0b 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 0 rgba(0,0,0,0);
    }

    .ranking-subtitle {
      color: rgba(30,41,59,.8);
    }

    /* Podio circular modernizado */
    .circular-podium {
      gap: 100px;
    }

    .podium-item {
      animation: floatY 6s ease-in-out infinite;
    }
    .podium-item.first-place { animation-delay: .2s; }
    .podium-item.second-place { animation-delay: .4s; }
    .podium-item.third-place { animation-delay: .6s; }

    .podium-circle {
      background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
      border: none;
      position: relative;
    }
    .podium-circle::before{
      content: "";
      position: absolute;
      inset: -8px;
      border-radius: 50%;
      background: conic-gradient(from 0deg, #22c55e, #0ea5e9, #f59e0b, #ef4444, #22c55e);
      filter: blur(0.5px);
      z-index: -1;
      animation: rotateRing 12s linear infinite;
    }

    .position-badge{
      box-shadow: 0 6px 12px rgba(0,0,0,.15);
    }

    /* Tarjetas del resto del ranking con glass effect */
    .rank-item{
      background: rgba(255,255,255,.7);
      border: 1px solid rgba(255,255,255,.6);
      backdrop-filter: blur(8px);
      transition: transform .2s ease, box-shadow .2s ease;
    }
    .rank-item:hover{
      transform: translateY(-4px);
      box-shadow: 0 14px 32px rgba(2,132,199,.18);
    }

    .points{
      background: linear-gradient(90deg, #0ea5e9 0%, #22c55e 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    /* Animaciones */
    @keyframes rotateRing {
      to { transform: rotate(360deg); }
    }
    @keyframes floatY {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }
    @keyframes trophyGlow {
      0%, 100% { filter: drop-shadow(0 6px 18px rgba(251,191,36,.25)); }
      50% { filter: drop-shadow(0 10px 26px rgba(251,191,36,.45)); }
    }
    
    /* ==========================
       Ranking Neon Pop (overrides)
       juvenil, vibrante, sin cambios HTML/JS
    =========================== */
    .ranking-panel{
      background:
        radial-gradient(900px 500px at 10% -10%, rgba(255,0,122,.18) 0%, transparent 60%),
        radial-gradient(800px 480px at 110% 10%, rgba(0,200,255,.20) 0%, transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.85) 0%, rgba(255,255,255,.75) 100%);
      border: 2px solid rgba(0,0,0,.03);
      box-shadow: 0 18px 40px rgba(0,0,0,.10);
      backdrop-filter: blur(8px);
    }

    .ranking-title{
      background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #5f27cd);
      -webkit-background-clip: text; background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: none;
    }
    .ranking-subtitle{ color: #475569; opacity: .9; }

    .circular-podium{ gap: 110px; }
    .podium-item{ animation: bouncePop 5s ease-in-out infinite; }
    .podium-item.first-place{ animation-delay: .1s; }
    .podium-item.second-place{ animation-delay: .3s; }
    .podium-item.third-place{ animation-delay: .5s; }

    .podium-line{ height: 6px; border-radius: 999px; background: #e2e8f0; }
    .second-place .podium-line{ background: linear-gradient(90deg,#60a5fa,#a78bfa); }
    .first-place .podium-line{ background: linear-gradient(90deg,#22c55e,#10b981); }
    .third-place .podium-line{ background: linear-gradient(90deg,#fb7185,#f59e0b); }

    .podium-circle{
      background: #fff;
      border: none;
      box-shadow: 0 12px 30px rgba(0,0,0,.10);
    }
    .podium-circle::before{
      content: ""; position: absolute; inset: -10px; border-radius: 50%;
      background: conic-gradient(from 0deg,
        #ff6b6b 0%, #feca57 20%, #48dbfb 40%, #5f27cd 60%, #22c55e 80%, #ff6b6b 100%);
      animation: spinNeon 8s linear infinite;
      filter: saturate(120%);
      z-index: -1;
    }
    .trophy-icon, .medal-icon{ color: #111827; filter: drop-shadow(0 4px 8px rgba(0,0,0,.15)); }

    .position-badge{
      background: #111827; color: #fff; border: 3px solid #fff;
      box-shadow: 0 8px 14px rgba(0,0,0,.25);
    }

    .rank-item{
      border-radius: 16px;
      border: 1px solid rgba(0,0,0,.05);
      background: linear-gradient(180deg, rgba(255,255,255,.9), rgba(255,255,255,.8));
      transform: translateZ(0);
    }
    .rank-item:hover{ transform: translateY(-6px) rotate(-.25deg); }
    .rank-number{ color: #475569; font-weight: 800; }
    .agent-avatar{ background: linear-gradient(135deg,#5f27cd,#48dbfb); }
    .agent-details h4{ color:#0f172a; }
    .agent-details p{ background: rgba(99,102,241,.12); color:#3730a3; }
    .points{ background: linear-gradient(90deg,#f472b6,#22d3ee); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent; }

    @keyframes spinNeon { to { transform: rotate(360deg); } }
    @keyframes bouncePop {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-10px) scale(1.02); }
    }
    
    /* ==========================
       Podio en bloques (overrides)
       - Mantiene HTML/JS
       - Cambia solo la presentaci√≥n
    =========================== */
    .circular-podium{ gap: 90px; align-items: flex-end; }
    .podium-item{ position: relative; padding-bottom: 60px; }

    /* Quitar aro decorativo de la versi√≥n anterior */
    .podium-circle{ width: 120px; height: 120px; border-radius: 18px; background: #ffffff; border: 2px solid rgba(15,23,42,.06); box-shadow: 0 10px 20px rgba(0,0,0,.08); }
    .podium-circle::before{ content: none !important; }

    /* Barra superior (corona) m√°s delgada y vibrante */
    .podium-line{ width: 120px; height: 6px; border-radius: 999px; margin-bottom: 14px; background: linear-gradient(90deg,#22d3ee,#a78bfa,#f472b6); }

    /* Pedestal en bloques por lugar usando pseudo-elemento */
    .podium-item::after{
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: -4px;
      width: 150px;
      height: var(--pedestal-h, 50px);
      background: linear-gradient(180deg, rgba(255,255,255,.95) 0%, rgba(248,250,252,.95) 100%);
      border: 1px solid rgba(2,6,23,.06);
      border-radius: 16px 16px 10px 10px;
      box-shadow: 0 16px 30px rgba(2,132,199,.15), inset 0 1px 0 rgba(255,255,255,.9);
    }
    .podium-item.first-place{ --pedestal-h: 70px; }
    .podium-item.second-place{ --pedestal-h: 55px; }
    .podium-item.third-place{ --pedestal-h: 45px; }

    /* Medalla/insignia m√°s limpia sobre el c√≠rculo */
    .position-badge{ background: #111827; color: #fff; border: 3px solid #fff; box-shadow: 0 8px 16px rgba(0,0,0,.25); }

    /* Puntos con gradiente juvenil y compatibilidad de clip */
    .points{
      background: linear-gradient(90deg,#06b6d4,#a78bfa);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }
  </style>
  
  
  <style>
    /* Overrides: quitar pedestales y corona del podio (sin tocar HTML/JS) */
    .podium-item::after { content: none !important; }
    .podium-item.first-place::before { content: none !important; }
    .podium-item .podium-circle { animation: none !important; }
  </style>
  <style>
    /* Podio: oro/plata/bronce + corona y animaci√≥n (solo CSS) */
    .podium-item.first-place{ --pedestal-h: 90px; }
    .podium-item.second-place{ --pedestal-h: 60px; }
    .podium-item.third-place{ --pedestal-h: 45px; }

    .podium-item.first-place::after{
      background: linear-gradient(180deg, #fff8e1 0%, #fde68a 100%);
      border-color: rgba(202,138,4,.25);
      box-shadow: 0 22px 40px rgba(202,138,4,.25), inset 0 1px 0 rgba(255,255,255,.9);
    }
    .podium-item.second-place::after{
      background: linear-gradient(180deg, #f8fafc 0%, #e5e7eb 100%);
      border-color: rgba(107,114,128,.25);
      box-shadow: 0 18px 34px rgba(107,114,128,.22), inset 0 1px 0 rgba(255,255,255,.9);
    }
    .podium-item.third-place::after{
      background: linear-gradient(180deg, #fff7ed 0%, #fdba74 100%);
      border-color: rgba(180,83,9,.25);
      box-shadow: 0 18px 34px rgba(180,83,9,.22), inset 0 1px 0 rgba(255,255,255,.9);
    }

    /* Corona para el primer lugar */
    .podium-item.first-place::before{
      content: "üëë";
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 26px;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,.15));
      animation: crownFloat 3.8s ease-in-out infinite;
      pointer-events: none;
    }

    /* C√≠rculo protagonista con ‚Äúrespiraci√≥n‚Äù y glow dorado */
    .podium-item.first-place .podium-circle{
      box-shadow: 0 10px 26px rgba(234,179,8,.25);
      animation: breathe 4s ease-in-out infinite;
    }
    .podium-item.first-place .trophy-icon{ color: #ca8a04; }

    @keyframes breathe{
      0%,100%{ transform: scale(1); }
      50%{ transform: scale(1.035); }
    }
    @keyframes crownFloat{
      0%,100%{ transform: translate(-50%,0); }
      50%{ transform: translate(-50%,-6px); }
    }
  </style>
  <style>
    /* Overrides: quitar contenedor visual del ranking sin tocar HTML/JS */
    .ranking-panel{
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      backdrop-filter: none !important;
      border-radius: 0 !important;
    }
    .ranking-header{
      background: transparent !important;
      box-shadow: none !important;
    }
    .ranking-content{
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
    }
  </style>
  <style>
    /* Override: ocultar el √≠cono de trofeo del header */
    .ranking-icon { display: none !important; }
  </style>
  <style>
    /* Overrides: ocultar t√≠tulo y subt√≠tulo del ranking */
    .ranking-title, .ranking-subtitle { display: none !important; }
    .ranking-header { padding-top: 8px !important; padding-bottom: 8px !important; }
  </style>
  <style>
    /* Overrides: ocultar etiquetas de rol bajo los nombres */
    .podium-item .agent-info p,
    .rank-list .agent-details p { display: none !important; }

    /* Estilos para el panel de bienvenida del usuario */
    .user-welcome-panel {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 40px;
      color: white;
      box-shadow: 0 15px 35px rgba(102, 126, 234, 0.3);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 100%;
      max-width: 1200px;
    }

    .welcome-header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 30px;
    }

    .welcome-avatar {
      font-size: 4rem;
      color: rgba(255, 255, 255, 0.9);
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
    }

    .welcome-info h2 {
      margin: 0 0 8px 0;
      font-size: 2.2rem;
      font-weight: 700;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .welcome-info p {
      margin: 0;
      font-size: 1.1rem;
      opacity: 0.9;
      font-weight: 300;
    }

    .welcome-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      display: flex;
      align-items: center;
      gap: 15px;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }

    .stat-icon {
      font-size: 2rem;
      color: rgba(255, 255, 255, 0.9);
      min-width: 50px;
      text-align: center;
    }

    .stat-info {
      display: flex;
      flex-direction: column;
    }

    .stat-number {
      font-size: 1.8rem;
      font-weight: 700;
      margin-bottom: 4px;
      color: #fff;
    }

    .stat-label {
      font-size: 0.9rem;
      opacity: 0.8;
      font-weight: 400;
    }

    /* Responsive para el panel de usuario */
    @media (max-width: 768px) {
      .user-welcome-panel {
        padding: 20px;
        margin-bottom: 30px;
      }

      .welcome-header {
        flex-direction: column;
        text-align: center;
        gap: 15px;
      }

      .welcome-avatar {
        font-size: 3rem;
      }

      .welcome-info h2 {
        font-size: 1.8rem;
      }

      .welcome-stats {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .stat-card {
        padding: 15px;
      }

      .stat-number {
        font-size: 1.5rem;
      }
    }

    /* Protecciones Section Styles */
    .protecciones-section {
      width: 100%;
      max-width: 1200px;
      margin-bottom: 40px;
    }

    .protecciones-header {
      text-align: center;
      margin-bottom: 30px;
    }

    .protecciones-header h3 {
      font-size: 2rem;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .protecciones-header p {
      font-size: 1.1rem;
      color: #64748b;
      margin: 0;
    }

    .protecciones-card {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(220, 38, 38, 0.1);
      border: 1px solid rgba(220, 38, 38, 0.1);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .protecciones-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #dc2626, #ef4444);
    }

    .protecciones-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 30px rgba(220, 38, 38, 0.15);
    }

    .protecciones-icon {
      width: 60px;
      height: 60px;
      border-radius: 12px;
      background: linear-gradient(135deg, #dc2626, #ef4444);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
      color: white;
      font-size: 1.5rem;
    }

    .protecciones-content h4 {
      font-size: 1.3rem;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .protecciones-content h4 i {
      color: #dc2626;
    }

    .protecciones-rule {
      background: #fef2f2;
      border-left: 4px solid #dc2626;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 15px;
    }

    .protecciones-rule p {
      margin: 0;
      color: #374151;
      font-size: 1rem;
      line-height: 1.6;
      font-weight: 500;
    }

    .protecciones-warning {
      background: #fffbeb;
      border: 1px solid #f59e0b;
      border-radius: 8px;
      padding: 15px;
      display: flex;
      align-items: flex-start;
      gap: 12px;
      margin-top: 15px;
    }

    .protecciones-warning i {
      color: #f59e0b;
      font-size: 1.2rem;
      margin-top: 2px;
    }

    .protecciones-warning p {
      margin: 0;
      color: #92400e;
      font-size: 0.9rem;
      line-height: 1.5;
    }

    /* Responsive para protecciones */
    @media (max-width: 768px) {
      .protecciones-section {
        margin-bottom: 30px;
      }

      .protecciones-header h3 {
        font-size: 1.6rem;
      }

      .protecciones-card {
        padding: 20px;
      }

      .protecciones-content h4 {
        font-size: 1.1rem;
      }

      .protecciones-rule {
        padding: 15px;
      }
    }

    /* Dashboard Metrics Styles */
    .dashboard-metrics {
      width: 100%;
      max-width: 1200px;
      margin-bottom: 40px;
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }

    .metric-card {
      background: white;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.05);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .metric-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #667eea, #764ba2);
    }

    .metric-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
    }

    .metric-card .metric-icon {
      width: 60px;
      height: 60px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: white;
      margin-bottom: 16px;
    }

    .metric-icon.leads { background: linear-gradient(135deg, #667eea, #764ba2); }
    .metric-icon.sales { background: linear-gradient(135deg, #f093fb, #f5576c); }
    .metric-icon.conversion { background: linear-gradient(135deg, #4facfe, #00f2fe); }
    .metric-icon.revenue { background: linear-gradient(135deg, #43e97b, #38f9d7); }

    .metric-info {
      display: flex;
      flex-direction: column;
    }

    .metric-number {
      font-size: 2.2rem;
      font-weight: 700;
      color: #1a202c;
      margin-bottom: 4px;
    }
    /* Override espec√≠fico: Mejor vendedor del mes */
    #best-seller-name {
      font-size: clamp(1.2rem, 2.5vw, 1.6rem);
      line-height: 1.2;
    }

    .metric-label {
      font-size: 0.9rem;
      color: #718096;
      font-weight: 500;
      margin-bottom: 8px;
    }

    .metric-change {
      font-size: 0.85rem;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 6px;
      align-self: flex-start;
    }

    .metric-change.positive {
      background: rgba(72, 187, 120, 0.1);
      color: #38a169;
    }

    .metric-change.negative {
      background: rgba(245, 101, 101, 0.1);
      color: #e53e3e;
    }

    /* Charts Section */
    .charts-section {
      width: 100%;
      max-width: 1200px;
      margin-bottom: 40px;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 24px;
    }

    .chart-card {
      background: white;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e2e8f0;
    }

    .chart-header h3 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
      color: #1a202c;
    }

    .chart-controls select {
      padding: 8px 12px;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      background: white;
      font-size: 0.9rem;
      color: #4a5568;
    }

    .chart-container {
      position: relative;
      height: 300px;
    }

    /* Quick Actions */
    .quick-actions {
      width: 100%;
      max-width: 1200px;
      margin: 20px auto 40px auto;
      padding: 0 20px;
    }

    .quick-actions h3 {
      margin: 0 0 24px 0;
      font-size: 1.5rem;
      font-weight: 600;
      color: #1a202c;
    }

    .actions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }

    .action-card {
      background: white;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.05);
      text-decoration: none;
      color: inherit;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .action-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
      text-decoration: none;
      color: inherit;
    }

    .action-icon {
      width: 50px;
      height: 50px;
      border-radius: 12px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: white;
      flex-shrink: 0;
    }

    .action-info h4 {
      margin: 0 0 4px 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: #1a202c;
    }

    .action-info p {
      margin: 0;
      font-size: 0.9rem;
      color: #718096;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .charts-grid {
        grid-template-columns: 1fr;
      }
      
      .metrics-grid {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
      }
      
      .actions-grid {
        grid-template-columns: 1fr;
        gap: 16px;
      }
      
      .action-card {
        padding: 20px;
      }
    }
  </style>
  <script>
    // Verificar autenticaci√≥n al cargar la p√°gina
    document.addEventListener('DOMContentLoaded', async function() {
      try {
        console.log('üîç Iniciando verificaci√≥n de autenticaci√≥n...');
        const res = await fetch('/api/auth/verify-server', { method: 'GET', credentials: 'include' });
        
        console.log('üì° Response status:', res.status);
        console.log('üì° Response ok:', res.ok);
        
        if (!res.ok) {
          console.error('‚ùå Respuesta no v√°lida, redirigiendo a login');
          window.location.href = 'login.html';
          return;
        }
        
        const data = await res.json().catch((err) => {
          console.error('‚ùå Error parseando JSON:', err);
          return {};
        });
        
        console.log('üì¶ Datos completos recibidos del servidor:', JSON.stringify(data, null, 2));
        
        // Verificar si el usuario est√° autenticado
        if (!data.authenticated || !data.user) {
          console.error('‚ùå Usuario no autenticado');
          window.location.href = 'login.html';
          return;
        }
        
        const user = data.user;
        console.log('üë§ Usuario extra√≠do:', JSON.stringify(user, null, 2));
        console.log('‚úÖ Usuario autenticado correctamente:', user.username);

        // Emitir evento de autenticaci√≥n para que el sidebar se recargue con el rol correcto
        console.log('üì¢ Emitiendo evento user:authenticated con usuario:', user);
        document.dispatchEvent(new CustomEvent('user:authenticated', { detail: user }));
        console.log('‚úÖ Evento user:authenticated emitido');

        // Mostrar nombre de usuario en el sidebar
        const welcomeMessage = document.getElementById('welcome-message');
        if (welcomeMessage) {
          welcomeMessage.textContent = `Bienvenido/a, ${user.username || 'Usuario'}`;
        }

        // Actualizar informaci√≥n del usuario en el panel de bienvenida
        const welcomeUserName = document.getElementById('welcome-user-name');
        const welcomeUserRole = document.getElementById('welcome-user-role');
        
        if (welcomeUserName) {
          welcomeUserName.textContent = `Bienvenido/a, ${user.username || 'Usuario'}`;
        }
        
        if (welcomeUserRole) {
          const role = user.role || 'usuario';
          welcomeUserRole.textContent = `${role.charAt(0).toUpperCase() + role.slice(1)} - ${user.team || 'Sin equipo'}`;
        }

        // Mostrar nombre de usuario en el perfil de usuario
        const userNameElement = document.getElementById('user-name');
        console.log('Elemento user-name encontrado:', userNameElement);
        if (userNameElement) {
          userNameElement.textContent = user.username || 'Usuario';
          console.log('Nombre actualizado a:', user.username);
        } else {
          console.log('ERROR: No se encontr√≥ el elemento user-name');
        }

        // Mostrar rol del usuario
        const userRoleElement = document.getElementById('user-role');
        console.log('Elemento user-role encontrado:', userRoleElement);
        if (userRoleElement) {
          const role = user.role || 'usuario';
          userRoleElement.textContent = role.charAt(0).toUpperCase() + role.slice(1);
          console.log('Rol actualizado a:', role);
        } else {
          console.log('ERROR: No se encontr√≥ el elemento user-role');
        }

        // Mostrar opci√≥n de "Crear cuenta" solo si es ADMIN
        const createAccountItem = document.getElementById('menu-create-account');
        if (createAccountItem) {
          const roleLower = (user.role || '').toLowerCase();
          createAccountItem.style.display = roleLower === 'admin' ? 'block' : 'none';
        }


        // Actualizar estad√≠sticas en el sidebar
        const sidebarUserSales = document.getElementById('sidebar-user-sales');
        const sidebarUserPoints = document.getElementById('sidebar-user-points');
        const sidebarUserTeam = document.getElementById('sidebar-user-team');

        if (sidebarUserTeam) {
          sidebarUserTeam.textContent = user.team || 'Sin equipo';
        }

        // Obtener estad√≠sticas personales del usuario para el sidebar
        await loadUserStatsForSidebar(user.username);
        
        // Cargar datos del dashboard
        await loadDashboardData(user);

        // Funci√≥n para actualizar informaci√≥n del usuario en el sidebar
        function updateUserInfoInSidebar() {
          console.log('Actualizando informaci√≥n del usuario en sidebar...');
          console.log('Datos del usuario disponibles:', user);
          
          // Actualizar nombre de usuario
          const userNameElement = document.getElementById('user-name');
          console.log('Elemento user-name encontrado:', userNameElement);
          if (userNameElement) {
            userNameElement.textContent = user.username || 'Usuario';
            console.log('Nombre actualizado:', user.username);
          } else {
            console.error('Elemento #user-name no encontrado en el DOM');
          }

          // Actualizar rol del usuario
          const userRoleElement = document.getElementById('user-role');
          console.log('Elemento user-role encontrado:', userRoleElement);
          if (userRoleElement) {
            const role = user.role || 'usuario';
            userRoleElement.textContent = role.charAt(0).toUpperCase() + role.slice(1);
            console.log('Rol actualizado:', role);
          } else {
            console.error('Elemento #user-role no encontrado en el DOM');
          }

          // Actualizar estad√≠sticas en el sidebar
          const sidebarUserTeam = document.getElementById('sidebar-user-team');
          if (sidebarUserTeam) {
            sidebarUserTeam.textContent = user.team || 'Sin equipo';
          }

          // Recargar estad√≠sticas para el sidebar
          loadUserStatsForSidebar(user.username);
        }

        // Esperar a que el sidebar se cargue y luego actualizar la informaci√≥n
        document.addEventListener('sidebar:loaded', updateUserInfoInSidebar);
        
        // Tambi√©n intentar actualizar inmediatamente en caso de que el sidebar ya est√© cargado
        setTimeout(updateUserInfoInSidebar, 1000);

      } catch (e) {
        console.error('Error verificando autenticaci√≥n:', e);
        window.location.href = 'login.html';
      }
    });

    // Funci√≥n para cargar estad√≠sticas personales del usuario para el sidebar
    async function loadUserStatsForSidebar(username) {
      try {
        // Obtener datos de la colecci√≥n costumers (mismo endpoint que Costumer.html)
        const response = await fetch('/api/leads', {
          method: 'GET',
          credentials: 'include'
        });

        if (response.ok) {
          const data = await response.json();
          const leads = data.data || [];

          // Calcular estad√≠sticas del usuario actual
          const userLeads = leads.filter(lead => 
            lead.agenteNombre === username || 
            lead.agente === username ||
            lead.createdBy === username ||
            lead.ownerId === username
          );

          // Calcular ventas del mes actual - usando campos de costumers
          const currentMonth = new Date().getMonth();
          const currentYear = new Date().getFullYear();
          const monthlyLeads = userLeads.filter(lead => {
            const leadDate = new Date(lead.dia_venta || lead.fecha_contratacion || lead.createdAt || lead.fecha);
            return leadDate.getMonth() === currentMonth && leadDate.getFullYear() === currentYear;
          });

          // Actualizar estad√≠sticas en el sidebar
          const sidebarUserSales = document.getElementById('sidebar-user-sales');
          if (sidebarUserSales) {
            sidebarUserSales.textContent = monthlyLeads.length;
          }

          // TODOS los usuarios ven puntos (como admin)
          const userData = JSON.parse(localStorage.getItem('user') || sessionStorage.getItem('user') || '{}');
          const userRole = (userData.role || '').toLowerCase();
          const isAdminOrBackoffice = false; // FORZAR que todos vean puntos

          // TODOS calculan y muestran puntos
          if (true) {
            // Calcular puntos totales
            const totalPoints = userLeads.reduce((sum, lead) => {
              const points = parseFloat(lead.puntaje || lead.points || 0);
              return sum + points;
            }, 0);

            const sidebarUserPoints = document.getElementById('sidebar-user-points');
            if (sidebarUserPoints) {
              sidebarUserPoints.textContent = totalPoints.toFixed(1);
            }
          }
        }
      } catch (error) {
        console.log('Error cargando estad√≠sticas del usuario para sidebar:', error);
        // Mantener valores por defecto en caso de error
      }
    }

    // Funci√≥n para cargar datos del dashboard
    // Evitar cargas duplicadas desde otros m√≥dulos
    window.__dashboardLoading = window.__dashboardLoading || false;
    window.__dashboardLoaded = window.__dashboardLoaded || false;

    async function loadDashboardData(user) {
      if (window.__dashboardLoading || window.__dashboardLoaded) { return; }
      window.__dashboardLoading = true;
      try {
        console.log('üîÑ Cargando datos del dashboard...');
        
        // OPTIMIZACI√ìN: Intentar obtener datos ya precargados en login
        let dashboardData = window.dashboardManager?.getDisplayData();
        
        if (dashboardData) {
          // Usar datos del init-dashboard (ya est√°n en sessionStorage)
          console.log('üìä Usando datos precargados del init-dashboard');
          console.log('üìä Datos:', dashboardData);
          
          // Actualizar estad√≠sticas del usuario con datos optimizados
          await updateUserStats(dashboardData, user);
          
          // Crear gr√°ficos de forma diferida para no bloquear el primer render
          const deferCharts = () => { 
            try { 
              createChartsFromInitData(dashboardData); 
            } catch(_){} 
          };
          if ('requestIdleCallback' in window) { 
            requestIdleCallback(deferCharts, { timeout: 1200 }); 
          } else { 
            setTimeout(deferCharts, 300); 
          }
          
          window.__dashboardLoaded = true;
          return;
        }
        
        // FALLBACK: Si no hay datos precargados, hacer la petici√≥n antigua (compatible)
        console.warn('‚ö†Ô∏è  Datos precargados no disponibles, usando fallback a /api/leads');
        
        const response = await fetch('/api/leads', {
          method: 'GET',
          credentials: 'include'
        });

        if (response.ok) {
          const data = await response.json();
          const leads = data.data || [];
          
          console.log('üìä Datos cargados desde costumers:', leads.length, 'registros');
          console.log('üìä Estructura de datos:', leads[0] ? Object.keys(leads[0]) : 'Sin datos');
          console.log('üìä Ejemplo de registro:', leads[0] || 'Sin datos');
          
          // Actualizar estad√≠sticas del usuario
          await updateUserStats(leads, user);
          
          // Crear gr√°ficos de forma diferida para no bloquear el primer render
          const deferCharts = () => { try { createCharts(leads); } catch(_){} };
          if ('requestIdleCallback' in window) { requestIdleCallback(deferCharts, { timeout: 1200 }); }
          else { setTimeout(deferCharts, 300); }
          
        } else {
          console.error('Error cargando datos:', response.status);
        }
        window.__dashboardLoaded = true;
      } catch (error) {
        console.error('Error en loadDashboardData:', error.message || error);
        console.error('Stack trace:', error.stack);
      }
    }

    // Nueva funci√≥n para crear gr√°ficos desde datos del init-dashboard
    function createChartsFromInitData(dashboardData) {
      console.log('üìà Creando gr√°ficos desde datos optimizados...');
      
      if (dashboardData.chartTeams && dashboardData.chartTeams.length > 0) {
        createTeamsChartFromData(dashboardData.chartTeams);
      }
      
      if (dashboardData.chartProductos && dashboardData.chartProductos.length > 0) {
        createProductsChartFromData(dashboardData.chartProductos);
      }
      
      console.log('‚úÖ Gr√°ficos creados desde datos optimizados');
    }

    // Funci√≥n para crear gr√°fico de teams desde datos del init-dashboard
    function createTeamsChartFromData(teamsData) {
      try {
        const chartElement = document.getElementById('teamsChart');
        if (!chartElement) {
          console.warn('‚ö†Ô∏è  Elemento teamsChart no encontrado en el DOM');
          return;
        }

        const labels = teamsData.map(t => t.nombre);
        const counts = teamsData.map(t => t.count);

        const ctx = chartElement.getContext('2d');

        // Destruir gr√°fico anterior si existe
        if (teamsChartRefMain && teamsChartRefMain.destroy) {
          teamsChartRefMain.destroy();
        }

        const colors = ['#4f46e5', '#7c3aed', '#ec4899', '#f59e0b', '#10b981'];
        teamsChartRefMain = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: labels,
            datasets: [{
              data: counts,
              backgroundColor: colors.slice(0, counts.length),
              borderColor: '#fff',
              borderWidth: 2,
              borderRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                position: 'bottom',
                labels: { font: { size: 12 }, padding: 15 }
              }
            }
          }
        });
        console.log('‚úÖ Gr√°fico de teams creado');
      } catch (e) {
        console.error('Error creando gr√°fico de teams:', e);
      }
    }

    // Funci√≥n para crear gr√°fico de productos desde datos del init-dashboard
    function createProductsChartFromData(productsData) {
      try {
        const chartElement = document.getElementById('salesChart');
        if (!chartElement) {
          console.warn('‚ö†Ô∏è  Elemento salesChart no encontrado en el DOM');
          return;
        }

        const labels = productsData.map(p => p.servicio);
        const counts = productsData.map(p => p.count);

        const ctx = chartElement.getContext('2d');

        // Destruir gr√°fico anterior si existe
        if (salesChartRef && salesChartRef.destroy) {
          salesChartRef.destroy();
        }

        salesChartRef = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [{
              label: 'Productos Vendidos',
              data: counts,
              backgroundColor: '#4f46e5',
              borderColor: '#3730a3',
              borderWidth: 1,
              borderRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            indexAxis: 'y',
            plugins: {
              legend: { display: false }
            },
            scales: {
              x: { beginAtZero: true }
            }
          }
        });
        console.log('‚úÖ Gr√°fico de productos creado');
      } catch (e) {
        console.error('Error creando gr√°fico de productos:', e);
      }
    }

    // Funci√≥n para actualizar el mejor vendedor
    async function updateBestSeller() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        const headers = { 'Accept': 'application/json' };
        if (token) headers['Authorization'] = `Bearer ${token}`;
        // Usar el endpoint de ranking para garantizar el mismo primer lugar que ven los administradores
        const res = await fetch('/api/ranking?limit=1', { method: 'GET', headers, credentials: 'include', cache: 'no-store' });
        if (!res.ok) {
          console.warn('[KPI][BestSeller] ranking no OK', res.status, res.statusText);
          return;
        }
        const data = await res.json().catch(() => ({}));
        // Soportar diferentes formatos: {ranking:[]}, {data:{ranking:[]}}, o array directo
        let arr = [];
        if (Array.isArray(data)) arr = data;
        else if (Array.isArray(data.ranking)) arr = data.ranking;
        else if (data && data.data && Array.isArray(data.data.ranking)) arr = data.data.ranking;

        const top = Array.isArray(arr) && arr.length ? (arr[0].nombre || arr[0].name || '-') : '-';
        const el = document.getElementById('best-seller-name');
        if (el) el.textContent = top || '-';
      } catch (e) {
        console.error('[KPI][BestSeller] Error obteniendo ranking:', e);
      }
    }

    // Funci√≥n para actualizar estad√≠sticas del usuario
    async function updateUserStats(leadsOrDashboardData, user) {
      const currentMonth = new Date().getMonth();
      const currentYear = new Date().getFullYear();
      
      const userRole = (user.role || '').toLowerCase();
      const isAdminOrBackoffice = ['admin','administrator','administrador','administradora','backoffice','bo','supervisor'].some(r=>userRole.includes(r));

      // Mostrar TODOS los KPIs para todos los usuarios
      const pointsCard = document.getElementById('points-stat-card');
      const teamCard = document.getElementById('team-stat-card');
      const rankingCard = document.getElementById('ranking-stat-card');
      const cancelledCard = document.getElementById('cancelled-stat-card');
      const pendingCard = document.getElementById('pending-stat-card');
      
      // Mostrar tarjetas seg√∫n rol
      if (pointsCard) pointsCard.style.display = 'flex';
      if (teamCard) teamCard.style.display = 'flex';
      if (rankingCard) rankingCard.style.display = 'flex';
      if (cancelledCard) cancelledCard.style.display = isAdminOrBackoffice ? 'flex' : 'none';
      if (pendingCard) pendingCard.style.display = isAdminOrBackoffice ? 'flex' : 'none';
      
      // Detectar si son datos del init-dashboard o leads normales
      const isInitData = leadsOrDashboardData && leadsOrDashboardData.kpis && !Array.isArray(leadsOrDashboardData);
      
      if (isInitData) {
        // CASO 1: Datos del init-dashboard (optimizados)
        console.log('‚úÖ Usando datos optimizados del init-dashboard');
        const dashData = leadsOrDashboardData;
        
        if (isAdminOrBackoffice) {
          // Admin/Backoffice: usar datos precalculados
          document.getElementById('user-sales-count').textContent = dashData.kpis.ventas;
          document.getElementById('cancelled-count').textContent = dashData.kpis.canceladas;
          document.getElementById('pending-count').textContent = dashData.kpis.pendientes;
        } else {
          // Agente: usar estad√≠sticas personales
          const el1=document.getElementById('user-sales-count'); 
          if(el1) el1.textContent = dashData.userStats.ventasUsuario;
          const el2=document.getElementById('user-points-total'); 
          if(el2) el2.textContent = dashData.userStats.puntosUsuario.toFixed(2).replace(/\.00$/,'');
          document.getElementById('user-team-name').textContent = dashData.userStats.equipoUsuario;
          document.getElementById('user-ranking').textContent = dashData.userStats.rankingUsuario;
        }
      } else {
        // CASO 2: Leads normales (fallback)
        console.log('‚ö†Ô∏è  Usando datos de leads normales (fallback)');
        const leads = leadsOrDashboardData || [];
        
        if (isAdminOrBackoffice) {
          // Para Admin/Backoffice: calcular m√©tricas globales
          const allLeads = leads;
          
          const monthlySales = allLeads.filter(lead => {
            const leadDate = new Date(lead.dia_venta || lead.fecha_contratacion || lead.createdAt || lead.fecha);
            return leadDate.getMonth() === currentMonth && leadDate.getFullYear() === currentYear;
          }).length;
          
          const cancelledSales = allLeads.filter(lead => {
            const leadDate = new Date(lead.dia_venta || lead.fecha_contratacion || lead.createdAt || lead.fecha);
            const isThisMonth = leadDate.getMonth() === currentMonth && leadDate.getFullYear() === currentYear;
            const status = (lead.status || '').toLowerCase();
            return isThisMonth && (status.includes('cancel') || status.includes('anulad') || status === 'cancelado');
          }).length;
          
          const pendingSales = allLeads.filter(lead => {
            const leadDate = new Date(lead.dia_venta || lead.fecha_contratacion || lead.createdAt || lead.fecha);
            const isThisMonth = leadDate.getMonth() === currentMonth && leadDate.getFullYear() === currentYear;
            const status = (lead.status || '').toLowerCase();
            return isThisMonth && (status.includes('pend') || status.includes('espera') || status === 'pendiente');
          }).length;
          
          document.getElementById('user-sales-count').textContent = monthlySales;
          document.getElementById('cancelled-count').textContent = cancelledSales;
          document.getElementById('pending-count').textContent = pendingSales;
          
        } else {
          // Para Agentes: calcular m√©tricas personales
          const uname = (user.username||'').toString().trim().toLowerCase();
          const userLeads = leads.filter(lead => {
            const a = (lead.agenteNombre||'').toString().trim().toLowerCase();
            const b = (lead.agente||'').toString().trim().toLowerCase();
            const c = (lead.usuario||'').toString().trim().toLowerCase();
            return a===uname || b===uname || c===uname;
          });
          
          const userMonthlySales = userLeads.filter(lead => {
            const leadDate = new Date(lead.dia_venta || lead.fecha_contratacion || lead.createdAt || lead.fecha);
            return leadDate.getMonth() === currentMonth && leadDate.getFullYear() === currentYear;
          }).length;
          
          const userTotalPoints = userLeads.reduce((sum, lead) => {
            return sum + parseFloat(lead.puntaje || lead.points || 0);
          }, 0);
          
          const el1=document.getElementById('user-sales-count'); if(el1) el1.textContent = userMonthlySales;
          const el2=document.getElementById('user-points-total'); if(el2) el2.textContent = userTotalPoints.toFixed(2).replace(/\.00$/,'');
          document.getElementById('user-team-name').textContent = user.team || 'Sin equipo';
          
          const allAgents = [...new Set(leads.map(lead => lead.agenteNombre || lead.agente).filter(Boolean))];
          const userRanking = Math.floor(Math.random() * allAgents.length) + 1;
          document.getElementById('user-ranking').textContent = `#${userRanking}`;
        }
      }
      
      console.log(`üîç KPIs configurados - Usuario: ${user.username}, Rol: ${userRole}, Admin/BO: ${isAdminOrBackoffice}`);
    }

    // Variables globales para rastrear gr√°ficos
    let salesChartRef = null;
    let teamsChartRefMain = null;

    // Funci√≥n para crear gr√°ficos
    async function createCharts(leads) {
      // Gr√°fico de ventas por mes
      createSalesChart(leads);
      
      // Gr√°fico de distribuci√≥n por teams
      createTeamsChart(leads);
    }

    function createSalesChart(leads) {
      const chartElement = document.getElementById('salesChart');
      if (!chartElement) {
        console.warn('‚ö†Ô∏è Elemento salesChart no encontrado en el DOM, saltando creaci√≥n del gr√°fico');
        return;
      }
      
      // Destruir gr√°fico existente si existe (manejar registro interno de Chart.js)
      try {
        const existing = Chart.getChart(chartElement);
        if (existing) {
          existing.destroy();
        }
      } catch (e) {
        console.warn('Error al destruir gr√°fico salesChart desde registry:', e);
      }
      salesChartRef = null;

      const ctx = chartElement.getContext('2d');
      
      // Preparar datos por mes (√∫ltimos 6 meses)
      const months = [];
      const salesData = [];
      const currentDate = new Date();
      
      for (let i = 5; i >= 0; i--) {
        const date = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
        const monthName = date.toLocaleDateString('es-ES', { month: 'short' });
        months.push(monthName);
        
        const monthlySales = leads.filter(lead => {
          const leadDate = new Date(lead.fecha_contratacion || lead.createdAt || lead.fecha);
          return leadDate.getMonth() === date.getMonth() && leadDate.getFullYear() === date.getFullYear();
        }).length;
        
        salesData.push(monthlySales);
      }
      
      // Instanciar chart fuera del hilo cr√≠tico
      salesChartRef = new Chart(ctx, {
        type: 'line',
        data: {
          labels: months,
          datasets: [{
            label: 'Ventas',
            data: salesData,
            borderColor: '#667eea',
            backgroundColor: 'rgba(102, 126, 234, 0.1)',
            borderWidth: 3,
            fill: true,
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(0,0,0,0.1)'
              }
            },
            x: {
              grid: {
                display: false
              }
            }
          }
        }
      });
    }

    function createTeamsChart(leads) {
      const chartElement = document.getElementById('teamsChart');
      if (!chartElement) {
        console.warn('‚ö†Ô∏è Elemento teamsChart no encontrado en el DOM, saltando creaci√≥n del gr√°fico');
        return;
      }

      // Destruir gr√°fico existente si existe (usar Chart.getChart para cubrir todos los casos)
      try {
        const existing = Chart.getChart(chartElement);
        if (existing) {
          existing.destroy();
        }
      } catch (e) {
        console.warn('Error al destruir gr√°fico teamsChart desde registry:', e);
      }
      // Limpieza de referencias locales
      try { if (chartElement.__chartInstance) chartElement.__chartInstance = null; } catch(_) {}
      try { if (teamsChartRefMain) { teamsChartRefMain = null; } } catch(_) {}

      const ctx = chartElement.getContext('2d');

      // Contar leads por team
      const teamCounts = {};
      leads.forEach(lead => {
        const team = lead.team || lead.supervisor || 'Sin Team';
        teamCounts[team] = (teamCounts[team] || 0) + 1;
      });

      const teams = Object.keys(teamCounts);
      const counts = Object.values(teamCounts);
      const colors = [
        '#667eea', '#f093fb', '#4facfe', '#43e97b', 
        '#fa709a', '#feb47b', '#a8edea', '#d299c2'
      ];

      teamsChartRefMain = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: teams,
          datasets: [{
            data: counts,
            backgroundColor: colors.slice(0, teams.length),
            borderWidth: 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                padding: 20,
                usePointStyle: true
              }
            }
          }
        }
      });
      chartElement.__chartInstance = teamsChartRefMain;
    }

    // Debug: Verificar elementos del sidebar
    console.log('Verificando elementos del sidebar...');
  </script>
  <script src="js/core/dashboard.js"></script>
  <script src="js/ranking.js"></script>
</head>
<body>
  <div class="layout">
    <!-- SIDEBAR (cargado din√°micamente) -->
    <nav class="sidebar sidebar-inicio" data-active="inicio"></nav>
    <main class="main-content">
      
      <!-- Panel de Bienvenida del Usuario -->
      <div class="user-welcome-panel">
        <div class="welcome-header">
          <div class="welcome-avatar">
            <i class="fas fa-user-circle"></i>
          </div>
          <div class="welcome-info">
            <h2 id="welcome-user-name">Bienvenido/a</h2>
            <p id="welcome-user-role">Cargando...</p>
          </div>
        </div>
        <div class="welcome-stats" style="display:none;">
          <div class="stat-card">
            <div class="stat-icon">
              <i class="fas fa-chart-line"></i>
            </div>
            <div class="stat-info">
              <div class="stat-number" id="user-sales-count">0</div>
              <div class="stat-label">Ventas este mes</div>
            </div>
          </div>
          <!-- KPI Puntos (solo agentes) -->
          <div class="stat-card" id="points-stat-card">
            <div class="stat-icon">
              <i class="fas fa-star"></i>
            </div>
            <div class="stat-info">
              <div class="stat-number" id="user-points-total">0</div>
              <div class="stat-label">Puntos totales</div>
            </div>
          </div>
          
          <!-- KPI Canceladas (solo admin/backoffice) -->
          <div class="stat-card" id="cancelled-stat-card" style="display: none;">
            <div class="stat-icon" style="color: #ef4444;">
              <i class="fas fa-times-circle"></i>
            </div>
            <div class="stat-info">
              <div class="stat-number" id="cancelled-count">0</div>
              <div class="stat-label">Canceladas</div>
            </div>
          </div>

          <!-- KPI Equipo (solo agentes) -->
          <div class="stat-card" id="team-stat-card">
            <div class="stat-icon">
              <i class="fas fa-users"></i>
            </div>
            <div class="stat-info">
              <div class="stat-number" id="user-team-name">-</div>
              <div class="stat-label">Equipo</div>
            </div>
          </div>
          
          <!-- KPI Pendientes (solo admin/backoffice) -->
          <div class="stat-card" id="pending-stat-card" style="display: none;">
            <div class="stat-icon" style="color: #f59e0b;">
              <i class="fas fa-clock"></i>
            </div>
            <div class="stat-info">
              <div class="stat-number" id="pending-count">0</div>
              <div class="stat-label">Ventas pendientes</div>
            </div>
          </div>

          <!-- KPI Ranking (solo agentes) -->
          <div class="stat-card" id="ranking-stat-card">
            <div class="stat-icon">
              <i class="fas fa-trophy"></i>
            </div>
            <div class="stat-info">
              <div class="stat-number" id="user-ranking">-</div>
              <div class="stat-label">Posici√≥n</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Dashboard Metrics -->
      <div class="dashboard-metrics">
        <div class="metrics-grid">
          <div class="metric-card">
            <div class="metric-icon leads">
              <i class="fas fa-user-plus"></i>
            </div>
            <div class="metric-info">
              <div class="metric-number" id="month-sales-count">0</div>
              <div class="metric-label">Ventas totales del mes</div>
              <div class="metric-change positive" id="kpi1-change" style="display:none">+0%</div>
            </div>
          </div>
          
          <div class="metric-card">
            <div class="metric-icon sales">
              <i class="fas fa-handshake"></i>
            </div>
            <div class="metric-info">
              <div class="metric-number" id="month-points-total">0</div>
              <div class="metric-label">Puntos totales</div>
              <div class="metric-change positive" id="kpi2-change" style="display:none">+0%</div>
            </div>
          </div>
          
          <div class="metric-card">
            <div class="metric-icon conversion">
              <i class="fas fa-percentage"></i>
            </div>
            <div class="metric-info">
              <div class="metric-number" id="best-team-name">-</div>
              <div class="metric-label">Mejor Team del mes</div>
              <div class="metric-change positive" id="kpi3-change" style="display:none">+0%</div>
            </div>
          </div>
          
          <div class="metric-card">
            <div class="metric-icon revenue">
              <i class="fas fa-dollar-sign"></i>
            </div>
            <div class="metric-info">
              <div class="metric-number" id="best-seller-name">-</div>
              <div class="metric-label">Mejor vendedor del mes</div>
              <div class="metric-change positive" id="kpi4-change" style="display:none">+0%</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Charts Section -->
      <div class="charts-section">
        <div class="charts-grid">
          <div class="chart-card">
            <div class="chart-header">
              <h3>Productos vendidos en el mes</h3>
              <div class="chart-controls" style="display:none"></div>
            </div>
            <div class="chart-container">
              <canvas id="productsChart"></canvas>
            </div>
          </div>
          
          <div class="chart-card">
            <div class="chart-header">
              <h3>Distribuci√≥n por Team</h3>
            </div>
            <div class="chart-container">
              <canvas id="teamsChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Secci√≥n del Mapa de Clientes -->
      <div class="map-section">
        <div class="map-header">
          <h3><i class="fas fa-map-marked-alt"></i> Distribuci√≥n de Clientes en Estados Unidos</h3>
          <p>Ubicaciones de nuestros clientes y estad√≠sticas por estado</p>
        </div>
        
        <div class="map-container">
          <!-- Mapa -->
          <div class="map-wrapper" id="map-wrapper">
            <button id="expand-map-btn" class="expand-map-btn" onclick="toggleMapFullscreen()" title="Expandir mapa">
              <i class="fas fa-expand"></i>
            </button>
            <div id="usa-map" class="map-canvas"></div>
          </div>
          
          <!-- Panel lateral con estad√≠sticas -->
          <div class="map-stats">
            <div class="stats-header">
              <h4>Clientes por Estado</h4>
            </div>
            
            <div class="stats-list" id="states-stats">
              <!-- Se llenar√° din√°micamente -->
            </div>
          </div>
        </div>
      </div>

      <!-- Quick Actions -->
      <div class="quick-actions">
        <h3>Acciones R√°pidas</h3>
        <div class="actions-grid">
          <a href="lead.html" class="action-card">
            <div class="action-icon">
              <i class="fas fa-plus-circle"></i>
            </div>
            <div class="action-info">
              <h4>Nuevo Lead</h4>
              <p>Registrar cliente potencial</p>
            </div>
          </a>
          
          <a href="Costumer.html" class="action-card">
            <div class="action-icon">
              <i class="fas fa-search"></i>
            </div>
            <div class="action-info">
              <h4>Ver Clientes</h4>
              <p>Gestionar base de datos</p>
            </div>
          </a>
          
          <a href="Estadisticas.html" class="action-card">
            <div class="action-icon">
              <i class="fas fa-chart-bar"></i>
            </div>
            <div class="action-info">
              <h4>Estad√≠sticas</h4>
              <p>An√°lisis detallado</p>
            </div>
          </a>
          
          <a href="empleado-del-mes.html" class="action-card">
            <div class="action-icon">
              <i class="fas fa-award"></i>
            </div>
            <div class="action-info">
              <h4>Empleado del Mes</h4>
              <p>Reconocimientos</p>
            </div>
          </a>
        </div>
      </div>

  <!-- Scripts al final del body para mejor rendimiento -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js" defer></script>
  <script src="js/inactivity-manager.js" defer></script>
  <script src="agentes/js/auth-check.js" defer></script>
  <script src="js/crm-init.js" defer></script>
</main>
  </div>

  <!-- Sidebar unified scripts -->
  <script src="js/auth-logout.js" defer></script>
  <script src="js/user-info-updater.js" defer></script>
  <script src="js/sidebar-loader.js" defer></script>
  
  <!-- Script inmediato para normalizar multimedia -->
  <script>
    // Funci√≥n global para normalizar multimedia
    window.forceNormalizeMultimedia = function() {
      console.log('üé¨ [INICIO] Ejecutando normalizaci√≥n inmediata de multimedia...');
      
      const multimediaElements = document.querySelectorAll(
        '.sidebar a[href*="multimedia"], .sidebar .btn-sidebar[href*="multimedia"], a[title*="Multimedia"]'
      );
      
      console.log('üé¨ [INICIO] Elementos multimedia encontrados:', multimediaElements.length);
      
      if (multimediaElements.length === 0) {
        // Intentar con selectores m√°s amplios
        const allSidebarLinks = document.querySelectorAll('.sidebar a, .sidebar .btn-sidebar');
        console.log('üé¨ [INICIO] Total elementos sidebar:', allSidebarLinks.length);
        
        allSidebarLinks.forEach((el, i) => {
          const text = el.textContent?.trim().toLowerCase();
          const href = el.href || '';
          if (text.includes('multimedia') || href.includes('multimedia')) {
            console.log(`üé¨ [INICIO] Encontrado multimedia por texto/href ${i}:`, el);
            window.normalizeElement(el);
          }
        });
      } else {
        multimediaElements.forEach((el, i) => {
          console.log(`üé¨ [INICIO] Normalizando elemento ${i}:`, el);
          window.normalizeElement(el);
        });
      }
    };
    
    window.normalizeElement = function(element) {
      // Remover estilos inline
      element.style.cssText = '';
      
      // Normalizar el √≠cono
      const icon = element.querySelector('i');
      if (icon) {
        icon.style.cssText = '';
        icon.style.setProperty('font-weight', '900', 'important');
        icon.style.setProperty('font-size', '1.1rem', 'important');
        icon.style.setProperty('color', 'inherit', 'important');
        icon.style.setProperty('text-shadow', 'none', 'important');
        icon.style.setProperty('opacity', '1', 'important');
        icon.style.setProperty('background', 'none', 'important');
        icon.style.setProperty('border', 'none', 'important');
        icon.style.setProperty('box-shadow', 'none', 'important');
        icon.style.setProperty('filter', 'none', 'important');
        
        console.log('üé¨ [INICIO] √çcono normalizado:', {
          element: icon,
          fontWeight: icon.style.fontWeight,
          fontSize: icon.style.fontSize
        });
      }
    };
    
    // Ejecutar inmediatamente y luego cada segundo hasta que funcione
    let attempts = 0;
    const maxAttempts = 10;
    
    const intervalId = setInterval(() => {
      attempts++;
      console.log(`üé¨ [INICIO] Intento ${attempts}/${maxAttempts}`);
      
      window.forceNormalizeMultimedia();
      
      if (attempts >= maxAttempts) {
        clearInterval(intervalId);
        console.log('üé¨ [INICIO] M√°ximo de intentos alcanzado');
      }
    }, 1000);
    
    // Tambi√©n ejecutar cuando se dispare el evento de sidebar cargado
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(window.forceNormalizeMultimedia, 2000);
      setTimeout(window.forceNormalizeMultimedia, 5000);
    });
  </script>
  
  <script>
    // KPIs y Gr√°fica: Productos vendidos en el mes
    (function(){
      const SOLD = new Set(['vendido','cerrado','aprobado','approved','sold','closed']);
      const now = new Date(); const M = now.getMonth(); const Y = now.getFullYear();

      function pickDate(lead){
        return new Date(lead.dia_venta || lead.fecha_contratacion || lead.createdAt || lead.fecha);
      }

      function updateKPIs(leads){
        const monthly = leads.filter(l => { const d = pickDate(l); return d.getMonth()===M && d.getFullYear()===Y; });
        const soldMonthly = monthly.filter(l => SOLD.has(String(l.status||'').toLowerCase()));

        // Ventas totales del mes (usar todos los leads del mes para asegurar dato real)
        const ventasMes = monthly.length;
        // Puntos totales del mes
        const puntosMes = monthly.reduce((s,l)=>s+(parseFloat(l.puntaje||l.points||0)||0),0);
        // Mejor team del mes
        const teamCounts = {}; monthly.forEach(l=>{ const t=l.team||l.TEAM||'Sin equipo'; teamCounts[t]=(teamCounts[t]||0)+1;});
        let bestTeam = Object.entries(teamCounts).sort((a,b)=>b[1]-a[1])[0]?.[0] || '-';
        bestTeam = formatTeam(bestTeam);
        // Mejor vendedor del mes
        const sellerCounts={}; monthly.forEach(l=>{ const a=getAgentName(l); sellerCounts[a]=(sellerCounts[a]||0)+1;});
        const bestSeller = Object.entries(sellerCounts).sort((a,b)=>b[1]-a[1])[0]?.[0] || '-';

        const q=(id,v)=>{const el=document.getElementById(id); if(el) el.textContent=v;};
        q('month-sales-count', ventasMes);
        q('month-points-total', (puntosMes||0).toFixed(2).replace(/\.00$/,''));
        q('best-team-name', bestTeam);
        // NO TOCAR best-seller-name - se maneja en updateBestSeller
      }

      function formatTeam(name){
        const n = String(name||'').trim();
        const cleaned = n.replace(/^team\s+/i,'').toUpperCase();
        return cleaned ? `TEAM ${cleaned}` : 'TEAM -';
      }

      let productsChartRef=null;
      function renderProducts(leads){
        let monthSales = leads.filter(l=>{ const d=pickDate(l); return d.getMonth()===M && d.getFullYear()===Y && SOLD.has(String(l.status||'').toLowerCase());});
        // Si no hay registros con estado de venta, usar todos los del mes para no dejar la gr√°fica vac√≠a
        if (monthSales.length === 0) {
          monthSales = leads.filter(l=>{ const d=pickDate(l); return d.getMonth()===M && d.getFullYear()===Y;});
        }
        const getProd=(l)=>{ const v=l.servicios_texto||l.tipo_servicios||l.tipo_servicio||l.servicios||l.producto||l.product||l.service||l.servicio||''; return v?String(v).replace(/[-_]/g,' ').toUpperCase():'SIN PRODUCTO'; };
        const counts={}; monthSales.forEach(l=>{ const k=getProd(l); counts[k]=(counts[k]||0)+1; });
        const entries=Object.entries(counts).sort((a,b)=>b[1]-a[1]);
        const labels=entries.map(e=>e[0]); const data=entries.map(e=>e[1]);
        const canvas=document.getElementById('productsChart'); if(!canvas) return; const ctx=canvas.getContext('2d');
        if(productsChartRef){ try{productsChartRef.destroy();}catch(e){} }
        productsChartRef=new Chart(ctx,{ type:'bar', data:{ labels, datasets:[{ label:'Cantidad', data, backgroundColor:'rgba(54,162,235,.7)', borderColor:'rgba(54,162,235,1)', borderWidth:1, borderRadius:4 }] }, options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{ display:false } }, scales:{ y:{ beginAtZero:true, ticks:{ stepSize:1 } }, x:{ ticks:{ autoSkip:false, maxRotation:45, minRotation:45 } } } } });
      }

      function getCurrentMonthRange(){
        const start = new Date(Date.UTC(Y, M, 1));
        const end = new Date();
        const yyyyS = start.getUTCFullYear(); const mmS = String(start.getUTCMonth()+1).padStart(2,'0'); const ddS = String(start.getUTCDate()).padStart(2,'0');
        const yyyyE = end.getUTCFullYear(); const mmE = String(end.getUTCMonth()+1).padStart(2,'0'); const ddE = String(end.getUTCDate()).padStart(2,'0');
        return { inicio: `${yyyyS}-${mmS}-${ddS}`, fin: `${yyyyE}-${mmE}-${ddE}` };
      }

      async function loadMonthlyTeamStats(){
        try{
          const token = localStorage.getItem('token') || sessionStorage.getItem('token');
          const headers = { 'Accept':'application/json', 'Cache-Control':'no-cache' };
          if (token) headers['Authorization'] = `Bearer ${token}`;
          const {inicio, fin} = getCurrentMonthRange();
          const url = `/api/equipos/estadisticas?fechaInicio=${encodeURIComponent(inicio)}&fechaFin=${encodeURIComponent(fin)}`;
          const res = await fetch(url, { headers, credentials:'include' });
          if (!res.ok) { console.warn('equipos/estadisticas no OK', res.status); return null; }
          const data = await res.json();
          return data && data.data ? data.data : null;
        } catch(e){ console.warn('Error obteniendo estadisticas equipos', e); return null; }
      }

      async function loadLeads(){
        try{
          const token = localStorage.getItem('token') || sessionStorage.getItem('token');
          const headers = { 'Accept':'application/json', 'Cache-Control':'no-cache' };
          if (token) headers['Authorization'] = `Bearer ${token}`;
          const res=await fetch('/api/leads',{ method:'GET', credentials:'include', headers });
          if(!res.ok){ console.warn('API /api/leads no OK', res.status); return; }
          const json=await res.json(); const leads=json?.data||json?.leads||json||[];
          // Calcular KPIs: si es admin/BO/supervisor usar estad√≠stica por equipos; si es agente usar solo sus leads (backend ya filtra)
          let isAdminOrBO = false;
          try { const u = JSON.parse(localStorage.getItem('user')||sessionStorage.getItem('user')||'{}'); const r=(u.role||'').toLowerCase(); isAdminOrBO=['admin','administrator','administrador','administradora','backoffice','bo','supervisor'].some(x=>r.includes(x)); } catch{}
          if (isAdminOrBO){
            const equipos = await loadMonthlyTeamStats();
            if (Array.isArray(equipos) && equipos.length){
              const totalVentas = equipos.reduce((s,e)=> s + (parseFloat(e.Total)||0), 0);
              const totalPuntos = equipos.reduce((s,e)=> s + (parseFloat(e.Puntaje)||0), 0);
              const k1 = document.getElementById('month-sales-count'); if (k1) k1.textContent = totalVentas;
              const k2 = document.getElementById('month-points-total'); if (k2) k2.textContent = totalPuntos.toFixed(2).replace(/\.00$/,'');
              const best = [...equipos].sort((a,b)=> (parseFloat(b.Total||0))-(parseFloat(a.Total||0)))[0];
              const teamName = formatTeam(best?.TEAM || best?.name || '-');
              const elTeam = document.getElementById('best-team-name'); if (elTeam) elTeam.textContent = teamName;
            } else {
              updateKPIs(leads);
            }
          } else {
            // Agente: usar directamente leads (ya filtrados por backend al agente)
            updateKPIs(leads);
          }
          
          // Mejor vendedor del mes seg√∫n RANKING (sumatoria de puntos del mes)
          // IMPORTANTE: Esto debe ejecutarse DESPU√âS de updateKPIs para no ser sobrescrito
          setTimeout(() => {
            const monthly = leads.filter(l => { const d = pickDate(l); return d.getMonth()===M && d.getFullYear()===Y; });
            const sellerAgg = {};
            monthly.forEach(l=>{
              const a = getAgentName(l);
              const pts = parseFloat(l.puntaje || l.points || l.Puntos || 0) || 0;
              if (!sellerAgg[a]) sellerAgg[a] = { puntos: 0, ventas: 0 };
              sellerAgg[a].puntos += pts;
              sellerAgg[a].ventas += 1;
            });
            
            let bestSeller = '-';
            if (Object.keys(sellerAgg).length){
              // Filtrar nombres v√°lidos (no DESCONOCIDO)
              const validSellers = Object.entries(sellerAgg).filter(([name]) => name !== 'DESCONOCIDO');
              if (validSellers.length > 0) {
                const sortedSellers = validSellers.sort(([,A],[,B]) => (B.puntos - A.puntos) || (B.ventas - A.ventas));
                bestSeller = sortedSellers[0][0];
              }
            }
            
            // NO ACTUALIZAR AQU√ç - se maneja en updateBestSeller
          }, 100);

          renderProducts(leads);
          renderTeamsChart(leads);
        }catch(e){ console.error('Error cargando leads para inicio:', e); }
      }

      function getAgentName(l){
        const candidates = [
          l.agenteNombre, l.agente, l.AGENTE, l.vendedor, l.VENDEDOR,
          l.createdBy, l.ownerId, l.username, l.user, l.name, l.NOMBRE
        ];
        const value = candidates.find(v => typeof v === 'string' && v.trim().length > 0) || null;
        return value ? String(value).trim() : 'DESCONOCIDO';
      }

      function renderTeamsChart(leads){
        const monthly = leads.filter(l => { const d = pickDate(l); return d.getMonth()===M && d.getFullYear()===Y; });
        if (!monthly.length) return;
        const counts = {};
        monthly.forEach(l=>{ const t = l.team || l.TEAM || l.supervisor || 'Sin equipo'; counts[t] = (counts[t]||0)+1; });
        const labels = Object.keys(counts);
        const data = Object.values(counts);
        const canvas = document.getElementById('teamsChart');
        if (!canvas) return;

        // Destruir gr√°fico existente usando Chart.getChart()
        const existingChart = Chart.getChart(canvas);
        if (existingChart) {
          existingChart.destroy();
        }

        // Destruir instancia global si existe
        if (window.teamsChartRefMain) { 
          try { window.teamsChartRefMain.destroy(); } catch(_) {} 
          window.teamsChartRefMain = null;
        }

        const ctx = canvas.getContext('2d');
        const palette = ['#667eea','#f093fb','#4facfe','#43e97b','#fa709a','#feb47b','#a8edea','#d299c2','#5ee7df','#b490ca'];
        window.teamsChartRefMain = new Chart(ctx, {
          type: 'doughnut',
          data: { labels, datasets: [{ data, backgroundColor: palette.slice(0, labels.length), borderWidth: 0 }] },
          options: { responsive:true, maintainAspectRatio:false, plugins:{ legend:{ position:'bottom', labels:{ usePointStyle:true, padding: 20 } } } }
        });
      }

      // Evitar doble carga si otro m√≥dulo ya inici√≥
      const startLoad = () => { if (!window.__dashboardLoading && !window.__dashboardLoaded) loadLeads(); };
      if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', startLoad); else startLoad();
    })();
  </script>

  <!-- Leaflet CSS y JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <!-- Leaflet MarkerCluster para optimizaci√≥n -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
  
  <!-- Funciones adicionales del mapa -->
  <script src="map-functions.js"></script>

  <style>
    /* Estilos para la secci√≥n del mapa */
    .map-section {
      width: 100%;
      max-width: 1400px;
      margin: 40px auto 0;
      padding: 0 20px;
      margin-bottom: 0;
    }

    .map-header {
      text-align: center;
      margin-bottom: 30px;
    }

    .map-header h3 {
      font-size: 2rem;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    .map-header h3 i {
      color: #3b82f6;
    }

    .map-header p {
      font-size: 1.1rem;
      color: #64748b;
      margin: 0;
    }

    .map-container {
      display: flex;
      gap: 20px;
      background: white;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      min-height: 600px;
    }

    .map-wrapper {
      flex: 2;
      position: relative;
      transition: all 0.3s ease;
    }

    .map-canvas {
      width: 100%;
      height: 600px;
      border-radius: 20px 0 0 20px;
    }

    .map-stats {
      flex: 1;
      padding: 30px;
      background: #f8fafc;
      display: flex;
      flex-direction: column;
    }

    .stats-header {
      margin-bottom: 25px;
      text-align: center;
    }

    .stats-header h4 {
      font-size: 1.3rem;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 15px;
    }

    .stats-list {
      height: 520px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-right: 8px;
    }

    .stats-list::-webkit-scrollbar {
      width: 6px;
    }

    .stats-list::-webkit-scrollbar-track {
      background: #f1f5f9;
      border-radius: 3px;
    }

    .stats-list::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }

    .stats-list::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    .state-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .state-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .state-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .state-flag {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 0.8rem;
      font-weight: 600;
    }

    .state-details {
      display: flex;
      flex-direction: column;
    }

    .state-name {
      font-weight: 600;
      color: #1e293b;
      font-size: 0.95rem;
    }

    .state-code {
      font-size: 0.8rem;
      color: #64748b;
    }

    .state-stats {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .client-count {
      font-weight: 700;
      color: #3b82f6;
      font-size: 1.1rem;
    }

    .client-percentage {
      font-size: 0.8rem;
      color: #64748b;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .map-container {
        flex-direction: column;
        min-height: auto;
      }

      .map-canvas {
        height: 400px;
        border-radius: 20px 20px 0 0;
      }

      .map-stats {
        border-radius: 0 0 20px 20px;
      }
    }

    @media (max-width: 768px) {
      .map-section {
        padding: 0 15px;
      }

      .map-header h3 {
        font-size: 1.5rem;
      }

      .map-container {
        border-radius: 15px;
      }

      .map-canvas {
        height: 300px;
      }

      .map-stats {
        padding: 20px;
      }

      .total-number {
        font-size: 2rem;
      }
    }

    /* Estilos personalizados para clusters */
    .marker-cluster-small {
      background-color: rgba(59, 130, 246, 0.6);
      border: 2px solid rgba(59, 130, 246, 0.8);
    }
    .marker-cluster-small div {
      background-color: rgba(59, 130, 246, 0.8);
      color: white;
      font-weight: bold;
    }

    .marker-cluster-medium {
      background-color: rgba(245, 158, 11, 0.6);
      border: 2px solid rgba(245, 158, 11, 0.8);
    }
    .marker-cluster-medium div {
      background-color: rgba(245, 158, 11, 0.8);
      color: white;
      font-weight: bold;
    }

    .marker-cluster-large {
      background-color: rgba(239, 68, 68, 0.6);
      border: 2px solid rgba(239, 68, 68, 0.8);
    }
    .marker-cluster-large div {
      background-color: rgba(239, 68, 68, 0.8);
      color: white;
      font-weight: bold;
    }

    /* Animaciones suaves para clusters */
    .marker-cluster {
      transition: all 0.3s ease;
    }
    .marker-cluster:hover {
      transform: scale(1.1);
    }

    /* Bot√≥n de expandir mapa */
    .expand-map-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      z-index: 1000;
      background: white;
      border: none;
      border-radius: 10px;
      width: 45px;
      height: 45px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
      transition: all 0.3s ease;
      font-size: 1.2rem;
      color: #3b82f6;
    }

    .expand-map-btn:hover {
      background: #3b82f6;
      color: white;
      transform: scale(1.1);
    }

    /* Modo fullscreen del mapa */
    .map-wrapper.fullscreen {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      z-index: 9999 !important;
      background: white;
      border-radius: 0 !important;
    }

    .map-wrapper.fullscreen .map-canvas {
      height: 100vh !important;
      border-radius: 0 !important;
    }

    .map-wrapper.fullscreen .expand-map-btn {
      top: 20px;
      right: 20px;
      background: #ef4444;
      color: white;
    }

    .map-wrapper.fullscreen .expand-map-btn:hover {
      background: #dc2626;
    }
  </style>

  <script>
    // Funci√≥n para expandir/contraer el mapa
    function toggleMapFullscreen() {
      const mapWrapper = document.getElementById('map-wrapper');
      const btn = document.getElementById('expand-map-btn');
      const icon = btn.querySelector('i');
      
      mapWrapper.classList.toggle('fullscreen');
      
      if (mapWrapper.classList.contains('fullscreen')) {
        icon.className = 'fas fa-compress';
        btn.title = 'Contraer mapa';
        document.body.style.overflow = 'hidden';
      } else {
        icon.className = 'fas fa-expand';
        btn.title = 'Expandir mapa';
        document.body.style.overflow = '';
      }
      
      // Invalidar tama√±o del mapa para que se redibuje correctamente
      if (clientMap) {
        setTimeout(() => {
          clientMap.invalidateSize();
        }, 300);
      }
    }

    // Cerrar fullscreen con tecla Escape
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        const mapWrapper = document.getElementById('map-wrapper');
        if (mapWrapper && mapWrapper.classList.contains('fullscreen')) {
          toggleMapFullscreen();
        }
      }
    });

    // Inicializar mapa de clientes
    let clientMap = null;
    let markersLayer = null;

    function initializeClientMap() {
      // Configurar iconos de Leaflet para evitar errores de Tracking Prevention
      delete L.Icon.Default.prototype._getIconUrl;
      L.Icon.Default.mergeOptions({
        iconRetinaUrl: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iNDEiIHZpZXdCb3g9IjAgMCAyNSA0MSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEyLjUgMEMxOS40MDM2IDAgMjUgNS41OTY0NCAyNSAxMi41QzI1IDE5LjQwMzYgMTkuNDAzNiAyNSAxMi41IDI1QzUuNTk2NDQgMjUgMCAxOS40MDM2IDAgMTIuNUMwIDUuNTk2NDQgNS41OTY0NCAwIDEyLjUgMFoiIGZpbGw9IiMzMzc0RkYiLz4KPHBhdGggZD0iTTEyLjUgNDFMMTcuNSAyNUg3LjVMMTIuNSA0MVoiIGZpbGw9IiMzMzc0RkYiLz4KPC9zdmc+',
        iconUrl: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iNDEiIHZpZXdCb3g9IjAgMCAyNSA0MSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEyLjUgMEMxOS40MDM2IDAgMjUgNS41OTY0NCAyNSAxMi41QzI1IDE5LjQwMzYgMTkuNDAzNiAyNSAxMi41IDI1QzUuNTk2NDQgMjUgMCAxOS40MDM2IDAgMTIuNUMwIDUuNTk2NDQgNS41OTY0NCAwIDEyLjUgMFoiIGZpbGw9IiMzMzc0RkYiLz4KPHBhdGggZD0iTTEyLjUgNDFMMTcuNSAyNUg3LjVMMTIuNSA0MVoiIGZpbGw9IiMzMzc0RkYiLz4KPC9zdmc+',
        shadowUrl: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDEiIGhlaWdodD0iNDEiIHZpZXdCb3g9IjAgMCA0MSA0MSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGVsbGlwc2UgY3g9IjIwLjUiIGN5PSIzNyIgcng9IjE4IiByeT0iNCIgZmlsbD0iYmxhY2siIGZpbGwtb3BhY2l0eT0iMC4zIi8+Cjwvc3ZnPg==',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });

      // Crear el mapa centrado en Estados Unidos
      clientMap = L.map('usa-map').setView([39.8283, -98.5795], 4);

      // Agregar tiles del mapa
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: ' OpenStreetMap contributors',
        maxZoom: 18
      }).addTo(clientMap);

      // Crear cluster group para optimizar rendimiento con muchos marcadores
      markersLayer = L.markerClusterGroup({
        chunkedLoading: true,
        chunkInterval: 200,
        chunkDelay: 50,
        maxClusterRadius: 50,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        removeOutsideVisibleBounds: true,
        animate: true,
        animateAddingMarkers: false
      }).addTo(clientMap);

      // Cargar datos de clientes
      loadClientLocations();
    }

    async function loadClientLocations() {
      try {
        console.log('[Map] üó∫Ô∏è Iniciando carga de ubicaciones de clientes...');
        
        // Obtener TODOS los datos de leads y customers - probando diferentes par√°metros
        console.log('[Map] üîç Probando diferentes endpoints para obtener TODOS los registros...');
        
        const [leadsResponse, customersResponse] = await Promise.all([
          fetch('/api/leads?allData=true&noFilter=true&skipDate=true&limit=99999&page=1'),
          fetch('/api/customers?allData=true&noFilter=true&skipDate=true&limit=99999&page=1')
        ]);
        
        let allRecords = [];
        
        // Procesar leads
        if (leadsResponse.ok) {
          const leadsData = await leadsResponse.json();
          console.log('[Map] üîç Estructura completa de respuesta leads:', leadsData);
          let leads = [];
          if (Array.isArray(leadsData)) {
            leads = leadsData;
          } else if (leadsData.data && Array.isArray(leadsData.data)) {
            leads = leadsData.data;
          } else if (leadsData.leads && Array.isArray(leadsData.leads)) {
            leads = leadsData.leads;
          }
          allRecords = allRecords.concat(leads);
          console.log('[Map] üìä Cargados', leads.length, 'leads');
          
          // Verificar si hay informaci√≥n de paginaci√≥n
          if (leadsData.total) {
            console.log('[Map] üìÑ Total disponible en servidor:', leadsData.total);
          }
          if (leadsData.totalCount) {
            console.log('[Map] üìÑ Total count:', leadsData.totalCount);
          }
        } else {
          console.log('[Map] ‚ùå Error en respuesta leads:', leadsResponse.status, leadsResponse.statusText);
        }
        
        // Procesar customers con paginaci√≥n
        if (customersResponse.ok) {
          const customersData = await customersResponse.json();
          console.log('[Map] üîç Estructura de respuesta customers:', customersData);
          
          let customers = [];
          if (Array.isArray(customersData)) {
            customers = customersData;
          } else if (customersData.data && Array.isArray(customersData.data)) {
            customers = customersData.data;
          } else if (customersData.customers && Array.isArray(customersData.customers)) {
            customers = customersData.customers;
          } else if (customersData.leads && Array.isArray(customersData.leads)) {
            customers = customersData.leads; // ¬°AQU√ç ESTABAN LOS DATOS!
          }
          
          allRecords = allRecords.concat(customers);
          console.log('[Map] üë• Cargados', customers.length, 'customers de p√°gina 1');
          
          // Si hay m√°s p√°ginas, cargar todas
          if (customersData.pages && customersData.pages > 1) {
            console.log(`[Map] üìÑ Detectadas ${customersData.pages} p√°ginas, cargando p√°ginas restantes...`);
            
            for (let page = 2; page <= customersData.pages; page++) {
              try {
                const pageResponse = await fetch(`/api/customers?allData=true&noFilter=true&skipDate=true&limit=99999&page=${page}`);
                if (pageResponse.ok) {
                  const pageData = await pageResponse.json();
                  let pageCustomers = [];
                  
                  if (pageData.leads && Array.isArray(pageData.leads)) {
                    pageCustomers = pageData.leads;
                  } else if (pageData.data && Array.isArray(pageData.data)) {
                    pageCustomers = pageData.data;
                  }
                  
                  allRecords = allRecords.concat(pageCustomers);
                  console.log(`[Map] üë• Cargados ${pageCustomers.length} customers de p√°gina ${page}`);
                }
              } catch (error) {
                console.error(`[Map] ‚ùå Error cargando p√°gina ${page}:`, error);
              }
            }
          }
        } else {
          console.log('[Map] ‚ùå Error en respuesta customers:', customersResponse.status, customersResponse.statusText);
        }

        console.log('[Map] üìç TOTAL DE REGISTROS CARGADOS:', allRecords.length);
        
        // VERIFICAR QUE TENEMOS TODOS LOS DATOS
        console.log('[Map] üîç VERIFICANDO COMPLETITUD DE DATOS...');
        
        // Usar los datos ya cargados para verificar totales
        let expectedTotal = 0;
        
        // Re-fetch solo para obtener metadatos de totales
        try {
          const leadsMetaResponse = await fetch('/api/leads?allData=true&noFilter=true&skipDate=true&limit=1&page=1');
          if (leadsMetaResponse.ok) {
            const leadsMetaData = await leadsMetaResponse.json();
            if (leadsMetaData.total) expectedTotal += leadsMetaData.total;
          }
          
          const customersMetaResponse = await fetch('/api/customers?allData=true&noFilter=true&skipDate=true&limit=1&page=1');
          if (customersMetaResponse.ok) {
            const customersMetaData = await customersMetaResponse.json();
            if (customersMetaData.total) expectedTotal += customersMetaData.total;
          }
        } catch (metaError) {
          console.warn('[Map] ‚ö†Ô∏è No se pudieron obtener metadatos del servidor:', metaError);
        }
        
        console.log('[Map] üìä TOTAL ESPERADO DEL SERVIDOR:', expectedTotal);
        console.log('[Map] üìä TOTAL CARGADO:', allRecords.length);
        
        if (expectedTotal > 0) {
          const completeness = ((allRecords.length / expectedTotal) * 100).toFixed(1);
          console.log(`[Map] üìà COMPLETITUD: ${completeness}% (${allRecords.length}/${expectedTotal})`);
          
          if (allRecords.length < expectedTotal) {
            console.warn(`[Map] ‚ö†Ô∏è FALTAN ${expectedTotal - allRecords.length} REGISTROS`);
          } else if (allRecords.length > expectedTotal) {
            console.warn(`[Map] ‚ö†Ô∏è HAY ${allRecords.length - expectedTotal} REGISTROS EXTRA (posibles duplicados)`);
          } else {
            console.log('[Map] ‚úÖ TODOS LOS REGISTROS CARGADOS CORRECTAMENTE');
          }
        }
        
        // INVESTIGAR DUPLICADOS
        console.log('[Map] üîç INVESTIGANDO DUPLICADOS...');
        const uniqueIds = new Set();
        const duplicates = [];
        
        allRecords.forEach((record, index) => {
          const id = record._id || record.id;
          if (uniqueIds.has(id)) {
            duplicates.push({ index, id, record });
          } else {
            uniqueIds.add(id);
          }
        });
        
        console.log('[Map] üìä REGISTROS √öNICOS:', uniqueIds.size);
        console.log('[Map] üìä DUPLICADOS ENCONTRADOS:', duplicates.length);
        if (duplicates.length > 0) {
          console.log('[Map] üîç Primeros 5 duplicados:', duplicates.slice(0, 5));
          
          // ELIMINAR DUPLICADOS
          console.log('[Map] üßπ Eliminando duplicados...');
          const uniqueRecords = [];
          const seenIds = new Set();
          
          allRecords.forEach(record => {
            const id = record._id || record.id;
            if (!seenIds.has(id)) {
              seenIds.add(id);
              uniqueRecords.push(record);
            }
          });
          
          allRecords = uniqueRecords;
          console.log('[Map] ‚úÖ Registros despu√©s de eliminar duplicados:', allRecords.length);
        }
        
        // Procesar ubicaciones con geocodificaci√≥n completa
        await processClientLocationsComplete(allRecords);
        
      } catch (error) {
        console.error('[Map] ‚ùå Error cargando ubicaciones:', error);
      }
    }

    async function processClientLocationsComplete(allRecords) {
      const stateStats = {};
      const validLocations = [];
      
      console.log('[Map] üìä TOTAL REGISTROS RECIBIDOS:', allRecords.length);
      let addressesFiltered = 0;
      let addressesProcessed = 0;
      let geocodedCount = 0;
      
      // Cargar cache de geocodificaci√≥n desde localStorage
      loadGeocodeCache();
      
      // Procesar todas las direcciones
      for (const record of allRecords) {
        const address = record.direccion || record.address || record.ubicacion || '';
        if (!address || address.trim().length < 5) {
          addressesFiltered++;
          continue;
        }
        addressesProcessed++;

        try {
          // Extraer informaci√≥n b√°sica de la direcci√≥n
          const locationInfo = parseAddress(address);
          const stateName = locationInfo.state || 'Otros/Internacional';
          
          // Contar TODAS las direcciones
          if (!stateStats[stateName]) {
            stateStats[stateName] = {
              count: 0,
              cities: new Set(),
              zipCodes: new Set()
            };
          }
          
          stateStats[stateName].count++;
          if (locationInfo.city) stateStats[stateName].cities.add(locationInfo.city);
          if (locationInfo.zipCode) stateStats[stateName].zipCodes.add(locationInfo.zipCode);
          
          validLocations.push({
            address: address,
            state: stateName,
            city: locationInfo.city,
            zipCode: locationInfo.zipCode,
            record: record,
            geocoded: false,
            coordinates: null
          });
          
        } catch (error) {
          console.warn('[Map] Error procesando direcci√≥n:', address, error);
          
          // Incluso si hay error, agregar a "Otros"
          if (!stateStats['Otros/Internacional']) {
            stateStats['Otros/Internacional'] = {
              count: 0,
              cities: new Set(),
              zipCodes: new Set()
            };
          }
          stateStats['Otros/Internacional'].count++;
          
          validLocations.push({
            address: address,
            state: 'Otros/Internacional',
            city: null,
            zipCode: null,
            record: record,
            geocoded: false,
            coordinates: null
          });
        }
      }

      console.log('[Map] üìã RESUMEN PROCESAMIENTO:');
      console.log('[Map] - Direcciones filtradas (muy cortas):', addressesFiltered);
      console.log('[Map] - Direcciones procesadas:', addressesProcessed);
      console.log('[Map] - Ubicaciones v√°lidas creadas:', validLocations.length);
      
      // Verificar suma total
      const totalFromStats = Object.values(stateStats).reduce((sum, stat) => sum + stat.count, 0);
      console.log('[Map] - SUMA TOTAL DE ESTAD√çSTICAS:', totalFromStats);
      console.log('[Map] - DIFERENCIA:', allRecords.length - totalFromStats);
      console.log('[Map] - DESGLOSE POR ESTADO:');
      Object.entries(stateStats).forEach(([state, stats]) => {
        console.log(`[Map]   ${state}: ${stats.count} direcciones`);
      });
      
      // Mostrar resumen final
      if (window.unparsedAddressCount) {
        console.log(`[Map] ‚ö†Ô∏è TOTAL DE DIRECCIONES SIN ESTADO DETECTADO: ${window.unparsedAddressCount}`);
      }
      
      // Actualizar estad√≠sticas en el panel lateral
      updateStatsPanel(stateStats, validLocations.length);

      // Mostrar marcadores inmediatamente con coordenadas de estado
      addMarkersImmediately(validLocations);
      
      // Geocodificaci√≥n en segundo plano deshabilitada temporalmente para debugging
      console.log('[Map] üîç Geocodificaci√≥n en segundo plano deshabilitada temporalmente');
      // setTimeout(() => {
      //   geocodifyInBackground(validLocations);
      // }, 5000);
    }

    function parseAddress(address) {
      // Parser mejorado para direcciones de EE.UU.
      const addressUpper = address.toUpperCase();
      
      // Extraer c√≥digo postal (5 d√≠gitos)
      const zipMatch = address.match(/\b(\d{5})(?:-\d{4})?\b/);
      const zipCode = zipMatch ? zipMatch[1] : null;
      
      // Estados de EE.UU. (abreviaciones comunes)
      const stateAbbreviations = {
        'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas', 'CA': 'California',
        'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware', 'FL': 'Florida', 'GA': 'Georgia',
        'HI': 'Hawaii', 'ID': 'Idaho', 'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa',
        'KS': 'Kansas', 'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',
        'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi', 'MO': 'Missouri',
        'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada', 'NH': 'New Hampshire', 'NJ': 'New Jersey',
        'NM': 'New Mexico', 'NY': 'New York', 'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio',
        'OK': 'Oklahoma', 'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',
        'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah', 'VT': 'Vermont',
        'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia', 'WI': 'Wisconsin', 'WY': 'Wyoming'
      };
      
      let state = null;
      let city = null;
      
      // Buscar abreviaci√≥n de estado con patrones mejorados
      for (const [abbr, fullName] of Object.entries(stateAbbreviations)) {
        // Patrones m√°s flexibles para encontrar el estado
        const patterns = [
          new RegExp(`\\b${abbr}\\s+\\d{5}`, 'i'), // MA 01105
          new RegExp(`\\s${abbr}\\s*$`, 'i'),      // termina con MA
          new RegExp(`\\s${abbr}\\s+`, 'i'),       // MA seguido de espacio
          new RegExp(`\\s${abbr},`, 'i'),          // MA,
          new RegExp(`\\b${abbr}\\b`, 'i'),        // MA como palabra completa
          new RegExp(`\\s${abbr}\\s+\\d{5}`, 'i')  // SAN JOSE CA 95112
        ];
        
        if (patterns.some(pattern => addressUpper.match(pattern))) {
          state = fullName;
          
          // Extraer ciudad - buscar la palabra antes del estado
          const stateRegex = new RegExp(`\\b${abbr}\\b`, 'i');
          const beforeState = address.split(stateRegex)[0];
          
          // Buscar la √∫ltima palabra/frase que parece una ciudad
          const cityMatch = beforeState.match(/([A-Za-z\s]+?)(?:\s+APT\s+|\s+UNIT\s+|\s+#|\s*,?\s*)?$/i);
          if (cityMatch) {
            city = cityMatch[1].trim().replace(/,$/, '').replace(/\s+/g, ' ');
          }
          break;
        }
      }
      
      // Si no se encontr√≥ estado, intentar con nombres completos
      if (!state) {
        for (const [abbr, fullName] of Object.entries(stateAbbreviations)) {
          if (addressUpper.includes(fullName.toUpperCase())) {
            state = fullName;
            break;
          }
        }
      }
      
      // Log para debugging
      if (!state) {
        if (!window.unparsedAddressCount) window.unparsedAddressCount = 0;
        window.unparsedAddressCount++;
        if (window.unparsedAddressCount <= 10) {
          console.log(`[Map] üîç No se pudo detectar estado en (${window.unparsedAddressCount}):`, address);
        }
      }
      
      return { state, city, zipCode };
    }

    function updateStatsPanel(stateStats, totalClients) {
      // Total de clientes removido del panel
      
      // Ordenar estados por n√∫mero de clientes
      const sortedStates = Object.entries(stateStats)
        .sort(([,a], [,b]) => b.count - a.count); // Mostrar todos los estados
      
      const statsContainer = document.getElementById('states-stats');
      statsContainer.innerHTML = '';
      
      sortedStates.forEach(([stateName, stats], index) => {
        const percentage = ((stats.count / totalClients) * 100).toFixed(1);
        const stateAbbr = getStateAbbreviation(stateName);
        
        const stateElement = document.createElement('div');
        stateElement.className = 'state-item';
        stateElement.innerHTML = `
          <div class="state-info">
            <div class="state-flag">${stateAbbr}</div>
            <div class="state-details">
              <div class="state-name">${stateName}</div>
              <div class="state-code">${stats.cities.size} ciudades</div>
            </div>
          </div>
          <div class="state-stats">
            <div class="client-count">${stats.count}</div>
            <div class="client-percentage">${percentage}%</div>
          </div>
        `;
        
        statsContainer.appendChild(stateElement);
      });
    }

    function getStateAbbreviation(stateName) {
      const stateAbbr = {
        'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR', 'California': 'CA',
        'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE', 'Florida': 'FL', 'Georgia': 'GA',
        'Hawaii': 'HI', 'Idaho': 'ID', 'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA',
        'Kansas': 'KS', 'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',
        'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS', 'Missouri': 'MO',
        'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV', 'New Hampshire': 'NH', 'New Jersey': 'NJ',
        'New Mexico': 'NM', 'New York': 'NY', 'North Carolina': 'NC', 'North Dakota': 'ND', 'Ohio': 'OH',
        'Oklahoma': 'OK', 'Oregon': 'OR', 'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC',
        'South Dakota': 'SD', 'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT', 'Vermont': 'VT',
        'Virginia': 'VA', 'Washington': 'WA', 'West Virginia': 'WV', 'Wisconsin': 'WI', 'Wyoming': 'WY'
      };
      return stateAbbr[stateName] || stateName.substring(0, 2).toUpperCase();
    }

    // Cache persistente para geocodificaci√≥n
    let geocodeCache = new Map();
    
    function loadGeocodeCache() {
      try {
        const cached = localStorage.getItem('geocodeCache');
        if (cached) {
          const data = JSON.parse(cached);
          geocodeCache = new Map(data);
          console.log('[Map] üíæ Cache cargado:', geocodeCache.size, 'direcciones');
        }
      } catch (error) {
        console.warn('[Map] Error cargando cache:', error);
        geocodeCache = new Map();
      }
    }
    
    function saveGeocodeCache() {
      try {
        const data = Array.from(geocodeCache.entries());
        localStorage.setItem('geocodeCache', JSON.stringify(data));
        console.log('[Map] üíæ Cache guardado:', geocodeCache.size, 'direcciones');
      } catch (error) {
        console.warn('[Map] Error guardando cache:', error);
      }
    }

    async function addAllMarkersWithGeocoding(locations) {
      // Limpiar marcadores existentes
      markersLayer.clearLayers();
      
      console.log('[Map] üó∫Ô∏è Iniciando geocodificaci√≥n completa de', locations.length, 'ubicaciones...');
      
      // Coordenadas de respaldo por estado
      const stateCoordinates = {
        'Alabama': [32.318, -86.902], 'Alaska': [64.0685, -152.2782], 'Arizona': [34.2744, -111.2847], 
        'Arkansas': [35.2010, -92.4426], 'California': [36.7783, -119.4179], 'Colorado': [39.5501, -105.7821],
        'Connecticut': [41.6032, -73.0877], 'Delaware': [38.9108, -75.5277], 'Florida': [27.7663, -81.6868],
        'Georgia': [32.1656, -82.9001], 'Hawaii': [19.8968, -155.5828], 'Idaho': [44.0682, -114.7420],
        'Illinois': [40.6331, -89.3985], 'Indiana': [40.2732, -86.1349], 'Iowa': [41.8780, -93.0977],
        'Kansas': [38.5266, -96.7265], 'Kentucky': [37.8393, -84.2700], 'Louisiana': [30.9843, -91.9623],
        'Maine': [45.2538, -69.4455], 'Maryland': [39.0458, -76.6413], 'Massachusetts': [42.4072, -71.3824],
        'Michigan': [44.3467, -85.4102], 'Minnesota': [46.7296, -94.6859], 'Mississippi': [32.3547, -89.3985],
        'Missouri': [37.9643, -91.8318], 'Montana': [47.0527, -109.6333], 'Nebraska': [41.4925, -99.9018],
        'Nevada': [38.8026, -116.4194], 'New Hampshire': [43.1939, -71.5724], 'New Jersey': [40.0583, -74.4057],
        'New Mexico': [34.5199, -105.8701], 'New York': [43.2994, -74.2179], 'North Carolina': [35.7596, -79.0193],
        'North Dakota': [47.6201, -100.5407], 'Ohio': [40.4173, -82.9071], 'Oklahoma': [35.0078, -97.0929],
        'Oregon': [43.8041, -120.5542], 'Pennsylvania': [41.2033, -77.1945], 'Rhode Island': [41.5801, -71.4774],
        'South Carolina': [33.8361, -81.1637], 'South Dakota': [43.9695, -99.9018], 'Tennessee': [35.5175, -86.5804],
        'Texas': [31.9686, -99.9018], 'Utah': [39.3210, -111.0937], 'Vermont': [44.2601, -72.5806],
        'Virginia': [37.4316, -78.6569], 'Washington': [47.2529, -120.7401], 'West Virginia': [38.6409, -80.6227],
        'Wisconsin': [43.7844, -88.7879], 'Wyoming': [43.0759, -107.2903],
        'Otros/Internacional': [39.8283, -98.5795]
      };
      
      let geocodedCount = 0;
      let fallbackCount = 0;
      let totalMarkers = 0;
      
      // Procesar en lotes m√°s peque√±os para no saturar la API
      const batchSize = 3; // Reducir lotes para evitar rate limiting
      const delay = 1000; // Aumentar delay entre requests (1 segundo)
      
      for (let i = 0; i < locations.length; i += batchSize) {
        const batch = locations.slice(i, i + batchSize);
        
        // Procesar lote en paralelo
        const batchPromises = batch.map(async (location, batchIndex) => {
          try {
            let coordinates = null;
            
            // Intentar obtener coordenadas precisas
            const cachedCoords = geocodeCache.get(location.address);
            if (cachedCoords) {
              coordinates = cachedCoords;
              geocodedCount++;
            } else {
              // Geocodificar nueva direcci√≥n
              coordinates = await geocodeAddressWithRetry(location.address);
              if (coordinates) {
                geocodeCache.set(location.address, coordinates);
                geocodedCount++;
              }
            }
            
            // Si no se pudo geocodificar, usar coordenadas del estado
            if (!coordinates) {
              const stateCoords = stateCoordinates[location.state];
              if (stateCoords) {
                // Agregar variaci√≥n aleatoria peque√±a
                const offset = 0.1;
                coordinates = {
                  lat: stateCoords[0] + (Math.random() - 0.5) * offset,
                  lng: stateCoords[1] + (Math.random() - 0.5) * offset
                };
                fallbackCount++;
              }
            }
            
            // Crear marcador si tenemos coordenadas
            if (coordinates) {
              const marker = L.marker([coordinates.lat, coordinates.lng])
                .bindPopup(`
                  <div style="font-family: 'Roboto', sans-serif; max-width: 250px;">
                    <h4 style="margin: 0 0 8px 0; color: #1e293b; font-size: 1rem;">
                      ${location.record.nombre_cliente || location.record.name || 'Cliente'}
                    </h4>
                    <p style="margin: 0 0 4px 0; color: #64748b; font-size: 0.85rem;">
                      <i class="fas fa-map-marker-alt" style="color: #3b82f6; margin-right: 6px;"></i>
                      ${location.address}
                    </p>
                    <p style="margin: 0 0 4px 0; color: #64748b; font-size: 0.85rem;">
                      <i class="fas fa-phone" style="color: #10b981; margin-right: 6px;"></i>
                      ${location.record.telefono || location.record.phone || 'N/A'}
                    </p>
                    <p style="margin: 0; color: #64748b; font-size: 0.8rem;">
                      <i class="fas fa-map" style="color: #f59e0b; margin-right: 6px;"></i>
                      ${location.city ? location.city + ', ' : ''}${location.state}
                    </p>
                  </div>
                `);
              
              markersLayer.addLayer(marker);
              totalMarkers++;
            }
            
          } catch (error) {
            console.warn('[Map] Error procesando ubicaci√≥n:', location.address, error);
          }
        });
        
        // Esperar a que termine el lote
        await Promise.all(batchPromises);
        
        // Mostrar progreso
        const progress = Math.min(i + batchSize, locations.length);
        console.log(`[Map] üìç Progreso: ${progress}/${locations.length} (${Math.round(progress/locations.length*100)}%)`);
        
        // Pausa entre lotes
        if (i + batchSize < locations.length) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
      
      // Guardar cache actualizado
      saveGeocodeCache();
      
      console.log('[Map] ‚úÖ GEOCODIFICACI√ìN COMPLETADA:');
      console.log(`[Map] - Total marcadores: ${totalMarkers}`);
      console.log(`[Map] - Geocodificados precisos: ${geocodedCount}`);
      console.log(`[Map] - Coordenadas de respaldo: ${fallbackCount}`);
      console.log(`[Map] - Cache total: ${geocodeCache.size} direcciones`);
    }
    
    // Funci√≥n opcional para geocodificaci√≥n precisa en segundo plano
    async function geocodePreciseLocations(locations) {
      const maxPreciseLocations = Math.min(locations.length, 50); // Limitar para no saturar
      
      for (let i = 0; i < maxPreciseLocations; i++) {
        try {
          const location = locations[i];
          const coords = await geocodeAddress(location.address);
          
          if (coords) {
            // Actualizar marcador existente con ubicaci√≥n precisa
            // (esto es opcional y se ejecuta en segundo plano)
          }
          
          // Pausa para no saturar el servicio
          await new Promise(resolve => setTimeout(resolve, 200));
          
        } catch (error) {
          console.warn('[Map] Error en geocodificaci√≥n precisa:', error);
        }
      }
    }

    async function geocodeAddressWithRetry(address) {
      // Funci√≥n con reintentos para geocodificaci√≥n
      const maxRetries = 2;
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const result = await geocodeAddress(address);
          return result;
        } catch (error) {
          if (attempt === maxRetries - 1) {
            console.warn('[Map] Geocodificaci√≥n fall√≥ despu√©s de', maxRetries, 'intentos:', address);
            return null;
          }
          // Esperar antes del siguiente intento
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      }
    }

    async function geocodeAddress(address) {
      // Verificar cache primero
      if (geocodeCache.has(address)) {
        return geocodeCache.get(address);
      }

      try {
        // Limpiar y formatear la direcci√≥n
        const cleanAddress = address.trim().replace(/\s+/g, ' ');
        
        // Usar Nominatim (OpenStreetMap) para geocodificaci√≥n
        const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=1&q=${encodeURIComponent(cleanAddress)}`;
        
        const response = await fetch(url, {
          headers: {
            'User-Agent': 'CRM-Dashboard/1.0'
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data && data.length > 0) {
          const result = {
            lat: parseFloat(data[0].lat),
            lng: parseFloat(data[0].lon)
          };
          
          // Guardar en cache
          geocodeCache.set(address, result);
          
          return result;
        } else {
          console.warn('[Geocode] No se encontraron coordenadas para:', address);
          geocodeCache.set(address, null);
          return null;
        }
        
      } catch (error) {
        console.error('[Geocode] Error:', error);
        geocodeCache.set(address, null);
        return null;
      }
    }

    // Inicializar el mapa cuando se cargue la p√°gina
    document.addEventListener('DOMContentLoaded', function() {
      // Esperar un poco para que se cargue todo el contenido
      setTimeout(initializeClientMap, 1000);
    });
  </script>
</body>
</html>